"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/react/cjs/react.production.js
  var require_react_production = __commonJS({
    "node_modules/react/cjs/react.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      };
      var assign = Object.assign;
      var emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      var ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, self, source, owner, props) {
        self = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== self ? self : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          void 0,
          oldElement.props
        );
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
      }
      function noop$1() {
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      function noop() {
      }
      exports.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size) {
          return ReactSharedInternals.H.useMemoCache(size);
        }
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = void 0;
        if (null != config)
          for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i = 0; i < propName; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, void 0, void 0, owner, props);
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      exports.createElement = function(type, config, children) {
        var propName, props = {}, key = null;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, void 0, void 0, null, props);
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      exports.isValidElement = isValidElement;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      exports.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      exports.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, createDeps, update) {
        var dispatcher = ReactSharedInternals.H;
        if ("function" === typeof update)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create, createDeps);
      };
      exports.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
      };
      exports.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      exports.version = "19.1.0";
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.production.js
  var require_scheduler_production = __commonJS({
    "node_modules/scheduler/cjs/scheduler.production.js"(exports) {
      "use strict";
      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for (; 0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last))
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
      }
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var localPerformance;
      var localDate;
      var initialTime;
      var taskQueue = [];
      var timerQueue = [];
      var taskIdCounter = 1;
      var currentTask = null;
      var currentPriorityLevel = 3;
      var isPerformingWork = false;
      var isHostCallbackScheduled = false;
      var isHostTimeoutScheduled = false;
      var needsPaint = false;
      var localSetTimeout = "function" === typeof setTimeout ? setTimeout : null;
      var localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null;
      var localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false;
      var taskTimeoutID = -1;
      var frameInterval = 5;
      var startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      var channel;
      var port;
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_scheduler_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.production.js
  var require_react_dom_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom.production.js"(exports) {
      "use strict";
      var React4 = require_react();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop() {
      }
      var Internals = {
        d: {
          f: noop,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      };
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React4.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container2) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container2 || 1 !== container2.nodeType && 9 !== container2.nodeType && 11 !== container2.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container2, null, key);
      };
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else Internals.d.m(href);
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      exports.version = "19.1.0";
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.production.js
  var require_react_dom_client_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.production.js"(exports) {
      "use strict";
      var Scheduler = require_scheduler();
      var React4 = require_react();
      var ReactDOM = require_react_dom();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b.return) a = parentA, b = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (child$0 === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      var assign = Object.assign;
      var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.tracing_marker");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      Symbol.for("react.view_transition");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      var isArrayImpl = Array.isArray;
      var ReactSharedInternals = React4.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null
      };
      var valueStack = [];
      var index = -1;
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor) {
        0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
      }
      function push(cursor, value) {
        index++;
        valueStack[index] = cursor.current;
        cursor.current = value;
      }
      var contextStackCursor = createCursor(null);
      var contextFiberStackCursor = createCursor(null);
      var rootInstanceStackCursor = createCursor(null);
      var hostTransitionProviderCursor = createCursor(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
            break;
          default:
            if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
            else
              switch (fiber) {
                case "svg":
                  fiber = 1;
                  break;
                case "math":
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;
      var cancelCallback$1 = Scheduler.unstable_cancelCallback;
      var shouldYield = Scheduler.unstable_shouldYield;
      var requestPaint = Scheduler.unstable_requestPaint;
      var now = Scheduler.unstable_now;
      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
      var NormalPriority$1 = Scheduler.unstable_NormalPriority;
      var LowPriority = Scheduler.unstable_LowPriority;
      var IdlePriority = Scheduler.unstable_IdlePriority;
      var log$1 = Scheduler.log;
      var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
      var rendererID = null;
      var injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
          }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      var nextTransitionLane = 256;
      var nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 4194048;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root2.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
        root2 = root2.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root2, renderLanes2) {
        return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root2, updateLane) {
        root2.pendingLanes |= updateLane;
        268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
      }
      function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root2.pendingLanes;
        root2.pendingLanes = remainingLanes;
        root2.suspendedLanes = 0;
        root2.pingedLanes = 0;
        root2.warmLanes = 0;
        root2.expiredLanes &= remainingLanes;
        root2.entangledLanes &= remainingLanes;
        root2.errorRecoveryDisabledLanes &= remainingLanes;
        root2.shellSuspendCounter = 0;
        var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
          entanglements[index$5] = 0;
          expirationTimes[index$5] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$5];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
              var update = hiddenUpdatesForLane[index$5];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
        root2.pendingLanes |= spawnedLane;
        root2.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root2.entangledLanes |= spawnedLane;
        root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
      }
      function markRootEntangled(root2, entangledLanes) {
        var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
        for (root2 = root2.entanglements; rootEntangledLanes; ) {
          var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
          lane & entangledLanes | root2[index$6] & entangledLanes && (root2[index$6] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority, fn();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2);
      var internalInstanceKey = "__reactFiber$" + randomKey;
      var internalPropsKey = "__reactProps$" + randomKey;
      var internalContainerInstanceKey = "__reactContainer$" + randomKey;
      var internalEventHandlersKey = "__reactEvents$" + randomKey;
      var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
      var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
      var internalRootNodeResourcesKey = "__reactResources$" + randomKey;
      var internalHoistableMarker = "__reactMarker$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey]) return parentNode;
                targetNode = getParentSuspenseInstance(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root2) {
        var resources = root2[internalRootNodeResourcesKey];
        resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = true;
      }
      var allNativeEvents = /* @__PURE__ */ new Set();
      var registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      );
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        return false;
      }
      function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node.removeAttribute(name);
                return;
              case "boolean":
                var prefix$8 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
                  node.removeAttribute(name);
                  return;
                }
            }
            node.setAttribute(name, "" + value);
          }
      }
      function setValueForKnownAttribute(node, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttribute(name, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttributeNS(namespace, name, "" + value);
        }
      }
      var prefix;
      var suffix;
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      var reentry = false;
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$9) {
                      control = x$9;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$10) {
                    control = x$10;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          do
            info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        ), currentValue = "" + node[valueField];
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get = descriptor.get, set = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              node._valueTracker = null;
              delete node[valueField];
            }
          };
        }
      }
      function track(node) {
        node._valueTracker || (node._valueTracker = trackValueOnNode(node));
      }
      function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = node._valueTracker;
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), true) : false;
      }
      function getActiveElement(doc) {
        doc = doc || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc) return null;
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
            return;
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
      }
      function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i = 0; i < propValue.length; i++)
            multiple["$" + propValue[i]] = true;
          for (propValue = 0; propValue < node.length; propValue++)
            i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i = 0; i < node.length; i++) {
            if (node[i].value === propValue) {
              node[i].selected = true;
              setDefaultSelected && (node[i].defaultSelected = true);
              return;
            }
            null !== multiple || node[i].disabled || (multiple = node[i]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue) throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children)) {
              if (1 < children.length) throw Error(formatProdErrorMessage(93));
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      var unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      );
      function setValueForStyle(style2, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
      }
      function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && "object" !== typeof styles)
          throw Error(formatProdErrorMessage(62));
        node = node.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
          for (var styleName$16 in styles)
            styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
        } else
          for (var styleName$17 in styles)
            styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]);
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null;
      var restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ("radio" === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                props = props.querySelectorAll(
                  'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) + '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
          }
        }
      }
      var isInsideEventHandler = false;
      function batchedUpdates$1(fn, a, b) {
        if (isInsideEventHandler) return fn(a, b);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn(a);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
              for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
            inst = !props;
            break a;
          default:
            inst = false;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            formatProdErrorMessage(231, registrationName, typeof stateNode)
          );
        return stateNode;
      }
      var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var passiveBrowserEventsSupported = false;
      if (canUseDOM)
        try {
          options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      var options;
      var root = null;
      var startText = null;
      var fallbackText = null;
      function getData() {
        if (fallbackText) return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      };
      var SyntheticEvent = createSyntheticEvent(EventInterface);
      var UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 });
      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
      var lastMovementX;
      var lastMovementY;
      var lastMouseEvent;
      var MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      });
      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
      var DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 });
      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
      var FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 });
      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
      var AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
      var ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      });
      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
      var CompositionEventInterface = assign({}, EventInterface, { data: 0 });
      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
      var normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      });
      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
      var PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      });
      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
      var TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      });
      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
      var TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
      var WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
      var ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      });
      var SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface);
      var END_KEYCODES = [9, 13, 27, 32];
      var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
      var documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
      var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode);
      var SPACEBAR_CHAR = String.fromCharCode(32);
      var hasSpaceKeypress = false;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return 229 !== nativeEvent.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = false;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (32 !== nativeEvent.which) return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null;
      var activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        if (canUseDOM) {
          isSupported$jscomp$inline_417 = "oninput" in document;
          if (!isSupported$jscomp$inline_417) {
            element$jscomp$inline_418 = document.createElement("div");
            element$jscomp$inline_418.setAttribute("oninput", "return;");
            isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
          }
          JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
        } else JSCompiler_inline_result$jscomp$282 = false;
        isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
      }
      var JSCompiler_inline_result$jscomp$282;
      var isSupported$jscomp$inline_417;
      var element$jscomp$inline_418;
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; ) node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root2, offset) {
        var node = getLeafNode(root2);
        root2 = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root2 + node.textContent.length;
            if (root2 <= offset && nodeEnd >= offset)
              return { node, offset: offset - root2 };
            root2 = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode;
      var activeElement = null;
      var activeElementInst = null;
      var lastSelection = null;
      var mouseDown = false;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      var prefixedEventNames = {};
      var style = {};
      canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend");
      var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
      var ANIMATION_START = getVendorPrefixedEventName("animationstart");
      var TRANSITION_RUN = getVendorPrefixedEventName("transitionrun");
      var TRANSITION_START = getVendorPrefixedEventName("transitionstart");
      var TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel");
      var TRANSITION_END = getVendorPrefixedEventName("transitionend");
      var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
      var simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap();
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      var concurrentQueues = [];
      var concurrentQueuesIndex = 0;
      var concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_TYPE:
              return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_LIST_TYPE:
              return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
              );
              owner = null;
          }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiberImplClass(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      var forkStack = [];
      var forkStackIndex = 0;
      var treeForkProvider = null;
      var treeForkCount = 0;
      var idStack = [];
      var idStackIndex = 0;
      var treeContextProvider = null;
      var treeContextId = 1;
      var treeContextOverflow = "";
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index2 += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;
      var hydrationErrors = null;
      var rootOrSingletonContext = false;
      var HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error = Error(formatProdErrorMessage(418, ""));
        queueHydrationError(createCapturedValueAtFiber(error, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
        instance[internalInstanceKey] = fiber;
        instance[internalPropsKey] = props;
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", instance);
            listenToNonDelegatedEvent("close", instance);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", instance);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance);
            break;
          case "source":
            listenToNonDelegatedEvent("error", instance);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", instance);
            listenToNonDelegatedEvent("load", instance);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", instance);
            break;
          case "input":
            listenToNonDelegatedEvent("invalid", instance);
            initInput(
              instance,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            track(instance);
            break;
          case "select":
            listenToNonDelegatedEvent("invalid", instance);
            break;
          case "textarea":
            listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
        instance || throwOnHydrationMismatch(fiber);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return false;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          a: {
            fiber = fiber.nextSibling;
            for (tag = 0; fiber; ) {
              if (8 === fiber.nodeType)
                if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
                  if (0 === tag) {
                    nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                    break a;
                  }
                  tag--;
                } else
                  "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || tag++;
              fiber = fiber.nextSibling;
            }
            nextHydratableInstance = null;
          }
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      var valueCursor = createCursor(null);
      var currentlyRenderingFiber$1 = null;
      var lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      };
      var scheduleCallback$2 = Scheduler.unstable_scheduleCallback;
      var NormalPriority = Scheduler.unstable_NormalPriority;
      var CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      var currentEntangledListeners = null;
      var currentEntangledPendingCount = 0;
      var currentEntangledLane = 0;
      var currentEntangledActionThenable = null;
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460));
      var SuspenseyCommitException = Error(formatProdErrorMessage(474));
      var SuspenseActionException = Error(formatProdErrorMessage(542));
      var noopSuspenseyCommitThenable = { then: function() {
      } };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function noop$3() {
      }
      function trackUsedThenable(thenableState2, thenable, index2) {
        index2 = thenableState2[index2];
        void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$3, noop$3), thenable = index2);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var hasForceUpdate = false;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root2, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = false;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                updateLane = props;
                var instance = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress2 = update.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(instance, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      var currentTreeHiddenStackCursor = createCursor(null);
      var prevEntangledRenderLanesCursor = createCursor(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var renderLanes = 0;
      var currentlyRenderingFiber = null;
      var currentHook = null;
      var workInProgressHook = null;
      var didScheduleRenderPhaseUpdate = false;
      var didScheduleRenderPhaseUpdateDuringThisPass = false;
      var shouldDoubleInvokeUserFnsInHooksDEV = false;
      var localIdCounter = 0;
      var thenableIndexCounter$1 = 0;
      var thenableState$1 = null;
      var globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return false;
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter$1 = 0;
        thenableState$1 = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
          thenableIndexCounter$1 = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter$1 = localIdCounter = 0;
        thenableState$1 = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index2 = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        thenable = trackUsedThenable(thenableState$1, thenable, index2);
        index2 = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$32 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        var create = subscribeToStore.bind(null, fiber, hook, subscribe);
        updateEffectImpl(2048, 8, create, [subscribe]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
          } catch (error$38) {
            onActionError(actionQueue, node, error$38);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node, error);
          }
        ) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          createEffectInstance(),
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create, createDeps) {
        tag = { tag, create, deps: createDeps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
        return tag;
      }
      function createEffectInstance() {
        return { destroy: void 0, resource: void 0 };
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
        var hook = mountWorkInProgressHook();
        createDeps = void 0 === createDeps ? null : createDeps;
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          createEffectInstance(),
          create,
          createDeps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, createDeps) {
        mountEffectImpl(8390656, 8, create, createDeps);
      }
      function updateEffect(create, createDeps) {
        updateEffectImpl(2048, 8, create, createDeps);
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(4, 2, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(4, 4, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return create = create(), ref.current = create, function() {
            ref.current = null;
          };
      }
      function updateImperativeHandle(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
      }
      function mountDebugValue() {
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane()
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function noop$2() {
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action ? noop$2 : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
        dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root$41 = enqueueUpdate(provider, fiber, lane);
              null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root2, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
      var HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        },
        useLayoutEffect: function(create, deps) {
          return mountEffectImpl(4194308, 4, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          mountEffectImpl(4, 2, create, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "\xAB" + identifierPrefix + "R" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "\xBB";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "\xAB" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "\xBB";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
      };
      var HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      var HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      var thenableState = null;
      var thenableIndexCounter = 0;
      function unwrapThenable(thenable) {
        var index2 = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index2);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function resolveLazy(lazyType2) {
        var init = lazyType2._init;
        return init(lazyType2._payload);
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(true);
      var mountChildFibers = createChildReconciler(false);
      var suspenseHandlerStackCursor = createCursor(null);
      var shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushOffscreenSuspenseHandler(fiber) {
        if (22 === fiber.tag) {
          if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
            var current = fiber.alternate;
            null !== current && null !== current.memoizedState && (shellBoundary = fiber);
          }
        } else reuseSuspenseHandlerOnStack(fiber);
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor(0);
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback && null !== callback && (update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        workInProgress2 = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      function defaultOnUncaughtError(error) {
        reportGlobalError(error);
      }
      function defaultOnCaughtError(error) {
        console.error(error);
      }
      function defaultOnRecoverableError(error) {
        reportGlobalError(error);
      }
      function logUncaughtError(root2, errorInfo) {
        try {
          var onUncaughtError = root2.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function() {
            throw e$74;
          });
        }
      }
      function logCaughtError(root2, boundary, errorInfo) {
        try {
          var onCaughtError = root2.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$75) {
          setTimeout(function() {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root2, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root2, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error);
          };
          update.callback = function() {
            logCaughtError(root2, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          logCaughtError(root2, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root2, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root2.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root2,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461));
      var didReceiveUpdate = false;
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextChildren = workInProgress2.child = current.child;
              for (prevState = 0; null !== nextChildren; )
                prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
              workInProgress2.childLanes = prevState & ~nextProps;
            } else workInProgress2.childLanes = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              nextProps,
              renderLanes2
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress2));
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        return null;
      }
      function markRef(current, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
            if (isHydrating) {
              var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
              if (JSCompiler_temp$jscomp$0 = nextInstance) {
                c: {
                  JSCompiler_temp$jscomp$0 = nextInstance;
                  for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
                    if (!nextInstance) {
                      nextInstance = null;
                      break c;
                    }
                    JSCompiler_temp$jscomp$0 = getNextHydratable(
                      JSCompiler_temp$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_temp$jscomp$0) {
                      nextInstance = null;
                      break c;
                    }
                  }
                  nextInstance = JSCompiler_temp$jscomp$0;
                }
                null !== nextInstance ? (workInProgress2.memoizedState = {
                  dehydrated: nextInstance,
                  treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                  retryLane: 536870912,
                  hydrationErrors: null
                }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
                  18,
                  null,
                  null,
                  0
                ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
              }
              JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
            }
            nextInstance = workInProgress2.memoizedState;
            if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
              return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
            popSuspenseHandler(workInProgress2);
          }
          nextInstance = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextInstance },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
        }
        JSCompiler_temp$jscomp$0 = current.memoizedState;
        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              nextInstance
            ), showFallback = createFiberFromFragment(
              showFallback,
              nextInstance,
              renderLanes2,
              null
            ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextInstance)) {
            JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
            if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = "";
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
              throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            "$?" === nextInstance.data ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
              nextInstance.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes2,
            null
          ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
            baseLanes: nextInstance.baseLanes | renderLanes2,
            cachePool: JSCompiler_temp$jscomp$0
          }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        offscreenProps.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        };
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
        nextProps = suspenseStackCursor.current;
        if (0 !== (nextProps & 2))
          nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
        else {
          if (null !== current && 0 !== (current.flags & 128))
            a: for (current = workInProgress2.child; null !== current; ) {
              if (13 === current.tag)
                null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (19 === current.tag)
                scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (null !== current.child) {
                current.child.return = current;
                current = current.child;
                continue;
              }
              if (current === workInProgress2) break a;
              for (; null === current.sibling; ) {
                if (null === current.return || current.return === workInProgress2)
                  break a;
                current = current.return;
              }
              current.sibling.return = current.return;
              current = current.sibling;
            }
          nextProps &= 1;
        }
        push(suspenseStackCursor, nextProps);
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode
            );
            break;
          case "backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode
            );
            break;
          case "together":
            initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2)) return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 13:
            var state = workInProgress2.memoizedState;
            if (null !== state) {
              if (null !== state.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(current, workInProgress2, renderLanes2);
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state) break;
            else return null;
          case 22:
          case 23:
            return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              current = workInProgress2.pendingProps;
              var lazyComponent = workInProgress2.elementType, init = lazyComponent._init;
              lazyComponent = init(lazyComponent._payload);
              workInProgress2.type = lazyComponent;
              if ("function" === typeof lazyComponent)
                shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                ));
              else {
                if (void 0 !== lazyComponent && null !== lazyComponent) {
                  if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  } else if (init === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return lazyComponent = workInProgress2.type, init = resolveClassComponentProps(
              lazyComponent,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              lazyComponent,
              init,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current) throw Error(formatProdErrorMessage(387));
              lazyComponent = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              init = prevState.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, lazyComponent, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              lazyComponent = nextState.cache;
              pushProvider(workInProgress2, CacheContext, lazyComponent);
              lazyComponent !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              lazyComponent = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: lazyComponent,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  );
                  break a;
                } else if (lazyComponent !== init) {
                  init = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError(init);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  );
                  break a;
                } else {
                  current = workInProgress2.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    lazyComponent,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (lazyComponent === init) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(
                  current,
                  workInProgress2,
                  lazyComponent,
                  renderLanes2
                );
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current.memoizedProps,
              workInProgress2.pendingProps,
              current.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootInstanceStackCursor.current
            ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, init = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = init, nextHydratableInstance = getNextHydratable(
              lazyComponent.firstChild
            )) : nextHydratableInstance = init), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              if (init = lazyComponent = nextHydratableInstance)
                lazyComponent = canHydrateInstance(
                  lazyComponent,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                  lazyComponent.firstChild
                ), rootOrSingletonContext = false, init = true) : init = false;
              init || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            init = workInProgress2.type;
            prevState = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            lazyComponent = prevState.children;
            shouldSetTextContent(init, prevState) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && (init = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = init);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              lazyComponent,
              renderLanes2
            ) : reconcileChildren(
              current,
              workInProgress2,
              lazyComponent,
              renderLanes2
            ), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
              current,
              workInProgress2,
              lazyComponent.children,
              renderLanes2
            ), workInProgress2.child;
          case 9:
            return init = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
          case 31:
            return lazyComponent = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, lazyComponent = {
              mode: lazyComponent.mode,
              children: lazyComponent.children
            }, null === current ? (renderLanes2 = mountWorkInProgressOffscreenFiber(
              lazyComponent,
              renderLanes2
            ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2) : (renderLanes2 = createWorkInProgress(current.child, lazyComponent), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2), workInProgress2;
          case 22:
            return updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, prevState = createCache(), init.pooledCache = prevState, prevState.refCount++, null !== prevState && (init.pooledCacheLanes |= renderLanes2), init = prevState), workInProgress2.memoizedState = {
              parent: lazyComponent,
              cache: init
            }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, prevState = workInProgress2.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
          resource = suspenseHandlerStackCursor.current;
          if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
          workInProgress2.flags |= 8192;
        }
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$113 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$114 = completedWork.child; null !== child$114; )
            newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;
        else
          for (child$114 = completedWork.child; null !== child$114; )
            newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 31:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = rootInstanceStackCursor.current;
            var type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            renderLanes2 = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2, current);
              else {
                type = getOwnerDocumentFromRootContainer(
                  rootInstanceStackCursor.current
                );
                switch (current) {
                  case 1:
                    current = type.createElementNS(
                      "http://www.w3.org/2000/svg",
                      renderLanes2
                    );
                    break;
                  case 2:
                    current = type.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      renderLanes2
                    );
                    break;
                  default:
                    switch (renderLanes2) {
                      case "svg":
                        current = type.createElementNS(
                          "http://www.w3.org/2000/svg",
                          renderLanes2
                        );
                        break;
                      case "math":
                        current = type.createElementNS(
                          "http://www.w3.org/1998/Math/MathML",
                          renderLanes2
                        );
                        break;
                      case "script":
                        current = type.createElement("div");
                        current.innerHTML = "<script><\/script>";
                        current = current.removeChild(current.firstChild);
                        break;
                      case "select":
                        current = "string" === typeof newProps.is ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
                        newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                        break;
                      default:
                        current = "string" === typeof newProps.is ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
                    }
                }
                current[internalInstanceKey] = workInProgress2;
                current[internalPropsKey] = newProps;
                a: for (type = workInProgress2.child; null !== type; ) {
                  if (5 === type.tag || 6 === type.tag)
                    current.appendChild(type.stateNode);
                  else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                    type.child.return = type;
                    type = type.child;
                    continue;
                  }
                  if (type === workInProgress2) break a;
                  for (; null === type.sibling; ) {
                    if (null === type.return || type.return === workInProgress2)
                      break a;
                    type = type.return;
                  }
                  type.sibling.return = type.return;
                  type = type.sibling;
                }
                workInProgress2.stateNode = current;
                a: switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    current = !!newProps.autoFocus;
                    break a;
                  case "img":
                    current = true;
                    break a;
                  default:
                    current = false;
                }
                current && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            workInProgress2.flags &= -16777217;
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress2;
                current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                current || throwOnHydrationMismatch(workInProgress2);
              } else
                current = getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps
                ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              type = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type) throw Error(formatProdErrorMessage(318));
                  type = workInProgress2.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type) throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            if (renderLanes2) {
              newProps = workInProgress2.child;
              type = null;
              null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
              var cache$127 = null;
              null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
              cache$127 !== type && (newProps.flags |= 2048);
            }
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            type = workInProgress2.memoizedState;
            if (null === type) return bubbleProperties(workInProgress2), null;
            newProps = 0 !== (workInProgress2.flags & 128);
            cache$127 = type.rendering;
            if (null === cache$127)
              if (newProps) cutOffTailIfNeeded(type, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    cache$127 = findFirstSuspended(current);
                    if (null !== cache$127) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(type, false);
                      current = cache$127.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!newProps)
                if (current = findFirstSuspended(cache$127), null !== current) {
                  if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
              type.isBackwards ? (cache$127.sibling = workInProgress2.child, workInProgress2.child = cache$127) : (current = type.last, null !== current ? current.sibling = cache$127 : workInProgress2.child = cache$127, type.last = cache$127);
            }
            if (null !== type.tail)
              return workInProgress2 = type.tail, type.rendering = workInProgress2, type.tail = workInProgress2.sibling, type.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create = updateQueue.create, inst = updateQueue.inst;
                lastEffect = create();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error
                    );
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance.state = current.memoizedState;
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
          }
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              ref(null);
            } catch (error$143) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$143);
            }
          else ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          a: switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              props.autoFocus && instance.focus();
              break a;
            case "img":
              props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      var offscreenSubtreeIsHidden = false;
      var offscreenSubtreeWasHidden = false;
      var needsFormReset = false;
      var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
      var nextEffect = null;
      function commitBeforeMutationEffects(root2, firstChild) {
        root2 = root2.containerInfo;
        eventsEnabled = _enabled;
        root2 = getActiveElementDeep(root2);
        if (hasSelectionCapabilities(root2)) {
          if ("selectionStart" in root2)
            var JSCompiler_temp = {
              start: root2.selectionStart,
              end: root2.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection && 0 !== selection.rangeCount) {
                JSCompiler_temp = selection.anchorNode;
                var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                selection = selection.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                b: for (; ; ) {
                  for (var next; ; ) {
                    node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                    node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                    3 === node.nodeType && (length += node.nodeValue.length);
                    if (null === (next = node.firstChild)) break;
                    parentNode = node;
                    node = next;
                  }
                  for (; ; ) {
                    if (node === root2) break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                    if (null !== (next = node.nextSibling)) break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
                JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
            root2.return = firstChild, nextEffect = root2;
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root2 = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root2 & 1024) && null !== focusNode) {
                    root2 = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset,
                        JSCompiler_temp.elementType === JSCompiler_temp.type
                      );
                      root2 = selection.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        focusNode
                      );
                      selection.__reactInternalSnapshotBeforeUpdate = root2;
                    } catch (error) {
                      captureCommitPhaseError(
                        JSCompiler_temp,
                        JSCompiler_temp.return,
                        error
                      );
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root2 & 1024)) {
                    if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root2);
                    else if (1 === JSCompiler_temp)
                      switch (root2.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root2);
                          break;
                        default:
                          root2.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
              }
              root2 = firstChild.sibling;
              if (null !== root2) {
                root2.return = firstChild.return;
                nextEffect = root2;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$142) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$142
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null;
      var hostParentIsContainer = false;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
          }
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent) throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = false;
            root2 = childToDelete.alternate;
            null !== root2 && (root2.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13878)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root2) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b: switch (flags) {
                        case "title":
                          currentResource = hoistableRoot.getElementsByTagName("title")[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                            currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector("head > title")
                            );
                          setInitialProperties(currentResource, flags, current);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache(
                            "link",
                            "href",
                            hoistableRoot
                          ).get(flags + (current.href || ""));
                          if (maybeNodes) {
                            for (var i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            hoistableRoot
                          ).get(flags + (current.content || ""))) {
                            for (i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error(formatProdErrorMessage(468, flags));
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            null !== current && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, "");
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot
            ));
            flags & 1024 && (needsFormReset = true);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root2.containerInfo);
            recursivelyTraverseMutationEffects(root2, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root2.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 13:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
                if (5 === root2.tag || 26 === root2.tag) {
                  if (null === current) {
                    wasHidden = current = root2;
                    try {
                      if (currentResource = wasHidden.stateNode, hoistableRoot)
                        maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                      else {
                        i = wasHidden.stateNode;
                        var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                        i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                      }
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (6 === root2.tag) {
                  if (null === current) {
                    wasHidden = root2;
                    try {
                      wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                  root2.child.return = root2;
                  root2 = root2.child;
                  continue;
                }
                if (root2 === finishedWork) break a;
                for (; null === root2.sibling; ) {
                  if (null === root2.return || root2.return === finishedWork) break a;
                  current === root2 && (current = null);
                  root2 = root2.return;
                }
                current === root2 && (current = null);
                root2.sibling.return = root2.return;
                root2 = root2.sibling;
              }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$144 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
                var before$145 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
                break;
              case 3:
              case 4:
                var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$147,
                  parent$146
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root2, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance);
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root2,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256)
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(fiber);
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(fiber);
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(fiber);
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(fiber);
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i = deletions.stateNode;
              i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) cache.return = fiber, nextEffect = cache;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling, returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        }
      };
      var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
      var executionContext = 0;
      var workInProgressRoot = null;
      var workInProgress = null;
      var workInProgressRootRenderLanes = 0;
      var workInProgressSuspendedReason = 0;
      var workInProgressThrownValue = null;
      var workInProgressRootDidSkipSuspendedSiblings = false;
      var workInProgressRootIsPrerendering = false;
      var workInProgressRootDidAttachPingListener = false;
      var entangledRenderLanes = 0;
      var workInProgressRootExitStatus = 0;
      var workInProgressRootSkippedLanes = 0;
      var workInProgressRootInterleavedUpdatedLanes = 0;
      var workInProgressRootPingedLanes = 0;
      var workInProgressDeferredLane = 0;
      var workInProgressSuspendedRetryLanes = 0;
      var workInProgressRootConcurrentErrors = null;
      var workInProgressRootRecoverableErrors = null;
      var workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      var globalMostRecentFallbackTime = 0;
      var workInProgressRootRenderTargetTime = Infinity;
      var workInProgressTransitions = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var pendingEffectsStatus = 0;
      var pendingEffectsRoot = null;
      var pendingFinishedWork = null;
      var pendingEffectsLanes = 0;
      var pendingEffectsRemainingLanes = 0;
      var pendingPassiveTransitions = null;
      var pendingRecoverableErrors = null;
      var nestedUpdateCount = 0;
      var rootWithNestedUpdates = null;
      function requestUpdateLane() {
        if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
          return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
        if (null !== ReactSharedInternals.T) {
          var actionScopeLane = currentEntangledLane;
          return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
        }
        return resolveUpdatePriority();
      }
      function requestDeferredLane() {
        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
        var suspenseHandler = suspenseHandlerStackCursor.current;
        null !== suspenseHandler && (suspenseHandler.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root2, fiber, lane) {
        if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          prepareFreshStack(root2, 0), markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root2, lane);
        if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
          root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root2);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root2 = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root2,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    2,
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                0,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root2.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
            root2.cancelPendingCommit = suspendedCommitReason(
              commitRoot.bind(
                null,
                root2,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                1,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root2,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root2.suspendedLanes |= suspendedLanes;
        root2.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root2.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
          didAttemptEntireTree[index$4] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root2, lanes) {
        var timeoutHandle = root2.timeoutHandle;
        -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
        timeoutHandle = root2.cancelPendingCommit;
        null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
        resetWorkInProgressStack();
        workInProgressRoot = root2;
        workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root2.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
            lanes |= root2[index$2];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root2, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        ));
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root2, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$167) {
            handleThrow(root2, thrownValue$167);
          }
        while (1);
        lanes && root2.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root2,
          lanes
        );
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root2);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : 1) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$169) {
            handleThrow(root2, thrownValue$169);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState = null;
        thenableIndexCounter = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root2,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root2 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root2 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root2);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root2.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root2,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root2;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects(true);
            return null;
          })) : (root2.callbackNode = null, root2.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root2, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root2);
              var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start = priorSelectionRange.start, end = priorSelectionRange.end;
                  void 0 === end && (end = start);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                    if (win.getSelection) {
                      var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                      !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                        var range = doc.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                      }
                    }
                  }
                }
                doc = [];
                for (selection = priorFocusedElem; selection = selection.parentNode; )
                  1 === selection.nodeType && doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                  var info = doc[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root2.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
          var remainingLanes = root2.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root2);
          remainingLanes = root2.pendingLanes;
          0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0, false);
        }
      }
      function releaseRootPooledCache(root2, remainingLanes) {
        0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects(wasDelayedCommit) {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects(wasDelayedCommit);
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return false;
        var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            renderPriority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
            }
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root2, wakeable, lanes) {
        var pingCache = root2.pingCache;
        if (null === pingCache) {
          pingCache = root2.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
      }
      function pingSuspendedRoot(root2, wakeable, pingedLanes) {
        var pingCache = root2.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        root2.warmLanes &= ~pingedLanes;
        workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root2);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var didScheduleMicrotask = false;
      var mightHavePendingSyncWork = false;
      var isFlushingWork = false;
      var currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root2) {
        root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root$174 = firstScheduledRoot; null !== root$174; ) {
              if (!onlyLegacy)
                if (0 !== syncTransitionLanes) {
                  var pendingLanes = root$174.pendingLanes;
                  if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                  else {
                    var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes;
                    JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                    JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                    JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                  }
                  0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
                } else
                  JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                    root$174,
                    root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
                    null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle
                  ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
              root$174 = root$174.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
        for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
          var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
          if (0 === nextLanes)
            root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root2 = next;
        }
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      }
      function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
        for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
          var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root2,
          root2 === currentTime ? suspendedLanes : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        pingedLanes = root2.callbackNode;
        if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root2.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root2.callbackPriority = currentTime;
          root2.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root2.callbackPriority = 2;
        root2.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root2.callbackNode = null, root2.callbackPriority = 0, null;
        var originalCallbackNode = root2.callbackNode;
        if (flushPendingEffects(true) && root2.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root2,
          root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root2, now());
        return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
      }
      function performSyncWorkOnRoot(root2, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root2, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      for (i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
        eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1530,
          "on" + capitalizedEvent$jscomp$inline_1531
        );
      }
      var eventName$jscomp$inline_1529;
      var domEventName$jscomp$inline_1530;
      var capitalizedEvent$jscomp$inline_1531;
      var i$jscomp$inline_1528;
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(" ")
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      );
      var nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a: for (; ; ) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container2 = targetInst$jscomp$0.stateNode.containerInfo;
              if (container2 === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container2; ) {
                nodeTag = getClosestInstanceFromNode(container2);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container2 = container2.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                var _instance = instance;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                  createDispatchListener(instance, _instance, lastHostComponent)
                ));
                if (accumulateTargetOnly) break;
                instance = instance.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = SyntheticEventCtor;
                      reactEventName = reactEventType;
                      instance = 0;
                      for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                        instance++;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                        lastHostComponent++;
                      for (; 0 < instance - lastHostComponent; )
                        inCapturePhase = getParent(inCapturePhase), instance--;
                      for (; 0 < lastHostComponent - instance; )
                        reactEventName = getParent(reactEventName), lastHostComponent--;
                      for (; instance--; ) {
                        if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                          break b;
                        inCapturePhase = getParent(inCapturePhase);
                        reactEventName = getParent(reactEventName);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) break;
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
          var _instance2 = targetFiber, stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ));
          if (3 === targetFiber.tag) return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
          var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common) break;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event, listeners });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function noop$1() {
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              key
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              value
            );
            break;
          case "is":
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
              key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$188 = props[hasSrc];
                if (null != propValue$188)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = propValue$188;
                      break;
                    case "type":
                      propValue = propValue$188;
                      break;
                    case "checked":
                      checked = propValue$188;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$188;
                      break;
                    case "value":
                      propKey = propValue$188;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$188;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propValue$188)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$188, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            track(domElement);
            return;
          case "select":
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            track(domElement);
            return;
          case "option":
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$188 in props)
                props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  propValue$188,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$205 in nextProps) {
              var propKey = nextProps[propKey$205];
              lastProp = lastProps[propKey$205];
              if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp))
                switch (propKey$205) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      propKey$205,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case "select":
            propKey = value = defaultValue = propKey$205 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name in nextProps)
              if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                switch (name) {
                  case "value":
                    propKey$205 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
            return;
          case "textarea":
            propKey = propKey$205 = null;
            for (defaultValue in lastProps)
              if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                switch (value) {
                  case "value":
                    propKey$205 = name;
                    break;
                  case "defaultValue":
                    propKey = name;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, propKey$205, propKey);
            return;
          case "option":
            for (var propKey$221 in lastProps)
              if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221))
                switch (propKey$221) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propKey$221,
                      null,
                      nextProps,
                      propKey$205
                    );
                }
            for (lastDefaultValue in nextProps)
              if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      propKey$205,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var propKey$226 in lastProps)
              propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
            for (checked in nextProps)
              if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey$205)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      propKey$205,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$231 in lastProps)
                propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && void 0 !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(
                  domElement,
                  tag,
                  propKey$231,
                  void 0,
                  nextProps,
                  propKey$205
                );
              for (defaultChecked in nextProps)
                propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || void 0 === propKey$205 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  propKey$205,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var propKey$236 in lastProps)
          propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
        for (lastProp in nextProps)
          propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || null == propKey$205 && null == propKey || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
      }
      var eventsEnabled = null;
      var selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent) return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0;
      var cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var localPromise = "function" === typeof Promise ? Promise : void 0;
      var scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node) {
              if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                node = possiblePreambleContribution;
                var ownerDocument = parentInstance.ownerDocument;
                node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
                node & 2 && releaseSingletonInstance(ownerDocument.body);
                if (node & 4)
                  for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
                    var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                    ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
                    ownerDocument = nextNode$jscomp$0;
                  }
              }
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(suspenseInstance);
                return;
              }
              depth--;
            } else
              "$" === node || "$?" === node || "$!" === node ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
          else possiblePreambleContribution = 0;
          node = nextNode;
        } while (node);
        retryIfBlockedOn(suspenseInstance);
      }
      function clearContainerSparingly(container2) {
        var nextNode = container2.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node.rel.toLowerCase()) continue;
          }
          container2.removeChild(node);
        }
      }
      function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for (; 1 === instance.nodeType; ) {
          var anyProps = props;
          if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance.type) {
              var name = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                return instance;
            } else return instance;
          else if (!instance[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance.hasAttribute("itemprop")) break;
                return instance;
              case "link":
                name = instance.getAttribute("rel");
                if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                  break;
                else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance;
              case "style":
                if (instance.hasAttribute("data-precedence")) break;
                return instance;
              case "script":
                name = instance.getAttribute("src");
                if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                  break;
                return instance;
              default:
                return instance;
            }
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ("" === text) return null;
        for (; 3 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function isSuspenseInstanceFallback(instance) {
        return "$!" === instance.data || "$?" === instance.data && "complete" === instance.ownerDocument.readyState;
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        var ownerDocument = instance.ownerDocument;
        if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
          callback();
        else {
          var listener = function() {
            callback();
            ownerDocument.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument.addEventListener("DOMContentLoaded", listener);
          instance._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node.data;
            if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
              break;
            if ("/$" === nodeType) return null;
          }
        }
        return node;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getParentSuspenseInstance(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if ("$" === data || "$!" === data || "$?" === data) {
              if (0 === depth) return targetInstance;
              depth--;
            } else "/$" === data && depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type) throw Error(formatProdErrorMessage(452));
            return type;
          case "head":
            type = props.head;
            if (!type) throw Error(formatProdErrorMessage(453));
            return type;
          case "body":
            type = props.body;
            if (!type) throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance) {
        for (var attributes = instance.attributes; attributes.length; )
          instance.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance);
      }
      var preloadPropsMap = /* @__PURE__ */ new Map();
      var preconnectsSet = /* @__PURE__ */ new Set();
      function getHoistableRoot(container2) {
        return "function" === typeof container2.getRootNode ? container2.getRootNode() : 9 === container2.nodeType ? container2 : container2.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      }
      var globalDocument = "undefined" === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      }
      function preload(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSrcSet
          ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSizes
          ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign(
            {
              rel: "preload",
              href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
              as
            },
            options2
          ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      }
      function preloadModule(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if (resource = ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key)
            ))
              state.loading = 5;
            else {
              href = assign(
                { rel: "stylesheet", href, "data-precedence": precedence },
                options2
              );
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= 1;
              });
              link.addEventListener("error", function() {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles.set(key, resource);
          }
        }
      }
      function preinitScript(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
        if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var styles$244 = getResourcesFromRoot(
                JSCompiler_inline_result
              ).hoistableStyles, resource$245 = styles$244.get(type);
              resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$245.state
              )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ""));
              return resource$245;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ""));
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= 1;
        }), key.addEventListener("error", function() {
          return state.loading |= 2;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance)
                return resource.instance = instance, markNodeAsHoistable(instance), instance;
              var styleProps = assign({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                "style"
              );
              markNodeAsHoistable(instance);
              setInitialProperties(instance, "style", styleProps);
              insertStylesheet(instance, props.precedence, hoistableRoot);
              return resource.instance = instance;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var instance$250 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$250)
                return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
              instance = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
              instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(instance$250);
              var linkInstance = instance$250;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$250, "link", instance);
              resource.state.loading |= 4;
              insertStylesheet(instance$250, props.precedence, hoistableRoot);
              return resource.instance = instance$250;
            case "script":
              instance$250 = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$250)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance = props;
              if (styleProps = preloadPropsMap.get(instance$250))
                instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance, precedence, root2) {
        for (var nodes = root2.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (node.dataset.precedence === precedence) prior = node;
          else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches = tagCaches = /* @__PURE__ */ new Map();
          caches.set(ownerDocument, cache);
        } else
          caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument.length; caches++) {
          var node = ownerDocument[caches];
          if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
            var nodeKey = node.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp) return false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
              break;
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
              break;
            switch (props.rel) {
              case "stylesheet":
                return type = props.disabled, "string" === typeof props.precedence && null == type;
              default:
                return true;
            }
          case "script":
            if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
              return true;
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
      }
      var suspendedState = null;
      function noop() {
      }
      function suspendResource(hoistableRoot, resource, props) {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance) {
              hoistableRoot = instance._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance;
              markNodeAsHoistable(instance);
              return;
            }
            instance = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance = instance.createElement("link");
            markNodeAsHoistable(instance);
            var linkInstance = instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance, "link", props);
            resource.instance = instance;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      function waitForCommitToBeReady() {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, 6e4);
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count) {
          if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root2, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root2);
          if (precedences) var last = precedences.get(null);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root2, precedences);
            for (var nodes = root2.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                precedences.set(node.dataset.precedence, node), last = node;
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute("data-precedence");
          i = precedences.get(node) || last;
          i === last && precedences.set(null, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0
      };
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container2, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container2.context ? container2.context = parentComponent : container2.pendingContext = parentComponent;
        container2 = createUpdate(lane);
        container2.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container2.callback = callback);
        element = enqueueUpdate(rootFiber, container2, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      var _enabled = true;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root2 = fiber;
                        root2.pendingLanes |= 2;
                        for (root2.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root2.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                      }
                    }
                    break;
                  case 13:
                    root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = false;
      var queuedFocus = null;
      var queuedDrag = null;
      var queuedMouse = null;
      var queuedPointers = /* @__PURE__ */ new Map();
      var queuedPointerCaptures = /* @__PURE__ */ new Map();
      var queuedExplicitHydrationTargets = [];
      var discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  if (13 === nearestMounted.tag) {
                    var lane = requestUpdateLane();
                    lane = getBumpedLaneForHydrationByLane(lane);
                    var root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                    null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                    markRetryLaneIfNotHydrated(nearestMounted, lane);
                  }
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            );
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
                formInst,
                {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                },
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
          var queuedTarget = queuedExplicitHydrationTargets[i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
          attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i)
          for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i);
            }
          }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root2 = this._internalRoot;
        if (null === root2) throw Error(formatProdErrorMessage(409));
        var current = root2.current, lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root2, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root2 = this._internalRoot;
        if (null !== root2) {
          this._internalRoot = null;
          var container2 = root2.containerInfo;
          updateContainerImpl(root2.current, 2, null, root2, null, null);
          flushSyncWork$1();
          container2[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
          queuedExplicitHydrationTargets.splice(i, 0, target);
          0 === i && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1785 = React4.version;
      if ("19.1.0" !== isomorphicReactPackageVersion$jscomp$inline_1785)
        throw Error(
          formatProdErrorMessage(
            527,
            isomorphicReactPackageVersion$jscomp$inline_1785,
            "19.1.0"
          )
        );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2256 = {
        bundleType: 0,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.1.0"
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
          try {
            rendererID = hook$jscomp$inline_2257.inject(
              internals$jscomp$inline_2256
            ), injectedHook = hook$jscomp$inline_2257;
          } catch (err) {
          }
      }
      var hook$jscomp$inline_2257;
      exports.createRoot = function(container2, options2) {
        if (!isValidContainer(container2)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
        options2 = createFiberRoot(
          container2,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          null
        );
        container2[internalContainerInstanceKey] = options2.current;
        listenToAllSupportedEvents(container2);
        return new ReactDOMRoot(options2);
      };
      exports.hydrateRoot = function(container2, initialChildren, options2) {
        if (!isValidContainer(container2)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
        initialChildren = createFiberRoot(
          container2,
          1,
          true,
          initialChildren,
          null != options2 ? options2 : null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          formState
        );
        initialChildren.context = getContextForSubtree(null);
        options2 = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options2, identifierPrefix, isStrictMode);
        options2 = isStrictMode;
        initialChildren.current.lanes = options2;
        markRootUpdated$1(initialChildren, options2);
        ensureRootIsScheduled(initialChildren);
        container2[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container2);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      exports.version = "19.1.0";
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_client_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/v3/helpers/util.js
  var util, objectUtil, ZodParsedType, getParsedType;
  var init_util = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/v3/helpers/util.js"() {
      (function(util2) {
        util2.assertEqual = (_) => {
        };
        function assertIs(_arg) {
        }
        util2.assertIs = assertIs;
        function assertNever(_x) {
          throw new Error();
        }
        util2.assertNever = assertNever;
        util2.arrayToEnum = (items) => {
          const obj = {};
          for (const item of items) {
            obj[item] = item;
          }
          return obj;
        };
        util2.getValidEnumValues = (obj) => {
          const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
          const filtered = {};
          for (const k of validKeys) {
            filtered[k] = obj[k];
          }
          return util2.objectValues(filtered);
        };
        util2.objectValues = (obj) => {
          return util2.objectKeys(obj).map(function(e) {
            return obj[e];
          });
        };
        util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
          const keys = [];
          for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
        util2.find = (arr, checker) => {
          for (const item of arr) {
            if (checker(item))
              return item;
          }
          return void 0;
        };
        util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
        function joinValues(array, separator = " | ") {
          return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util2.joinValues = joinValues;
        util2.jsonStringifyReplacer = (_, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          return value;
        };
      })(util || (util = {}));
      (function(objectUtil2) {
        objectUtil2.mergeShapes = (first, second) => {
          return {
            ...first,
            ...second
            // second overwrites first
          };
        };
      })(objectUtil || (objectUtil = {}));
      ZodParsedType = util.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
      ]);
      getParsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "undefined":
            return ZodParsedType.undefined;
          case "string":
            return ZodParsedType.string;
          case "number":
            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
          case "boolean":
            return ZodParsedType.boolean;
          case "function":
            return ZodParsedType.function;
          case "bigint":
            return ZodParsedType.bigint;
          case "symbol":
            return ZodParsedType.symbol;
          case "object":
            if (Array.isArray(data)) {
              return ZodParsedType.array;
            }
            if (data === null) {
              return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return ZodParsedType.date;
            }
            return ZodParsedType.object;
          default:
            return ZodParsedType.unknown;
        }
      };
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/v3/ZodError.js
  var ZodIssueCode, quotelessJson, ZodError;
  var init_ZodError = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/v3/ZodError.js"() {
      init_util();
      ZodIssueCode = util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite"
      ]);
      quotelessJson = (obj) => {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
      };
      ZodError = class _ZodError extends Error {
        get errors() {
          return this.issues;
        }
        constructor(issues) {
          super();
          this.issues = [];
          this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
          };
          this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
          };
          const actualProto = new.target.prototype;
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
          } else {
            this.__proto__ = actualProto;
          }
          this.name = "ZodError";
          this.issues = issues;
        }
        format(_mapper) {
          const mapper = _mapper || function(issue) {
            return issue.message;
          };
          const fieldErrors = { _errors: [] };
          const processError = (error) => {
            for (const issue of error.issues) {
              if (issue.code === "invalid_union") {
                issue.unionErrors.map(processError);
              } else if (issue.code === "invalid_return_type") {
                processError(issue.returnTypeError);
              } else if (issue.code === "invalid_arguments") {
                processError(issue.argumentsError);
              } else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
              } else {
                let curr = fieldErrors;
                let i = 0;
                while (i < issue.path.length) {
                  const el = issue.path[i];
                  const terminal = i === issue.path.length - 1;
                  if (!terminal) {
                    curr[el] = curr[el] || { _errors: [] };
                  } else {
                    curr[el] = curr[el] || { _errors: [] };
                    curr[el]._errors.push(mapper(issue));
                  }
                  curr = curr[el];
                  i++;
                }
              }
            }
          };
          processError(this);
          return fieldErrors;
        }
        static assert(value) {
          if (!(value instanceof _ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
          }
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return this.issues.length === 0;
        }
        flatten(mapper = (issue) => issue.message) {
          const fieldErrors = {};
          const formErrors = [];
          for (const sub of this.issues) {
            if (sub.path.length > 0) {
              fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
              fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
              formErrors.push(mapper(sub));
            }
          }
          return { formErrors, fieldErrors };
        }
        get formErrors() {
          return this.flatten();
        }
      };
      ZodError.create = (issues) => {
        const error = new ZodError(issues);
        return error;
      };
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/v3/locales/en.js
  var errorMap, en_default;
  var init_en = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/v3/locales/en.js"() {
      init_ZodError();
      init_util();
      errorMap = (issue, _ctx) => {
        let message;
        switch (issue.code) {
          case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
              message = "Required";
            } else {
              message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
          case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
          case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
          case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
          case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
          case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
          case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
          case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
          case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
              if ("includes" in issue.validation) {
                message = `Invalid input: must include "${issue.validation.includes}"`;
                if (typeof issue.validation.position === "number") {
                  message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                }
              } else if ("startsWith" in issue.validation) {
                message = `Invalid input: must start with "${issue.validation.startsWith}"`;
              } else if ("endsWith" in issue.validation) {
                message = `Invalid input: must end with "${issue.validation.endsWith}"`;
              } else {
                util.assertNever(issue.validation);
              }
            } else if (issue.validation !== "regex") {
              message = `Invalid ${issue.validation}`;
            } else {
              message = "Invalid";
            }
            break;
          case ZodIssueCode.too_small:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.too_big:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
              message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
          case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
          case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
          default:
            message = _ctx.defaultError;
            util.assertNever(issue);
        }
        return { message };
      };
      en_default = errorMap;
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/v3/errors.js
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  var overrideErrorMap;
  var init_errors = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/v3/errors.js"() {
      init_en();
      overrideErrorMap = en_default;
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/v3/helpers/parseUtil.js
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === en_default ? void 0 : en_default
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  var makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync;
  var init_parseUtil = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/v3/helpers/parseUtil.js"() {
      init_errors();
      init_en();
      makeIssue = (params) => {
        const { data, path, errorMaps, issueData } = params;
        const fullPath = [...path, ...issueData.path || []];
        const fullIssue = {
          ...issueData,
          path: fullPath
        };
        if (issueData.message !== void 0) {
          return {
            ...issueData,
            path: fullPath,
            message: issueData.message
          };
        }
        let errorMessage = "";
        const maps = errorMaps.filter((m) => !!m).slice().reverse();
        for (const map of maps) {
          errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return {
          ...issueData,
          path: fullPath,
          message: errorMessage
        };
      };
      EMPTY_PATH = [];
      ParseStatus = class _ParseStatus {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          if (this.value === "valid")
            this.value = "dirty";
        }
        abort() {
          if (this.value !== "aborted")
            this.value = "aborted";
        }
        static mergeArray(status, results) {
          const arrayValue = [];
          for (const s of results) {
            if (s.status === "aborted")
              return INVALID;
            if (s.status === "dirty")
              status.dirty();
            arrayValue.push(s.value);
          }
          return { status: status.value, value: arrayValue };
        }
        static async mergeObjectAsync(status, pairs) {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value
            });
          }
          return _ParseStatus.mergeObjectSync(status, syncPairs);
        }
        static mergeObjectSync(status, pairs) {
          const finalObject = {};
          for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
              return INVALID;
            if (value.status === "aborted")
              return INVALID;
            if (key.status === "dirty")
              status.dirty();
            if (value.status === "dirty")
              status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
              finalObject[key.value] = value.value;
            }
          }
          return { status: status.value, value: finalObject };
        }
      };
      INVALID = Object.freeze({
        status: "aborted"
      });
      DIRTY = (value) => ({ status: "dirty", value });
      OK = (value) => ({ status: "valid", value });
      isAborted = (x) => x.status === "aborted";
      isDirty = (x) => x.status === "dirty";
      isValid = (x) => x.status === "valid";
      isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/v3/helpers/typeAliases.js
  var init_typeAliases = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/v3/helpers/typeAliases.js"() {
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/v3/helpers/errorUtil.js
  var errorUtil;
  var init_errorUtil = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/v3/helpers/errorUtil.js"() {
      (function(errorUtil2) {
        errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
        errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
      })(errorUtil || (errorUtil = {}));
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/v3/types.js
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && decoded?.typ !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        const r = check(data);
        if (r instanceof Promise) {
          return r.then((r2) => {
            if (!r2) {
              const params = cleanParams(_params, data);
              const _fatal = params.fatal ?? fatal ?? true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams(_params, data);
          const _fatal = params.fatal ?? fatal ?? true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny.create();
  }
  var ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER;
  var init_types = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/v3/types.js"() {
      init_ZodError();
      init_errors();
      init_errorUtil();
      init_parseUtil();
      init_util();
      ParseInputLazyPath = class {
        constructor(parent, value, path, key) {
          this._cachedPath = [];
          this.parent = parent;
          this.data = value;
          this._path = path;
          this._key = key;
        }
        get path() {
          if (!this._cachedPath.length) {
            if (Array.isArray(this._key)) {
              this._cachedPath.push(...this._path, ...this._key);
            } else {
              this._cachedPath.push(...this._path, this._key);
            }
          }
          return this._cachedPath;
        }
      };
      handleResult = (ctx, result) => {
        if (isValid(result)) {
          return { success: true, data: result.value };
        } else {
          if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
          }
          return {
            success: false,
            get error() {
              if (this._error)
                return this._error;
              const error = new ZodError(ctx.common.issues);
              this._error = error;
              return this._error;
            }
          };
        }
      };
      ZodType = class {
        get description() {
          return this._def.description;
        }
        _getType(input) {
          return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
          return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          };
        }
        _processInputParams(input) {
          return {
            status: new ParseStatus(),
            ctx: {
              common: input.parent.common,
              data: input.data,
              parsedType: getParsedType(input.data),
              schemaErrorMap: this._def.errorMap,
              path: input.path,
              parent: input.parent
            }
          };
        }
        _parseSync(input) {
          const result = this._parse(input);
          if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
          }
          return result;
        }
        _parseAsync(input) {
          const result = this._parse(input);
          return Promise.resolve(result);
        }
        parse(data, params) {
          const result = this.safeParse(data, params);
          if (result.success)
            return result.data;
          throw result.error;
        }
        safeParse(data, params) {
          const ctx = {
            common: {
              issues: [],
              async: params?.async ?? false,
              contextualErrorMap: params?.errorMap
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
          };
          const result = this._parseSync({ data, path: ctx.path, parent: ctx });
          return handleResult(ctx, result);
        }
        "~validate"(data) {
          const ctx = {
            common: {
              issues: [],
              async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
          };
          if (!this["~standard"].async) {
            try {
              const result = this._parseSync({ data, path: [], parent: ctx });
              return isValid(result) ? {
                value: result.value
              } : {
                issues: ctx.common.issues
              };
            } catch (err) {
              if (err?.message?.toLowerCase()?.includes("encountered")) {
                this["~standard"].async = true;
              }
              ctx.common = {
                issues: [],
                async: true
              };
            }
          }
          return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          });
        }
        async parseAsync(data, params) {
          const result = await this.safeParseAsync(data, params);
          if (result.success)
            return result.data;
          throw result.error;
        }
        async safeParseAsync(data, params) {
          const ctx = {
            common: {
              issues: [],
              contextualErrorMap: params?.errorMap,
              async: true
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
          };
          const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
          const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
          return handleResult(ctx, result);
        }
        refine(check, message) {
          const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
              return { message };
            } else if (typeof message === "function") {
              return message(val);
            } else {
              return message;
            }
          };
          return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
              code: ZodIssueCode.custom,
              ...getIssueProperties(val)
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then((data) => {
                if (!data) {
                  setError();
                  return false;
                } else {
                  return true;
                }
              });
            }
            if (!result) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        refinement(check, refinementData) {
          return this._refinement((val, ctx) => {
            if (!check(val)) {
              ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
              return false;
            } else {
              return true;
            }
          });
        }
        _refinement(refinement) {
          return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement }
          });
        }
        superRefine(refinement) {
          return this._refinement(refinement);
        }
        constructor(def) {
          this.spa = this.safeParseAsync;
          this._def = def;
          this.parse = this.parse.bind(this);
          this.safeParse = this.safeParse.bind(this);
          this.parseAsync = this.parseAsync.bind(this);
          this.safeParseAsync = this.safeParseAsync.bind(this);
          this.spa = this.spa.bind(this);
          this.refine = this.refine.bind(this);
          this.refinement = this.refinement.bind(this);
          this.superRefine = this.superRefine.bind(this);
          this.optional = this.optional.bind(this);
          this.nullable = this.nullable.bind(this);
          this.nullish = this.nullish.bind(this);
          this.array = this.array.bind(this);
          this.promise = this.promise.bind(this);
          this.or = this.or.bind(this);
          this.and = this.and.bind(this);
          this.transform = this.transform.bind(this);
          this.brand = this.brand.bind(this);
          this.default = this.default.bind(this);
          this.catch = this.catch.bind(this);
          this.describe = this.describe.bind(this);
          this.pipe = this.pipe.bind(this);
          this.readonly = this.readonly.bind(this);
          this.isNullable = this.isNullable.bind(this);
          this.isOptional = this.isOptional.bind(this);
          this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data) => this["~validate"](data)
          };
        }
        optional() {
          return ZodOptional.create(this, this._def);
        }
        nullable() {
          return ZodNullable.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return ZodArray.create(this);
        }
        promise() {
          return ZodPromise.create(this, this._def);
        }
        or(option) {
          return ZodUnion.create([this, option], this._def);
        }
        and(incoming) {
          return ZodIntersection.create(this, incoming, this._def);
        }
        transform(transform) {
          return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform }
          });
        }
        default(def) {
          const defaultValueFunc = typeof def === "function" ? def : () => def;
          return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
          });
        }
        brand() {
          return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def)
          });
        }
        catch(def) {
          const catchValueFunc = typeof def === "function" ? def : () => def;
          return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
          });
        }
        describe(description) {
          const This = this.constructor;
          return new This({
            ...this._def,
            description
          });
        }
        pipe(target) {
          return ZodPipeline.create(this, target);
        }
        readonly() {
          return ZodReadonly.create(this);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      };
      cuidRegex = /^c[^\s-]{8,}$/i;
      cuid2Regex = /^[0-9a-z]+$/;
      ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
      uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
      nanoidRegex = /^[a-z0-9_-]{21}$/i;
      jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
      durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
      emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
      _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
      ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
      ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
      ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
      ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
      base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
      base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
      dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
      dateRegex = new RegExp(`^${dateRegexSource}$`);
      ZodString = class _ZodString extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = String(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.string) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.length < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.length > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "length") {
              const tooBig = input.data.length > check.value;
              const tooSmall = input.data.length < check.value;
              if (tooBig || tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                if (tooBig) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                } else if (tooSmall) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                }
                status.dirty();
              }
            } else if (check.kind === "email") {
              if (!emailRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "email",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "emoji") {
              if (!emojiRegex) {
                emojiRegex = new RegExp(_emojiRegex, "u");
              }
              if (!emojiRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "emoji",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "uuid") {
              if (!uuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "uuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "nanoid") {
              if (!nanoidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "nanoid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid") {
              if (!cuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid2") {
              if (!cuid2Regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid2",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ulid") {
              if (!ulidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ulid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "url") {
              try {
                new URL(input.data);
              } catch {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "url",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "regex") {
              check.regex.lastIndex = 0;
              const testResult = check.regex.test(input.data);
              if (!testResult) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "regex",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "trim") {
              input.data = input.data.trim();
            } else if (check.kind === "includes") {
              if (!input.data.includes(check.value, check.position)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { includes: check.value, position: check.position },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "toLowerCase") {
              input.data = input.data.toLowerCase();
            } else if (check.kind === "toUpperCase") {
              input.data = input.data.toUpperCase();
            } else if (check.kind === "startsWith") {
              if (!input.data.startsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { startsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "endsWith") {
              if (!input.data.endsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { endsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "datetime") {
              const regex = datetimeRegex(check);
              if (!regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: "datetime",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "date") {
              const regex = dateRegex;
              if (!regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: "date",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "time") {
              const regex = timeRegex(check);
              if (!regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: "time",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "duration") {
              if (!durationRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "duration",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ip") {
              if (!isValidIP(input.data, check.version)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ip",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "jwt") {
              if (!isValidJWT(input.data, check.alg)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "jwt",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cidr") {
              if (!isValidCidr(input.data, check.version)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cidr",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "base64") {
              if (!base64Regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "base64",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "base64url") {
              if (!base64urlRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "base64url",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        _regex(regex, validation, message) {
          return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message)
          });
        }
        _addCheck(check) {
          return new _ZodString({
            ...this._def,
            checks: [...this._def.checks, check]
          });
        }
        email(message) {
          return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
        }
        url(message) {
          return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
        }
        emoji(message) {
          return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
        }
        uuid(message) {
          return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
        }
        nanoid(message) {
          return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
        }
        cuid(message) {
          return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
        }
        cuid2(message) {
          return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
        }
        ulid(message) {
          return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
        }
        base64(message) {
          return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
        }
        base64url(message) {
          return this._addCheck({
            kind: "base64url",
            ...errorUtil.errToObj(message)
          });
        }
        jwt(options) {
          return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
        }
        ip(options) {
          return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
        }
        cidr(options) {
          return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
        }
        datetime(options) {
          if (typeof options === "string") {
            return this._addCheck({
              kind: "datetime",
              precision: null,
              offset: false,
              local: false,
              message: options
            });
          }
          return this._addCheck({
            kind: "datetime",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            offset: options?.offset ?? false,
            local: options?.local ?? false,
            ...errorUtil.errToObj(options?.message)
          });
        }
        date(message) {
          return this._addCheck({ kind: "date", message });
        }
        time(options) {
          if (typeof options === "string") {
            return this._addCheck({
              kind: "time",
              precision: null,
              message: options
            });
          }
          return this._addCheck({
            kind: "time",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            ...errorUtil.errToObj(options?.message)
          });
        }
        duration(message) {
          return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
        }
        regex(regex, message) {
          return this._addCheck({
            kind: "regex",
            regex,
            ...errorUtil.errToObj(message)
          });
        }
        includes(value, options) {
          return this._addCheck({
            kind: "includes",
            value,
            position: options?.position,
            ...errorUtil.errToObj(options?.message)
          });
        }
        startsWith(value, message) {
          return this._addCheck({
            kind: "startsWith",
            value,
            ...errorUtil.errToObj(message)
          });
        }
        endsWith(value, message) {
          return this._addCheck({
            kind: "endsWith",
            value,
            ...errorUtil.errToObj(message)
          });
        }
        min(minLength, message) {
          return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message)
          });
        }
        max(maxLength, message) {
          return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message)
          });
        }
        length(len, message) {
          return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message)
          });
        }
        /**
         * Equivalent to `.min(1)`
         */
        nonempty(message) {
          return this.min(1, errorUtil.errToObj(message));
        }
        trim() {
          return new _ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }]
          });
        }
        toLowerCase() {
          return new _ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }]
          });
        }
        toUpperCase() {
          return new _ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }]
          });
        }
        get isDatetime() {
          return !!this._def.checks.find((ch) => ch.kind === "datetime");
        }
        get isDate() {
          return !!this._def.checks.find((ch) => ch.kind === "date");
        }
        get isTime() {
          return !!this._def.checks.find((ch) => ch.kind === "time");
        }
        get isDuration() {
          return !!this._def.checks.find((ch) => ch.kind === "duration");
        }
        get isEmail() {
          return !!this._def.checks.find((ch) => ch.kind === "email");
        }
        get isURL() {
          return !!this._def.checks.find((ch) => ch.kind === "url");
        }
        get isEmoji() {
          return !!this._def.checks.find((ch) => ch.kind === "emoji");
        }
        get isUUID() {
          return !!this._def.checks.find((ch) => ch.kind === "uuid");
        }
        get isNANOID() {
          return !!this._def.checks.find((ch) => ch.kind === "nanoid");
        }
        get isCUID() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid");
        }
        get isCUID2() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid2");
        }
        get isULID() {
          return !!this._def.checks.find((ch) => ch.kind === "ulid");
        }
        get isIP() {
          return !!this._def.checks.find((ch) => ch.kind === "ip");
        }
        get isCIDR() {
          return !!this._def.checks.find((ch) => ch.kind === "cidr");
        }
        get isBase64() {
          return !!this._def.checks.find((ch) => ch.kind === "base64");
        }
        get isBase64url() {
          return !!this._def.checks.find((ch) => ch.kind === "base64url");
        }
        get minLength() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxLength() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodString.create = (params) => {
        return new ZodString({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodString,
          coerce: params?.coerce ?? false,
          ...processCreateParams(params)
        });
      };
      ZodNumber = class _ZodNumber extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
          this.step = this.multipleOf;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = Number(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.number) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.number,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "int") {
              if (!util.isInteger(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (floatSafeRemainder(input.data, check.value) !== 0) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "finite") {
              if (!Number.isFinite(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_finite,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new _ZodNumber({
            ...this._def,
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          });
        }
        _addCheck(check) {
          return new _ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check]
          });
        }
        int(message) {
          return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message)
          });
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        finite(message) {
          return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message)
          });
        }
        safe(message) {
          return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message)
          })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
        get isInt() {
          return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
        }
        get isFinite() {
          let max = null;
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
              return true;
            } else if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            } else if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return Number.isFinite(min) && Number.isFinite(max);
        }
      };
      ZodNumber.create = (params) => {
        return new ZodNumber({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodNumber,
          coerce: params?.coerce || false,
          ...processCreateParams(params)
        });
      };
      ZodBigInt = class _ZodBigInt extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
        }
        _parse(input) {
          if (this._def.coerce) {
            try {
              input.data = BigInt(input.data);
            } catch {
              return this._getInvalidInput(input);
            }
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.bigint) {
            return this._getInvalidInput(input);
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  type: "bigint",
                  minimum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  type: "bigint",
                  maximum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (input.data % check.value !== BigInt(0)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        _getInvalidInput(input) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx.parsedType
          });
          return INVALID;
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new _ZodBigInt({
            ...this._def,
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          });
        }
        _addCheck(check) {
          return new _ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check]
          });
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodBigInt.create = (params) => {
        return new ZodBigInt({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodBigInt,
          coerce: params?.coerce ?? false,
          ...processCreateParams(params)
        });
      };
      ZodBoolean = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = Boolean(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.boolean,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodBoolean.create = (params) => {
        return new ZodBoolean({
          typeName: ZodFirstPartyTypeKind.ZodBoolean,
          coerce: params?.coerce || false,
          ...processCreateParams(params)
        });
      };
      ZodDate = class _ZodDate extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = new Date(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.date) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.date,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          if (Number.isNaN(input.data.getTime())) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_date
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.getTime() < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  minimum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.getTime() > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  maximum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return {
            status: status.value,
            value: new Date(input.data.getTime())
          };
        }
        _addCheck(check) {
          return new _ZodDate({
            ...this._def,
            checks: [...this._def.checks, check]
          });
        }
        min(minDate, message) {
          return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        max(maxDate, message) {
          return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        get minDate() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min != null ? new Date(min) : null;
        }
        get maxDate() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max != null ? new Date(max) : null;
        }
      };
      ZodDate.create = (params) => {
        return new ZodDate({
          checks: [],
          coerce: params?.coerce || false,
          typeName: ZodFirstPartyTypeKind.ZodDate,
          ...processCreateParams(params)
        });
      };
      ZodSymbol = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.symbol,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodSymbol.create = (params) => {
        return new ZodSymbol({
          typeName: ZodFirstPartyTypeKind.ZodSymbol,
          ...processCreateParams(params)
        });
      };
      ZodUndefined = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.undefined,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodUndefined.create = (params) => {
        return new ZodUndefined({
          typeName: ZodFirstPartyTypeKind.ZodUndefined,
          ...processCreateParams(params)
        });
      };
      ZodNull = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.null,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodNull.create = (params) => {
        return new ZodNull({
          typeName: ZodFirstPartyTypeKind.ZodNull,
          ...processCreateParams(params)
        });
      };
      ZodAny = class extends ZodType {
        constructor() {
          super(...arguments);
          this._any = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodAny.create = (params) => {
        return new ZodAny({
          typeName: ZodFirstPartyTypeKind.ZodAny,
          ...processCreateParams(params)
        });
      };
      ZodUnknown = class extends ZodType {
        constructor() {
          super(...arguments);
          this._unknown = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodUnknown.create = (params) => {
        return new ZodUnknown({
          typeName: ZodFirstPartyTypeKind.ZodUnknown,
          ...processCreateParams(params)
        });
      };
      ZodNever = class extends ZodType {
        _parse(input) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType
          });
          return INVALID;
        }
      };
      ZodNever.create = (params) => {
        return new ZodNever({
          typeName: ZodFirstPartyTypeKind.ZodNever,
          ...processCreateParams(params)
        });
      };
      ZodVoid = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.void,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodVoid.create = (params) => {
        return new ZodVoid({
          typeName: ZodFirstPartyTypeKind.ZodVoid,
          ...processCreateParams(params)
        });
      };
      ZodArray = class _ZodArray extends ZodType {
        _parse(input) {
          const { ctx, status } = this._processInputParams(input);
          const def = this._def;
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
              addIssueToContext(ctx, {
                code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                minimum: tooSmall ? def.exactLength.value : void 0,
                maximum: tooBig ? def.exactLength.value : void 0,
                type: "array",
                inclusive: true,
                exact: true,
                message: def.exactLength.message
              });
              status.dirty();
            }
          }
          if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def.minLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def.minLength.message
              });
              status.dirty();
            }
          }
          if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def.maxLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def.maxLength.message
              });
              status.dirty();
            }
          }
          if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
              return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result2) => {
              return ParseStatus.mergeArray(status, result2);
            });
          }
          const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          });
          return ParseStatus.mergeArray(status, result);
        }
        get element() {
          return this._def.type;
        }
        min(minLength, message) {
          return new _ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) }
          });
        }
        max(maxLength, message) {
          return new _ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) }
          });
        }
        length(len, message) {
          return new _ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil.toString(message) }
          });
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodArray.create = (schema, params) => {
        return new ZodArray({
          type: schema,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: ZodFirstPartyTypeKind.ZodArray,
          ...processCreateParams(params)
        });
      };
      ZodObject = class _ZodObject extends ZodType {
        constructor() {
          super(...arguments);
          this._cached = null;
          this.nonstrict = this.passthrough;
          this.augment = this.extend;
        }
        _getCached() {
          if (this._cached !== null)
            return this._cached;
          const shape = this._def.shape();
          const keys = util.objectKeys(shape);
          this._cached = { shape, keys };
          return this._cached;
        }
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.object) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const { status, ctx } = this._processInputParams(input);
          const { shape, keys: shapeKeys } = this._getCached();
          const extraKeys = [];
          if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
              if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
              }
            }
          }
          const pairs = [];
          for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
          if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
              for (const key of extraKeys) {
                pairs.push({
                  key: { status: "valid", value: key },
                  value: { status: "valid", value: ctx.data[key] }
                });
              }
            } else if (unknownKeys === "strict") {
              if (extraKeys.length > 0) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.unrecognized_keys,
                  keys: extraKeys
                });
                status.dirty();
              }
            } else if (unknownKeys === "strip") {
            } else {
              throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
          } else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
              const value = ctx.data[key];
              pairs.push({
                key: { status: "valid", value: key },
                value: catchall._parse(
                  new ParseInputLazyPath(ctx, value, ctx.path, key)
                  //, ctx.child(key), value, getParsedType(value)
                ),
                alwaysSet: key in ctx.data
              });
            }
          }
          if (ctx.common.async) {
            return Promise.resolve().then(async () => {
              const syncPairs = [];
              for (const pair of pairs) {
                const key = await pair.key;
                const value = await pair.value;
                syncPairs.push({
                  key,
                  value,
                  alwaysSet: pair.alwaysSet
                });
              }
              return syncPairs;
            }).then((syncPairs) => {
              return ParseStatus.mergeObjectSync(status, syncPairs);
            });
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get shape() {
          return this._def.shape();
        }
        strict(message) {
          errorUtil.errToObj;
          return new _ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...message !== void 0 ? {
              errorMap: (issue, ctx) => {
                const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                if (issue.code === "unrecognized_keys")
                  return {
                    message: errorUtil.errToObj(message).message ?? defaultError
                  };
                return {
                  message: defaultError
                };
              }
            } : {}
          });
        }
        strip() {
          return new _ZodObject({
            ...this._def,
            unknownKeys: "strip"
          });
        }
        passthrough() {
          return new _ZodObject({
            ...this._def,
            unknownKeys: "passthrough"
          });
        }
        // const AugmentFactory =
        //   <Def extends ZodObjectDef>(def: Def) =>
        //   <Augmentation extends ZodRawShape>(
        //     augmentation: Augmentation
        //   ): ZodObject<
        //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
        //     Def["unknownKeys"],
        //     Def["catchall"]
        //   > => {
        //     return new ZodObject({
        //       ...def,
        //       shape: () => ({
        //         ...def.shape(),
        //         ...augmentation,
        //       }),
        //     }) as any;
        //   };
        extend(augmentation) {
          return new _ZodObject({
            ...this._def,
            shape: () => ({
              ...this._def.shape(),
              ...augmentation
            })
          });
        }
        /**
         * Prior to zod@1.0.12 there was a bug in the
         * inferred type of merged objects. Please
         * upgrade if you are experiencing issues.
         */
        merge(merging) {
          const merged = new _ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
              ...this._def.shape(),
              ...merging._def.shape()
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject
          });
          return merged;
        }
        // merge<
        //   Incoming extends AnyZodObject,
        //   Augmentation extends Incoming["shape"],
        //   NewOutput extends {
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   },
        //   NewInput extends {
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }
        // >(
        //   merging: Incoming
        // ): ZodObject<
        //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
        //   Incoming["_def"]["unknownKeys"],
        //   Incoming["_def"]["catchall"],
        //   NewOutput,
        //   NewInput
        // > {
        //   const merged: any = new ZodObject({
        //     unknownKeys: merging._def.unknownKeys,
        //     catchall: merging._def.catchall,
        //     shape: () =>
        //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
        //     typeName: ZodFirstPartyTypeKind.ZodObject,
        //   }) as any;
        //   return merged;
        // }
        setKey(key, schema) {
          return this.augment({ [key]: schema });
        }
        // merge<Incoming extends AnyZodObject>(
        //   merging: Incoming
        // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
        // ZodObject<
        //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
        //   Incoming["_def"]["unknownKeys"],
        //   Incoming["_def"]["catchall"]
        // > {
        //   // const mergedShape = objectUtil.mergeShapes(
        //   //   this._def.shape(),
        //   //   merging._def.shape()
        //   // );
        //   const merged: any = new ZodObject({
        //     unknownKeys: merging._def.unknownKeys,
        //     catchall: merging._def.catchall,
        //     shape: () =>
        //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
        //     typeName: ZodFirstPartyTypeKind.ZodObject,
        //   }) as any;
        //   return merged;
        // }
        catchall(index) {
          return new _ZodObject({
            ...this._def,
            catchall: index
          });
        }
        pick(mask) {
          const shape = {};
          for (const key of util.objectKeys(mask)) {
            if (mask[key] && this.shape[key]) {
              shape[key] = this.shape[key];
            }
          }
          return new _ZodObject({
            ...this._def,
            shape: () => shape
          });
        }
        omit(mask) {
          const shape = {};
          for (const key of util.objectKeys(this.shape)) {
            if (!mask[key]) {
              shape[key] = this.shape[key];
            }
          }
          return new _ZodObject({
            ...this._def,
            shape: () => shape
          });
        }
        /**
         * @deprecated
         */
        deepPartial() {
          return deepPartialify(this);
        }
        partial(mask) {
          const newShape = {};
          for (const key of util.objectKeys(this.shape)) {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
              newShape[key] = fieldSchema;
            } else {
              newShape[key] = fieldSchema.optional();
            }
          }
          return new _ZodObject({
            ...this._def,
            shape: () => newShape
          });
        }
        required(mask) {
          const newShape = {};
          for (const key of util.objectKeys(this.shape)) {
            if (mask && !mask[key]) {
              newShape[key] = this.shape[key];
            } else {
              const fieldSchema = this.shape[key];
              let newField = fieldSchema;
              while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
              }
              newShape[key] = newField;
            }
          }
          return new _ZodObject({
            ...this._def,
            shape: () => newShape
          });
        }
        keyof() {
          return createZodEnum(util.objectKeys(this.shape));
        }
      };
      ZodObject.create = (shape, params) => {
        return new ZodObject({
          shape: () => shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject,
          ...processCreateParams(params)
        });
      };
      ZodObject.strictCreate = (shape, params) => {
        return new ZodObject({
          shape: () => shape,
          unknownKeys: "strict",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject,
          ...processCreateParams(params)
        });
      };
      ZodObject.lazycreate = (shape, params) => {
        return new ZodObject({
          shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject,
          ...processCreateParams(params)
        });
      };
      ZodUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const options = this._def.options;
          function handleResults(results) {
            for (const result of results) {
              if (result.result.status === "valid") {
                return result.result;
              }
            }
            for (const result of results) {
              if (result.result.status === "dirty") {
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
              }
            }
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
              const childCtx = {
                ...ctx,
                common: {
                  ...ctx.common,
                  issues: []
                },
                parent: null
              };
              return {
                result: await option._parseAsync({
                  data: ctx.data,
                  path: ctx.path,
                  parent: childCtx
                }),
                ctx: childCtx
              };
            })).then(handleResults);
          } else {
            let dirty = void 0;
            const issues = [];
            for (const option of options) {
              const childCtx = {
                ...ctx,
                common: {
                  ...ctx.common,
                  issues: []
                },
                parent: null
              };
              const result = option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              });
              if (result.status === "valid") {
                return result;
              } else if (result.status === "dirty" && !dirty) {
                dirty = { result, ctx: childCtx };
              }
              if (childCtx.common.issues.length) {
                issues.push(childCtx.common.issues);
              }
            }
            if (dirty) {
              ctx.common.issues.push(...dirty.ctx.common.issues);
              return dirty.result;
            }
            const unionErrors = issues.map((issues2) => new ZodError(issues2));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
        }
        get options() {
          return this._def.options;
        }
      };
      ZodUnion.create = (types, params) => {
        return new ZodUnion({
          options: types,
          typeName: ZodFirstPartyTypeKind.ZodUnion,
          ...processCreateParams(params)
        });
      };
      getDiscriminator = (type) => {
        if (type instanceof ZodLazy) {
          return getDiscriminator(type.schema);
        } else if (type instanceof ZodEffects) {
          return getDiscriminator(type.innerType());
        } else if (type instanceof ZodLiteral) {
          return [type.value];
        } else if (type instanceof ZodEnum) {
          return type.options;
        } else if (type instanceof ZodNativeEnum) {
          return util.objectValues(type.enum);
        } else if (type instanceof ZodDefault) {
          return getDiscriminator(type._def.innerType);
        } else if (type instanceof ZodUndefined) {
          return [void 0];
        } else if (type instanceof ZodNull) {
          return [null];
        } else if (type instanceof ZodOptional) {
          return [void 0, ...getDiscriminator(type.unwrap())];
        } else if (type instanceof ZodNullable) {
          return [null, ...getDiscriminator(type.unwrap())];
        } else if (type instanceof ZodBranded) {
          return getDiscriminator(type.unwrap());
        } else if (type instanceof ZodReadonly) {
          return getDiscriminator(type.unwrap());
        } else if (type instanceof ZodCatch) {
          return getDiscriminator(type._def.innerType);
        } else {
          return [];
        }
      };
      ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const discriminator = this.discriminator;
          const discriminatorValue = ctx.data[discriminator];
          const option = this.optionsMap.get(discriminatorValue);
          if (!option) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union_discriminator,
              options: Array.from(this.optionsMap.keys()),
              path: [discriminator]
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          } else {
            return option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        /**
         * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
         * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
         * have a different value for each object in the union.
         * @param discriminator the name of the discriminator property
         * @param types an array of object schemas
         * @param params
         */
        static create(discriminator, options, params) {
          const optionsMap = /* @__PURE__ */ new Map();
          for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
              throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
              if (optionsMap.has(value)) {
                throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
              }
              optionsMap.set(value, type);
            }
          }
          return new _ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params)
          });
        }
      };
      ZodIntersection = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
              return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_intersection_types
              });
              return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
              status.dirty();
            }
            return { status: status.value, value: merged.data };
          };
          if (ctx.common.async) {
            return Promise.all([
              this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              }),
              this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              })
            ]).then(([left, right]) => handleParsed(left, right));
          } else {
            return handleParsed(this._def.left._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }), this._def.right._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }));
          }
        }
      };
      ZodIntersection.create = (left, right, params) => {
        return new ZodIntersection({
          left,
          right,
          typeName: ZodFirstPartyTypeKind.ZodIntersection,
          ...processCreateParams(params)
        });
      };
      ZodTuple = class _ZodTuple extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            return INVALID;
          }
          const rest = this._def.rest;
          if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            status.dirty();
          }
          const items = [...ctx.data].map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
              return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
          }).filter((x) => !!x);
          if (ctx.common.async) {
            return Promise.all(items).then((results) => {
              return ParseStatus.mergeArray(status, results);
            });
          } else {
            return ParseStatus.mergeArray(status, items);
          }
        }
        get items() {
          return this._def.items;
        }
        rest(rest) {
          return new _ZodTuple({
            ...this._def,
            rest
          });
        }
      };
      ZodTuple.create = (schemas, params) => {
        if (!Array.isArray(schemas)) {
          throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple({
          items: schemas,
          typeName: ZodFirstPartyTypeKind.ZodTuple,
          rest: null,
          ...processCreateParams(params)
        });
      };
      ZodRecord = class _ZodRecord extends ZodType {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const pairs = [];
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          for (const key in ctx.data) {
            pairs.push({
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
              value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
          if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get element() {
          return this._def.valueType;
        }
        static create(first, second, third) {
          if (second instanceof ZodType) {
            return new _ZodRecord({
              keyType: first,
              valueType: second,
              typeName: ZodFirstPartyTypeKind.ZodRecord,
              ...processCreateParams(third)
            });
          }
          return new _ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second)
          });
        }
      };
      ZodMap = class extends ZodType {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.map,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
              value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
            };
          });
          if (ctx.common.async) {
            const finalMap = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async () => {
              for (const pair of pairs) {
                const key = await pair.key;
                const value = await pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                  return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                  status.dirty();
                }
                finalMap.set(key.value, value.value);
              }
              return { status: status.value, value: finalMap };
            });
          } else {
            const finalMap = /* @__PURE__ */ new Map();
            for (const pair of pairs) {
              const key = pair.key;
              const value = pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          }
        }
      };
      ZodMap.create = (keyType, valueType, params) => {
        return new ZodMap({
          valueType,
          keyType,
          typeName: ZodFirstPartyTypeKind.ZodMap,
          ...processCreateParams(params)
        });
      };
      ZodSet = class _ZodSet extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.set,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const def = this._def;
          if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def.minSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def.minSize.message
              });
              status.dirty();
            }
          }
          if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def.maxSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def.maxSize.message
              });
              status.dirty();
            }
          }
          const valueType = this._def.valueType;
          function finalizeSet(elements2) {
            const parsedSet = /* @__PURE__ */ new Set();
            for (const element of elements2) {
              if (element.status === "aborted")
                return INVALID;
              if (element.status === "dirty")
                status.dirty();
              parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
          }
          const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
          if (ctx.common.async) {
            return Promise.all(elements).then((elements2) => finalizeSet(elements2));
          } else {
            return finalizeSet(elements);
          }
        }
        min(minSize, message) {
          return new _ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) }
          });
        }
        max(maxSize, message) {
          return new _ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) }
          });
        }
        size(size, message) {
          return this.min(size, message).max(size, message);
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodSet.create = (valueType, params) => {
        return new ZodSet({
          valueType,
          minSize: null,
          maxSize: null,
          typeName: ZodFirstPartyTypeKind.ZodSet,
          ...processCreateParams(params)
        });
      };
      ZodFunction = class _ZodFunction extends ZodType {
        constructor() {
          super(...arguments);
          this.validate = this.implement;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.function,
              received: ctx.parsedType
            });
            return INVALID;
          }
          function makeArgsIssue(args, error) {
            return makeIssue({
              data: args,
              path: ctx.path,
              errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
              issueData: {
                code: ZodIssueCode.invalid_arguments,
                argumentsError: error
              }
            });
          }
          function makeReturnsIssue(returns, error) {
            return makeIssue({
              data: returns,
              path: ctx.path,
              errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
              issueData: {
                code: ZodIssueCode.invalid_return_type,
                returnTypeError: error
              }
            });
          }
          const params = { errorMap: ctx.common.contextualErrorMap };
          const fn = ctx.data;
          if (this._def.returns instanceof ZodPromise) {
            const me = this;
            return OK(async function(...args) {
              const error = new ZodError([]);
              const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
                error.addIssue(makeArgsIssue(args, e));
                throw error;
              });
              const result = await Reflect.apply(fn, this, parsedArgs);
              const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
                error.addIssue(makeReturnsIssue(result, e));
                throw error;
              });
              return parsedReturns;
            });
          } else {
            const me = this;
            return OK(function(...args) {
              const parsedArgs = me._def.args.safeParse(args, params);
              if (!parsedArgs.success) {
                throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
              }
              const result = Reflect.apply(fn, this, parsedArgs.data);
              const parsedReturns = me._def.returns.safeParse(result, params);
              if (!parsedReturns.success) {
                throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
              }
              return parsedReturns.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...items) {
          return new _ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create())
          });
        }
        returns(returnType) {
          return new _ZodFunction({
            ...this._def,
            returns: returnType
          });
        }
        implement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        strictImplement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        static create(args, returns, params) {
          return new _ZodFunction({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params)
          });
        }
      };
      ZodLazy = class extends ZodType {
        get schema() {
          return this._def.getter();
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const lazySchema = this._def.getter();
          return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
        }
      };
      ZodLazy.create = (getter, params) => {
        return new ZodLazy({
          getter,
          typeName: ZodFirstPartyTypeKind.ZodLazy,
          ...processCreateParams(params)
        });
      };
      ZodLiteral = class extends ZodType {
        _parse(input) {
          if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_literal,
              expected: this._def.value
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
        get value() {
          return this._def.value;
        }
      };
      ZodLiteral.create = (value, params) => {
        return new ZodLiteral({
          value,
          typeName: ZodFirstPartyTypeKind.ZodLiteral,
          ...processCreateParams(params)
        });
      };
      ZodEnum = class _ZodEnum extends ZodType {
        _parse(input) {
          if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (!this._cache) {
            this._cache = new Set(this._def.values);
          }
          if (!this._cache.has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Values() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        extract(values, newDef = this._def) {
          return _ZodEnum.create(values, {
            ...this._def,
            ...newDef
          });
        }
        exclude(values, newDef = this._def) {
          return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
            ...this._def,
            ...newDef
          });
        }
      };
      ZodEnum.create = createZodEnum;
      ZodNativeEnum = class extends ZodType {
        _parse(input) {
          const nativeEnumValues = util.getValidEnumValues(this._def.values);
          const ctx = this._getOrReturnCtx(input);
          if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (!this._cache) {
            this._cache = new Set(util.getValidEnumValues(this._def.values));
          }
          if (!this._cache.has(input.data)) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get enum() {
          return this._def.values;
        }
      };
      ZodNativeEnum.create = (values, params) => {
        return new ZodNativeEnum({
          values,
          typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
          ...processCreateParams(params)
        });
      };
      ZodPromise = class extends ZodType {
        unwrap() {
          return this._def.type;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.promise,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
          return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
              path: ctx.path,
              errorMap: ctx.common.contextualErrorMap
            });
          }));
        }
      };
      ZodPromise.create = (schema, params) => {
        return new ZodPromise({
          type: schema,
          typeName: ZodFirstPartyTypeKind.ZodPromise,
          ...processCreateParams(params)
        });
      };
      ZodEffects = class extends ZodType {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const effect = this._def.effect || null;
          const checkCtx = {
            addIssue: (arg) => {
              addIssueToContext(ctx, arg);
              if (arg.fatal) {
                status.abort();
              } else {
                status.dirty();
              }
            },
            get path() {
              return ctx.path;
            }
          };
          checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
          if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(processed).then(async (processed2) => {
                if (status.value === "aborted")
                  return INVALID;
                const result = await this._def.schema._parseAsync({
                  data: processed2,
                  path: ctx.path,
                  parent: ctx
                });
                if (result.status === "aborted")
                  return INVALID;
                if (result.status === "dirty")
                  return DIRTY(result.value);
                if (status.value === "dirty")
                  return DIRTY(result.value);
                return result;
              });
            } else {
              if (status.value === "aborted")
                return INVALID;
              const result = this._def.schema._parseSync({
                data: processed,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            }
          }
          if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
              const result = effect.refinement(acc, checkCtx);
              if (ctx.common.async) {
                return Promise.resolve(result);
              }
              if (result instanceof Promise) {
                throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
              }
              return acc;
            };
            if (ctx.common.async === false) {
              const inner = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              executeRefinement(inner.value);
              return { status: status.value, value: inner.value };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                if (inner.status === "aborted")
                  return INVALID;
                if (inner.status === "dirty")
                  status.dirty();
                return executeRefinement(inner.value).then(() => {
                  return { status: status.value, value: inner.value };
                });
              });
            }
          }
          if (effect.type === "transform") {
            if (ctx.common.async === false) {
              const base = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (!isValid(base))
                return INVALID;
              const result = effect.transform(base.value, checkCtx);
              if (result instanceof Promise) {
                throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
              }
              return { status: status.value, value: result };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
                if (!isValid(base))
                  return INVALID;
                return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                  status: status.value,
                  value: result
                }));
              });
            }
          }
          util.assertNever(effect);
        }
      };
      ZodEffects.create = (schema, effect, params) => {
        return new ZodEffects({
          schema,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect,
          ...processCreateParams(params)
        });
      };
      ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
        return new ZodEffects({
          schema,
          effect: { type: "preprocess", transform: preprocess },
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          ...processCreateParams(params)
        });
      };
      ZodOptional = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.undefined) {
            return OK(void 0);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodOptional.create = (type, params) => {
        return new ZodOptional({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodOptional,
          ...processCreateParams(params)
        });
      };
      ZodNullable = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.null) {
            return OK(null);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodNullable.create = (type, params) => {
        return new ZodNullable({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodNullable,
          ...processCreateParams(params)
        });
      };
      ZodDefault = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          let data = ctx.data;
          if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
          }
          return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        removeDefault() {
          return this._def.innerType;
        }
      };
      ZodDefault.create = (type, params) => {
        return new ZodDefault({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodDefault,
          defaultValue: typeof params.default === "function" ? params.default : () => params.default,
          ...processCreateParams(params)
        });
      };
      ZodCatch = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const newCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            }
          };
          const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
              ...newCtx
            }
          });
          if (isAsync(result)) {
            return result.then((result2) => {
              return {
                status: "valid",
                value: result2.status === "valid" ? result2.value : this._def.catchValue({
                  get error() {
                    return new ZodError(newCtx.common.issues);
                  },
                  input: newCtx.data
                })
              };
            });
          } else {
            return {
              status: "valid",
              value: result.status === "valid" ? result.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          }
        }
        removeCatch() {
          return this._def.innerType;
        }
      };
      ZodCatch.create = (type, params) => {
        return new ZodCatch({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodCatch,
          catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
          ...processCreateParams(params)
        });
      };
      ZodNaN = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.nan,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
      };
      ZodNaN.create = (params) => {
        return new ZodNaN({
          typeName: ZodFirstPartyTypeKind.ZodNaN,
          ...processCreateParams(params)
        });
      };
      BRAND = Symbol("zod_brand");
      ZodBranded = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const data = ctx.data;
          return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        unwrap() {
          return this._def.type;
        }
      };
      ZodPipeline = class _ZodPipeline extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.common.async) {
            const handleAsync = async () => {
              const inResult = await this._def.in._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inResult.status === "aborted")
                return INVALID;
              if (inResult.status === "dirty") {
                status.dirty();
                return DIRTY(inResult.value);
              } else {
                return this._def.out._parseAsync({
                  data: inResult.value,
                  path: ctx.path,
                  parent: ctx
                });
              }
            };
            return handleAsync();
          } else {
            const inResult = this._def.in._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return {
                status: "dirty",
                value: inResult.value
              };
            } else {
              return this._def.out._parseSync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }
        }
        static create(a, b) {
          return new _ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
          });
        }
      };
      ZodReadonly = class extends ZodType {
        _parse(input) {
          const result = this._def.innerType._parse(input);
          const freeze = (data) => {
            if (isValid(data)) {
              data.value = Object.freeze(data.value);
            }
            return data;
          };
          return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodReadonly.create = (type, params) => {
        return new ZodReadonly({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodReadonly,
          ...processCreateParams(params)
        });
      };
      late = {
        object: ZodObject.lazycreate
      };
      (function(ZodFirstPartyTypeKind2) {
        ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
        ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
        ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
        ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
        ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
      })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
      instanceOfType = (cls, params = {
        message: `Input not instance of ${cls.name}`
      }) => custom((data) => data instanceof cls, params);
      stringType = ZodString.create;
      numberType = ZodNumber.create;
      nanType = ZodNaN.create;
      bigIntType = ZodBigInt.create;
      booleanType = ZodBoolean.create;
      dateType = ZodDate.create;
      symbolType = ZodSymbol.create;
      undefinedType = ZodUndefined.create;
      nullType = ZodNull.create;
      anyType = ZodAny.create;
      unknownType = ZodUnknown.create;
      neverType = ZodNever.create;
      voidType = ZodVoid.create;
      arrayType = ZodArray.create;
      objectType = ZodObject.create;
      strictObjectType = ZodObject.strictCreate;
      unionType = ZodUnion.create;
      discriminatedUnionType = ZodDiscriminatedUnion.create;
      intersectionType = ZodIntersection.create;
      tupleType = ZodTuple.create;
      recordType = ZodRecord.create;
      mapType = ZodMap.create;
      setType = ZodSet.create;
      functionType = ZodFunction.create;
      lazyType = ZodLazy.create;
      literalType = ZodLiteral.create;
      enumType = ZodEnum.create;
      nativeEnumType = ZodNativeEnum.create;
      promiseType = ZodPromise.create;
      effectsType = ZodEffects.create;
      optionalType = ZodOptional.create;
      nullableType = ZodNullable.create;
      preprocessType = ZodEffects.createWithPreprocess;
      pipelineType = ZodPipeline.create;
      ostring = () => stringType().optional();
      onumber = () => numberType().optional();
      oboolean = () => booleanType().optional();
      coerce = {
        string: (arg) => ZodString.create({ ...arg, coerce: true }),
        number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
        boolean: (arg) => ZodBoolean.create({
          ...arg,
          coerce: true
        }),
        bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
        date: (arg) => ZodDate.create({ ...arg, coerce: true })
      };
      NEVER = INVALID;
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/v3/external.js
  var external_exports = {};
  __export(external_exports, {
    BRAND: () => BRAND,
    DIRTY: () => DIRTY,
    EMPTY_PATH: () => EMPTY_PATH,
    INVALID: () => INVALID,
    NEVER: () => NEVER,
    OK: () => OK,
    ParseStatus: () => ParseStatus,
    Schema: () => ZodType,
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBigInt: () => ZodBigInt,
    ZodBoolean: () => ZodBoolean,
    ZodBranded: () => ZodBranded,
    ZodCatch: () => ZodCatch,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodEffects: () => ZodEffects,
    ZodEnum: () => ZodEnum,
    ZodError: () => ZodError,
    ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
    ZodFunction: () => ZodFunction,
    ZodIntersection: () => ZodIntersection,
    ZodIssueCode: () => ZodIssueCode,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNativeEnum: () => ZodNativeEnum,
    ZodNever: () => ZodNever,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodParsedType: () => ZodParsedType,
    ZodPipeline: () => ZodPipeline,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRecord: () => ZodRecord,
    ZodSchema: () => ZodType,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodSymbol: () => ZodSymbol,
    ZodTransformer: () => ZodEffects,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    addIssueToContext: () => addIssueToContext,
    any: () => anyType,
    array: () => arrayType,
    bigint: () => bigIntType,
    boolean: () => booleanType,
    coerce: () => coerce,
    custom: () => custom,
    date: () => dateType,
    datetimeRegex: () => datetimeRegex,
    defaultErrorMap: () => en_default,
    discriminatedUnion: () => discriminatedUnionType,
    effect: () => effectsType,
    enum: () => enumType,
    function: () => functionType,
    getErrorMap: () => getErrorMap,
    getParsedType: () => getParsedType,
    instanceof: () => instanceOfType,
    intersection: () => intersectionType,
    isAborted: () => isAborted,
    isAsync: () => isAsync,
    isDirty: () => isDirty,
    isValid: () => isValid,
    late: () => late,
    lazy: () => lazyType,
    literal: () => literalType,
    makeIssue: () => makeIssue,
    map: () => mapType,
    nan: () => nanType,
    nativeEnum: () => nativeEnumType,
    never: () => neverType,
    null: () => nullType,
    nullable: () => nullableType,
    number: () => numberType,
    object: () => objectType,
    objectUtil: () => objectUtil,
    oboolean: () => oboolean,
    onumber: () => onumber,
    optional: () => optionalType,
    ostring: () => ostring,
    pipeline: () => pipelineType,
    preprocess: () => preprocessType,
    promise: () => promiseType,
    quotelessJson: () => quotelessJson,
    record: () => recordType,
    set: () => setType,
    setErrorMap: () => setErrorMap,
    strictObject: () => strictObjectType,
    string: () => stringType,
    symbol: () => symbolType,
    transformer: () => effectsType,
    tuple: () => tupleType,
    undefined: () => undefinedType,
    union: () => unionType,
    unknown: () => unknownType,
    util: () => util,
    void: () => voidType
  });
  var init_external = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/v3/external.js"() {
      init_errors();
      init_parseUtil();
      init_typeAliases();
      init_util();
      init_types();
      init_ZodError();
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/v3/index.js
  var init_v3 = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/v3/index.js"() {
      init_external();
      init_external();
    }
  });

  // node_modules/@google/genai/node_modules/zod/dist/esm/index.js
  var init_esm = __esm({
    "node_modules/@google/genai/node_modules/zod/dist/esm/index.js"() {
      init_v3();
      init_v3();
    }
  });

  // node_modules/@google/genai/dist/web/index.mjs
  function getDefaultBaseUrls() {
    return {
      geminiUrl: _defaultBaseGeminiUrl,
      vertexUrl: _defaultBaseVertexUrl
    };
  }
  function getBaseUrl(options, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
    var _a, _b, _c;
    if (!((_a = options.httpOptions) === null || _a === void 0 ? void 0 : _a.baseUrl)) {
      const defaultBaseUrls = getDefaultBaseUrls();
      if (options.vertexai) {
        return (_b = defaultBaseUrls.vertexUrl) !== null && _b !== void 0 ? _b : vertexBaseUrlFromEnv;
      } else {
        return (_c = defaultBaseUrls.geminiUrl) !== null && _c !== void 0 ? _c : geminiBaseUrlFromEnv;
      }
    }
    return options.httpOptions.baseUrl;
  }
  function formatMap(templateString, valueMap) {
    const regex = /\{([^}]+)\}/g;
    return templateString.replace(regex, (match, key) => {
      if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
        const value = valueMap[key];
        return value !== void 0 && value !== null ? String(value) : "";
      } else {
        throw new Error(`Key '${key}' not found in valueMap.`);
      }
    });
  }
  function setValueByPath(data, keys, value) {
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (key.endsWith("[]")) {
        const keyName = key.slice(0, -2);
        if (!(keyName in data)) {
          if (Array.isArray(value)) {
            data[keyName] = Array.from({ length: value.length }, () => ({}));
          } else {
            throw new Error(`Value must be a list given an array path ${key}`);
          }
        }
        if (Array.isArray(data[keyName])) {
          const arrayData = data[keyName];
          if (Array.isArray(value)) {
            for (let j = 0; j < arrayData.length; j++) {
              const entry = arrayData[j];
              setValueByPath(entry, keys.slice(i + 1), value[j]);
            }
          } else {
            for (const d of arrayData) {
              setValueByPath(d, keys.slice(i + 1), value);
            }
          }
        }
        return;
      } else if (key.endsWith("[0]")) {
        const keyName = key.slice(0, -3);
        if (!(keyName in data)) {
          data[keyName] = [{}];
        }
        const arrayData = data[keyName];
        setValueByPath(arrayData[0], keys.slice(i + 1), value);
        return;
      }
      if (!data[key] || typeof data[key] !== "object") {
        data[key] = {};
      }
      data = data[key];
    }
    const keyToSet = keys[keys.length - 1];
    const existingData = data[keyToSet];
    if (existingData !== void 0) {
      if (!value || typeof value === "object" && Object.keys(value).length === 0) {
        return;
      }
      if (value === existingData) {
        return;
      }
      if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) {
        Object.assign(existingData, value);
      } else {
        throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
      }
    } else {
      data[keyToSet] = value;
    }
  }
  function getValueByPath(data, keys) {
    try {
      if (keys.length === 1 && keys[0] === "_self") {
        return data;
      }
      for (let i = 0; i < keys.length; i++) {
        if (typeof data !== "object" || data === null) {
          return void 0;
        }
        const key = keys[i];
        if (key.endsWith("[]")) {
          const keyName = key.slice(0, -2);
          if (keyName in data) {
            const arrayData = data[keyName];
            if (!Array.isArray(arrayData)) {
              return void 0;
            }
            return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1)));
          } else {
            return void 0;
          }
        } else {
          data = data[key];
        }
      }
      return data;
    } catch (error) {
      if (error instanceof TypeError) {
        return void 0;
      }
      throw error;
    }
  }
  function tModel(apiClient, model) {
    if (!model || typeof model !== "string") {
      throw new Error("model is required and must be a string");
    }
    if (apiClient.isVertexAI()) {
      if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) {
        return model;
      } else if (model.indexOf("/") >= 0) {
        const parts = model.split("/", 2);
        return `publishers/${parts[0]}/models/${parts[1]}`;
      } else {
        return `publishers/google/models/${model}`;
      }
    } else {
      if (model.startsWith("models/") || model.startsWith("tunedModels/")) {
        return model;
      } else {
        return `models/${model}`;
      }
    }
  }
  function tCachesModel(apiClient, model) {
    const transformedModel = tModel(apiClient, model);
    if (!transformedModel) {
      return "";
    }
    if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) {
      return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
    } else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) {
      return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
    } else {
      return transformedModel;
    }
  }
  function tBlobs(apiClient, blobs) {
    if (Array.isArray(blobs)) {
      return blobs.map((blob) => tBlob(apiClient, blob));
    } else {
      return [tBlob(apiClient, blobs)];
    }
  }
  function tBlob(apiClient, blob) {
    if (typeof blob === "object" && blob !== null) {
      return blob;
    }
    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
  }
  function tImageBlob(apiClient, blob) {
    const transformedBlob = tBlob(apiClient, blob);
    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) {
      return transformedBlob;
    }
    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
  }
  function tAudioBlob(apiClient, blob) {
    const transformedBlob = tBlob(apiClient, blob);
    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) {
      return transformedBlob;
    }
    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
  }
  function tPart(apiClient, origin) {
    if (origin === null || origin === void 0) {
      throw new Error("PartUnion is required");
    }
    if (typeof origin === "object") {
      return origin;
    }
    if (typeof origin === "string") {
      return { text: origin };
    }
    throw new Error(`Unsupported part type: ${typeof origin}`);
  }
  function tParts(apiClient, origin) {
    if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
      throw new Error("PartListUnion is required");
    }
    if (Array.isArray(origin)) {
      return origin.map((item) => tPart(apiClient, item));
    }
    return [tPart(apiClient, origin)];
  }
  function _isContent(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
  }
  function _isFunctionCallPart(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
  }
  function _isFunctionResponsePart(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
  }
  function tContent(apiClient, origin) {
    if (origin === null || origin === void 0) {
      throw new Error("ContentUnion is required");
    }
    if (_isContent(origin)) {
      return origin;
    }
    return {
      role: "user",
      parts: tParts(apiClient, origin)
    };
  }
  function tContentsForEmbed(apiClient, origin) {
    if (!origin) {
      return [];
    }
    if (apiClient.isVertexAI() && Array.isArray(origin)) {
      return origin.flatMap((item) => {
        const content = tContent(apiClient, item);
        if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
          return [content.parts[0].text];
        }
        return [];
      });
    } else if (apiClient.isVertexAI()) {
      const content = tContent(apiClient, origin);
      if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
        return [content.parts[0].text];
      }
      return [];
    }
    if (Array.isArray(origin)) {
      return origin.map((item) => tContent(apiClient, item));
    }
    return [tContent(apiClient, origin)];
  }
  function tContents(apiClient, origin) {
    if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
      throw new Error("contents are required");
    }
    if (!Array.isArray(origin)) {
      if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {
        throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
      }
      return [tContent(apiClient, origin)];
    }
    const result = [];
    const accumulatedParts = [];
    const isContentArray = _isContent(origin[0]);
    for (const item of origin) {
      const isContent = _isContent(item);
      if (isContent != isContentArray) {
        throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
      }
      if (isContent) {
        result.push(item);
      } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {
        throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
      } else {
        accumulatedParts.push(item);
      }
    }
    if (!isContentArray) {
      result.push({ role: "user", parts: tParts(apiClient, accumulatedParts) });
    }
    return result;
  }
  function createJsonSchemaValidator(strictMode = true) {
    const jsonSchemaValidator = external_exports.lazy(() => {
      const baseShape = external_exports.object({
        // --- Type ---
        type: schemaTypeUnion.optional(),
        // --- Annotations ---
        format: external_exports.string().optional(),
        title: external_exports.string().optional(),
        description: external_exports.string().optional(),
        default: external_exports.unknown().optional(),
        // --- Array Validations ---
        items: jsonSchemaValidator.optional(),
        minItems: external_exports.coerce.string().optional(),
        maxItems: external_exports.coerce.string().optional(),
        // --- Generic Validations ---
        enum: external_exports.array(external_exports.unknown()).optional(),
        // --- Object Validations ---
        properties: external_exports.record(external_exports.string(), jsonSchemaValidator).optional(),
        required: external_exports.array(external_exports.string()).optional(),
        minProperties: external_exports.coerce.string().optional(),
        maxProperties: external_exports.coerce.string().optional(),
        propertyOrdering: external_exports.array(external_exports.string()).optional(),
        // --- Numeric Validations ---
        minimum: external_exports.number().optional(),
        maximum: external_exports.number().optional(),
        // --- String Validations ---
        minLength: external_exports.coerce.string().optional(),
        maxLength: external_exports.coerce.string().optional(),
        pattern: external_exports.string().optional(),
        // --- Schema Composition ---
        anyOf: external_exports.array(jsonSchemaValidator).optional(),
        // --- Additional Properties --- This field is not included in the
        // JSONSchema, will not be communicated to the model, it is here purely
        // for enabling the zod validation strict mode.
        additionalProperties: external_exports.boolean().optional()
      });
      return strictMode ? baseShape.strict() : baseShape;
    });
    return jsonSchemaValidator;
  }
  function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
    if (typeList.includes("null")) {
      resultingSchema["nullable"] = true;
    }
    const listWithoutNull = typeList.filter((type) => type !== "null");
    if (listWithoutNull.length === 1) {
      resultingSchema["type"] = Object.keys(Type).includes(listWithoutNull[0].toUpperCase()) ? Type[listWithoutNull[0].toUpperCase()] : Type.TYPE_UNSPECIFIED;
    } else {
      resultingSchema["anyOf"] = [];
      for (const i of listWithoutNull) {
        resultingSchema["anyOf"].push({
          "type": Object.keys(Type).includes(i.toUpperCase()) ? Type[i.toUpperCase()] : Type.TYPE_UNSPECIFIED
        });
      }
    }
  }
  function processJsonSchema(_jsonSchema) {
    const genAISchema = {};
    const schemaFieldNames = ["items"];
    const listSchemaFieldNames = ["anyOf"];
    const dictSchemaFieldNames = ["properties"];
    if (_jsonSchema["type"] && _jsonSchema["anyOf"]) {
      throw new Error("type and anyOf cannot be both populated.");
    }
    const incomingAnyOf = _jsonSchema["anyOf"];
    if (incomingAnyOf != null && incomingAnyOf.length == 2) {
      if (incomingAnyOf[0]["type"] === "null") {
        genAISchema["nullable"] = true;
        _jsonSchema = incomingAnyOf[1];
      } else if (incomingAnyOf[1]["type"] === "null") {
        genAISchema["nullable"] = true;
        _jsonSchema = incomingAnyOf[0];
      }
    }
    if (_jsonSchema["type"] instanceof Array) {
      flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
    }
    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
      if (fieldValue == null) {
        continue;
      }
      if (fieldName == "type") {
        if (fieldValue === "null") {
          throw new Error("type: null can not be the only possible type for the field.");
        }
        if (fieldValue instanceof Array) {
          continue;
        }
        genAISchema["type"] = Object.keys(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
      } else if (schemaFieldNames.includes(fieldName)) {
        genAISchema[fieldName] = processJsonSchema(fieldValue);
      } else if (listSchemaFieldNames.includes(fieldName)) {
        const listSchemaFieldValue = [];
        for (const item of fieldValue) {
          if (item["type"] == "null") {
            genAISchema["nullable"] = true;
            continue;
          }
          listSchemaFieldValue.push(processJsonSchema(item));
        }
        genAISchema[fieldName] = listSchemaFieldValue;
      } else if (dictSchemaFieldNames.includes(fieldName)) {
        const dictSchemaFieldValue = {};
        for (const [key, value] of Object.entries(fieldValue)) {
          dictSchemaFieldValue[key] = processJsonSchema(value);
        }
        genAISchema[fieldName] = dictSchemaFieldValue;
      } else {
        if (fieldName === "additionalProperties") {
          continue;
        }
        genAISchema[fieldName] = fieldValue;
      }
    }
    return genAISchema;
  }
  function tSchema(apiClient, schema) {
    if (Object.keys(schema).includes("$schema")) {
      delete schema["$schema"];
      const validatedJsonSchema = createJsonSchemaValidator().parse(schema);
      return processJsonSchema(validatedJsonSchema);
    } else {
      return processJsonSchema(schema);
    }
  }
  function tSpeechConfig(apiClient, speechConfig) {
    if (typeof speechConfig === "object") {
      return speechConfig;
    } else if (typeof speechConfig === "string") {
      return {
        voiceConfig: {
          prebuiltVoiceConfig: {
            voiceName: speechConfig
          }
        }
      };
    } else {
      throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
    }
  }
  function tLiveSpeechConfig(apiClient, speechConfig) {
    if ("multiSpeakerVoiceConfig" in speechConfig) {
      throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
    }
    return speechConfig;
  }
  function tTool(apiClient, tool) {
    if (tool.functionDeclarations) {
      for (const functionDeclaration of tool.functionDeclarations) {
        if (functionDeclaration.parameters) {
          functionDeclaration.parameters = tSchema(apiClient, functionDeclaration.parameters);
        }
        if (functionDeclaration.response) {
          functionDeclaration.response = tSchema(apiClient, functionDeclaration.response);
        }
      }
    }
    return tool;
  }
  function tTools(apiClient, tools) {
    if (tools === void 0 || tools === null) {
      throw new Error("tools is required");
    }
    if (!Array.isArray(tools)) {
      throw new Error("tools is required and must be an array of Tools");
    }
    const result = [];
    for (const tool of tools) {
      result.push(tool);
    }
    return result;
  }
  function resourceName(client, resourceName2, resourcePrefix, splitsAfterPrefix = 1) {
    const shouldAppendPrefix = !resourceName2.startsWith(`${resourcePrefix}/`) && resourceName2.split("/").length === splitsAfterPrefix;
    if (client.isVertexAI()) {
      if (resourceName2.startsWith("projects/")) {
        return resourceName2;
      } else if (resourceName2.startsWith("locations/")) {
        return `projects/${client.getProject()}/${resourceName2}`;
      } else if (resourceName2.startsWith(`${resourcePrefix}/`)) {
        return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName2}`;
      } else if (shouldAppendPrefix) {
        return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName2}`;
      } else {
        return resourceName2;
      }
    }
    if (shouldAppendPrefix) {
      return `${resourcePrefix}/${resourceName2}`;
    }
    return resourceName2;
  }
  function tCachedContentName(apiClient, name) {
    if (typeof name !== "string") {
      throw new Error("name must be a string");
    }
    return resourceName(apiClient, name, "cachedContents");
  }
  function tTuningJobStatus(apiClient, status) {
    switch (status) {
      case "STATE_UNSPECIFIED":
        return "JOB_STATE_UNSPECIFIED";
      case "CREATING":
        return "JOB_STATE_RUNNING";
      case "ACTIVE":
        return "JOB_STATE_SUCCEEDED";
      case "FAILED":
        return "JOB_STATE_FAILED";
      default:
        return status;
    }
  }
  function tBytes(apiClient, fromImageBytes) {
    if (typeof fromImageBytes !== "string") {
      throw new Error("fromImageBytes must be a string");
    }
    return fromImageBytes;
  }
  function _isFile(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "name" in origin;
  }
  function isGeneratedVideo(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "video" in origin;
  }
  function isVideo(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "uri" in origin;
  }
  function tFileName(apiClient, fromName) {
    var _a;
    let name;
    if (_isFile(fromName)) {
      name = fromName.name;
    }
    if (isVideo(fromName)) {
      name = fromName.uri;
      if (name === void 0) {
        return void 0;
      }
    }
    if (isGeneratedVideo(fromName)) {
      name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;
      if (name === void 0) {
        return void 0;
      }
    }
    if (typeof fromName === "string") {
      name = fromName;
    }
    if (name === void 0) {
      throw new Error("Could not extract file name from the provided input.");
    }
    if (name.startsWith("https://")) {
      const suffix = name.split("files/")[1];
      const match = suffix.match(/[a-z0-9]+/);
      if (match === null) {
        throw new Error(`Could not extract file name from URI ${name}`);
      }
      name = match[0];
    } else if (name.startsWith("files/")) {
      name = name.split("files/")[1];
    }
    return name;
  }
  function tModelsUrl(apiClient, baseModels) {
    let res;
    if (apiClient.isVertexAI()) {
      res = baseModels ? "publishers/google/models" : "models";
    } else {
      res = baseModels ? "models" : "tunedModels";
    }
    return res;
  }
  function tExtractModels(apiClient, response) {
    for (const key of ["models", "tunedModels", "publisherModels"]) {
      if (hasField(response, key)) {
        return response[key];
      }
    }
    return [];
  }
  function hasField(data, fieldName) {
    return data !== null && typeof data === "object" && fieldName in data;
  }
  function videoMetadataToMldev$2(apiClient, fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function blobToMldev$2(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToMldev$2(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function partToMldev$2(apiClient, fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$2(apiClient, fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$2(apiClient, fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$2(apiClient, fromFileData));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], fromFunctionCall);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function contentToMldev$2(apiClient, fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$2(apiClient, item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function functionDeclarationToMldev$2(apiClient, fromObject) {
    const toObject = {};
    const fromBehavior = getValueByPath(fromObject, ["behavior"]);
    if (fromBehavior != null) {
      setValueByPath(toObject, ["behavior"], fromBehavior);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    return toObject;
  }
  function intervalToMldev$2(apiClient, fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function googleSearchToMldev$2(apiClient, fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$2(apiClient, fromTimeRangeFilter));
    }
    return toObject;
  }
  function dynamicRetrievalConfigToMldev$2(apiClient, fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function googleSearchRetrievalToMldev$2(apiClient, fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$2(apiClient, fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function urlContextToMldev$2() {
    const toObject = {};
    return toObject;
  }
  function toolToMldev$2(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToMldev$2(apiClient, item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(apiClient, fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$2(apiClient, fromGoogleSearchRetrieval));
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
      throw new Error("googleMaps parameter is not supported in Gemini API.");
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToMldev$2());
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function functionCallingConfigToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    return toObject;
  }
  function latLngToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromLatitude = getValueByPath(fromObject, ["latitude"]);
    if (fromLatitude != null) {
      setValueByPath(toObject, ["latitude"], fromLatitude);
    }
    const fromLongitude = getValueByPath(fromObject, ["longitude"]);
    if (fromLongitude != null) {
      setValueByPath(toObject, ["longitude"], fromLongitude);
    }
    return toObject;
  }
  function retrievalConfigToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromLatLng = getValueByPath(fromObject, ["latLng"]);
    if (fromLatLng != null) {
      setValueByPath(toObject, ["latLng"], latLngToMldev$1(apiClient, fromLatLng));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function toolConfigToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(apiClient, fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev$1(apiClient, fromRetrievalConfig));
    }
    return toObject;
  }
  function createCachedContentConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (parentObject !== void 0 && fromContents != null) {
      let transformedList = tContents(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$2(apiClient, item);
        });
      }
      setValueByPath(parentObject, ["contents"], transformedList);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev$2(apiClient, tContent(apiClient, fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$2(apiClient, item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(apiClient, fromToolConfig));
    }
    if (getValueByPath(fromObject, ["kmsKeyName"]) !== void 0) {
      throw new Error("kmsKeyName parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function createCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], createCachedContentConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function getCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function deleteCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function updateCachedContentConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    return toObject;
  }
  function updateCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], updateCachedContentConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function listCachedContentsConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listCachedContentsParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], listCachedContentsConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function videoMetadataToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function blobToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function partToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex$2(apiClient, fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToVertex$2(apiClient, fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToVertex$2(apiClient, fromFileData));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], fromFunctionCall);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function contentToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToVertex$2(apiClient, item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function functionDeclarationToVertex$2(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    return toObject;
  }
  function intervalToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function googleSearchToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex$2(apiClient, fromTimeRangeFilter));
    }
    return toObject;
  }
  function dynamicRetrievalConfigToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function googleSearchRetrievalToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex$2(apiClient, fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function enterpriseWebSearchToVertex$2() {
    const toObject = {};
    return toObject;
  }
  function apiKeyConfigToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
    if (fromApiKeyString != null) {
      setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
    }
    return toObject;
  }
  function authConfigToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
    if (fromApiKeyConfig != null) {
      setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex$2(apiClient, fromApiKeyConfig));
    }
    const fromAuthType = getValueByPath(fromObject, ["authType"]);
    if (fromAuthType != null) {
      setValueByPath(toObject, ["authType"], fromAuthType);
    }
    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
      "googleServiceAccountConfig"
    ]);
    if (fromGoogleServiceAccountConfig != null) {
      setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
    }
    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
      "httpBasicAuthConfig"
    ]);
    if (fromHttpBasicAuthConfig != null) {
      setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
    }
    const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
    if (fromOauthConfig != null) {
      setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
    }
    const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
    if (fromOidcConfig != null) {
      setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
    }
    return toObject;
  }
  function googleMapsToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
    if (fromAuthConfig != null) {
      setValueByPath(toObject, ["authConfig"], authConfigToVertex$2(apiClient, fromAuthConfig));
    }
    return toObject;
  }
  function toolToVertex$2(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex$2(apiClient, item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToVertex$2(apiClient, fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex$2(apiClient, fromGoogleSearchRetrieval));
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex$2());
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToVertex$2(apiClient, fromGoogleMaps));
    }
    if (getValueByPath(fromObject, ["urlContext"]) !== void 0) {
      throw new Error("urlContext parameter is not supported in Vertex AI.");
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function functionCallingConfigToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    return toObject;
  }
  function latLngToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromLatitude = getValueByPath(fromObject, ["latitude"]);
    if (fromLatitude != null) {
      setValueByPath(toObject, ["latitude"], fromLatitude);
    }
    const fromLongitude = getValueByPath(fromObject, ["longitude"]);
    if (fromLongitude != null) {
      setValueByPath(toObject, ["longitude"], fromLongitude);
    }
    return toObject;
  }
  function retrievalConfigToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromLatLng = getValueByPath(fromObject, ["latLng"]);
    if (fromLatLng != null) {
      setValueByPath(toObject, ["latLng"], latLngToVertex$1(apiClient, fromLatLng));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function toolConfigToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToVertex$1(apiClient, fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToVertex$1(apiClient, fromRetrievalConfig));
    }
    return toObject;
  }
  function createCachedContentConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (parentObject !== void 0 && fromContents != null) {
      let transformedList = tContents(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToVertex$2(apiClient, item);
        });
      }
      setValueByPath(parentObject, ["contents"], transformedList);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToVertex$2(apiClient, tContent(apiClient, fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex$2(apiClient, item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToVertex$1(apiClient, fromToolConfig));
    }
    const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
    if (parentObject !== void 0 && fromKmsKeyName != null) {
      setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
    }
    return toObject;
  }
  function createCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], createCachedContentConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function getCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function deleteCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function updateCachedContentConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    return toObject;
  }
  function updateCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], updateCachedContentConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function listCachedContentsConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listCachedContentsParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], listCachedContentsConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function cachedContentFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (fromExpireTime != null) {
      setValueByPath(toObject, ["expireTime"], fromExpireTime);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function deleteCachedContentResponseFromMldev() {
    const toObject = {};
    return toObject;
  }
  function listCachedContentsResponseFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromCachedContents = getValueByPath(fromObject, [
      "cachedContents"
    ]);
    if (fromCachedContents != null) {
      let transformedList = fromCachedContents;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return cachedContentFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["cachedContents"], transformedList);
    }
    return toObject;
  }
  function cachedContentFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (fromExpireTime != null) {
      setValueByPath(toObject, ["expireTime"], fromExpireTime);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function deleteCachedContentResponseFromVertex() {
    const toObject = {};
    return toObject;
  }
  function listCachedContentsResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromCachedContents = getValueByPath(fromObject, [
      "cachedContents"
    ]);
    if (fromCachedContents != null) {
      let transformedList = fromCachedContents;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return cachedContentFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["cachedContents"], transformedList);
    }
    return toObject;
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f) {
      return function(v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function isValidResponse(response) {
    var _a;
    if (response.candidates == void 0 || response.candidates.length === 0) {
      return false;
    }
    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;
    if (content === void 0) {
      return false;
    }
    return isValidContent(content);
  }
  function isValidContent(content) {
    if (content.parts === void 0 || content.parts.length === 0) {
      return false;
    }
    for (const part of content.parts) {
      if (part === void 0 || Object.keys(part).length === 0) {
        return false;
      }
      if (!part.thought && part.text !== void 0 && part.text === "") {
        return false;
      }
    }
    return true;
  }
  function validateHistory(history) {
    if (history.length === 0) {
      return;
    }
    for (const content of history) {
      if (content.role !== "user" && content.role !== "model") {
        throw new Error(`Role must be user or model, but got ${content.role}.`);
      }
    }
  }
  function extractCuratedHistory(comprehensiveHistory) {
    if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) {
      return [];
    }
    const curatedHistory = [];
    const length = comprehensiveHistory.length;
    let i = 0;
    while (i < length) {
      if (comprehensiveHistory[i].role === "user") {
        curatedHistory.push(comprehensiveHistory[i]);
        i++;
      } else {
        const modelOutput = [];
        let isValid2 = true;
        while (i < length && comprehensiveHistory[i].role === "model") {
          modelOutput.push(comprehensiveHistory[i]);
          if (isValid2 && !isValidContent(comprehensiveHistory[i])) {
            isValid2 = false;
          }
          i++;
        }
        if (isValid2) {
          curatedHistory.push(...modelOutput);
        } else {
          curatedHistory.pop();
        }
      }
    }
    return curatedHistory;
  }
  function listFilesConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listFilesParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], listFilesConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function fileStatusToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromDetails = getValueByPath(fromObject, ["details"]);
    if (fromDetails != null) {
      setValueByPath(toObject, ["details"], fromDetails);
    }
    const fromMessage = getValueByPath(fromObject, ["message"]);
    if (fromMessage != null) {
      setValueByPath(toObject, ["message"], fromMessage);
    }
    const fromCode = getValueByPath(fromObject, ["code"]);
    if (fromCode != null) {
      setValueByPath(toObject, ["code"], fromCode);
    }
    return toObject;
  }
  function fileToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    const fromSizeBytes = getValueByPath(fromObject, ["sizeBytes"]);
    if (fromSizeBytes != null) {
      setValueByPath(toObject, ["sizeBytes"], fromSizeBytes);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromExpirationTime = getValueByPath(fromObject, [
      "expirationTime"
    ]);
    if (fromExpirationTime != null) {
      setValueByPath(toObject, ["expirationTime"], fromExpirationTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromSha256Hash = getValueByPath(fromObject, ["sha256Hash"]);
    if (fromSha256Hash != null) {
      setValueByPath(toObject, ["sha256Hash"], fromSha256Hash);
    }
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromDownloadUri = getValueByPath(fromObject, ["downloadUri"]);
    if (fromDownloadUri != null) {
      setValueByPath(toObject, ["downloadUri"], fromDownloadUri);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], fromState);
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      setValueByPath(toObject, ["source"], fromSource);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fileStatusToMldev(apiClient, fromError));
    }
    return toObject;
  }
  function createFileParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromFile = getValueByPath(fromObject, ["file"]);
    if (fromFile != null) {
      setValueByPath(toObject, ["file"], fileToMldev(apiClient, fromFile));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function getFileParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "file"], tFileName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function deleteFileParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "file"], tFileName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function fileStatusFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromDetails = getValueByPath(fromObject, ["details"]);
    if (fromDetails != null) {
      setValueByPath(toObject, ["details"], fromDetails);
    }
    const fromMessage = getValueByPath(fromObject, ["message"]);
    if (fromMessage != null) {
      setValueByPath(toObject, ["message"], fromMessage);
    }
    const fromCode = getValueByPath(fromObject, ["code"]);
    if (fromCode != null) {
      setValueByPath(toObject, ["code"], fromCode);
    }
    return toObject;
  }
  function fileFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    const fromSizeBytes = getValueByPath(fromObject, ["sizeBytes"]);
    if (fromSizeBytes != null) {
      setValueByPath(toObject, ["sizeBytes"], fromSizeBytes);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromExpirationTime = getValueByPath(fromObject, [
      "expirationTime"
    ]);
    if (fromExpirationTime != null) {
      setValueByPath(toObject, ["expirationTime"], fromExpirationTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromSha256Hash = getValueByPath(fromObject, ["sha256Hash"]);
    if (fromSha256Hash != null) {
      setValueByPath(toObject, ["sha256Hash"], fromSha256Hash);
    }
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromDownloadUri = getValueByPath(fromObject, ["downloadUri"]);
    if (fromDownloadUri != null) {
      setValueByPath(toObject, ["downloadUri"], fromDownloadUri);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], fromState);
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      setValueByPath(toObject, ["source"], fromSource);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fileStatusFromMldev(apiClient, fromError));
    }
    return toObject;
  }
  function listFilesResponseFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromFiles = getValueByPath(fromObject, ["files"]);
    if (fromFiles != null) {
      let transformedList = fromFiles;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return fileFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["files"], transformedList);
    }
    return toObject;
  }
  function createFileResponseFromMldev() {
    const toObject = {};
    return toObject;
  }
  function deleteFileResponseFromMldev() {
    const toObject = {};
    return toObject;
  }
  function prebuiltVoiceConfigToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
    if (fromVoiceName != null) {
      setValueByPath(toObject, ["voiceName"], fromVoiceName);
    }
    return toObject;
  }
  function prebuiltVoiceConfigToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
    if (fromVoiceName != null) {
      setValueByPath(toObject, ["voiceName"], fromVoiceName);
    }
    return toObject;
  }
  function voiceConfigToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
      "prebuiltVoiceConfig"
    ]);
    if (fromPrebuiltVoiceConfig != null) {
      setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev$1(apiClient, fromPrebuiltVoiceConfig));
    }
    return toObject;
  }
  function voiceConfigToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
      "prebuiltVoiceConfig"
    ]);
    if (fromPrebuiltVoiceConfig != null) {
      setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToVertex$1(apiClient, fromPrebuiltVoiceConfig));
    }
    return toObject;
  }
  function speakerVoiceConfigToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
    if (fromSpeaker != null) {
      setValueByPath(toObject, ["speaker"], fromSpeaker);
    }
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$1(apiClient, fromVoiceConfig));
    }
    return toObject;
  }
  function multiSpeakerVoiceConfigToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
      "speakerVoiceConfigs"
    ]);
    if (fromSpeakerVoiceConfigs != null) {
      let transformedList = fromSpeakerVoiceConfigs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return speakerVoiceConfigToMldev$1(apiClient, item);
        });
      }
      setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
    }
    return toObject;
  }
  function speechConfigToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$1(apiClient, fromVoiceConfig));
    }
    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
      "multiSpeakerVoiceConfig"
    ]);
    if (fromMultiSpeakerVoiceConfig != null) {
      setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev$1(apiClient, fromMultiSpeakerVoiceConfig));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function speechConfigToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToVertex$1(apiClient, fromVoiceConfig));
    }
    if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
      throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function videoMetadataToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoMetadataToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function blobToMldev$1(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function blobToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToMldev$1(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function partToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$1(apiClient, fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$1(apiClient, fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$1(apiClient, fromFileData));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], fromFunctionCall);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function partToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex$1(apiClient, fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToVertex$1(apiClient, fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToVertex$1(apiClient, fromFileData));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], fromFunctionCall);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function contentToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$1(apiClient, item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contentToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToVertex$1(apiClient, item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function functionDeclarationToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromBehavior = getValueByPath(fromObject, ["behavior"]);
    if (fromBehavior != null) {
      setValueByPath(toObject, ["behavior"], fromBehavior);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    return toObject;
  }
  function functionDeclarationToVertex$1(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    return toObject;
  }
  function intervalToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function intervalToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function googleSearchToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$1(apiClient, fromTimeRangeFilter));
    }
    return toObject;
  }
  function googleSearchToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex$1(apiClient, fromTimeRangeFilter));
    }
    return toObject;
  }
  function dynamicRetrievalConfigToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function dynamicRetrievalConfigToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function googleSearchRetrievalToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$1(apiClient, fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function googleSearchRetrievalToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex$1(apiClient, fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function enterpriseWebSearchToVertex$1() {
    const toObject = {};
    return toObject;
  }
  function apiKeyConfigToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
    if (fromApiKeyString != null) {
      setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
    }
    return toObject;
  }
  function authConfigToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
    if (fromApiKeyConfig != null) {
      setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex$1(apiClient, fromApiKeyConfig));
    }
    const fromAuthType = getValueByPath(fromObject, ["authType"]);
    if (fromAuthType != null) {
      setValueByPath(toObject, ["authType"], fromAuthType);
    }
    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
      "googleServiceAccountConfig"
    ]);
    if (fromGoogleServiceAccountConfig != null) {
      setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
    }
    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
      "httpBasicAuthConfig"
    ]);
    if (fromHttpBasicAuthConfig != null) {
      setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
    }
    const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
    if (fromOauthConfig != null) {
      setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
    }
    const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
    if (fromOidcConfig != null) {
      setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
    }
    return toObject;
  }
  function googleMapsToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
    if (fromAuthConfig != null) {
      setValueByPath(toObject, ["authConfig"], authConfigToVertex$1(apiClient, fromAuthConfig));
    }
    return toObject;
  }
  function urlContextToMldev$1() {
    const toObject = {};
    return toObject;
  }
  function toolToMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToMldev$1(apiClient, item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(apiClient, fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$1(apiClient, fromGoogleSearchRetrieval));
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
      throw new Error("googleMaps parameter is not supported in Gemini API.");
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToMldev$1());
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function toolToVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex$1(apiClient, item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToVertex$1(apiClient, fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex$1(apiClient, fromGoogleSearchRetrieval));
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex$1());
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToVertex$1(apiClient, fromGoogleMaps));
    }
    if (getValueByPath(fromObject, ["urlContext"]) !== void 0) {
      throw new Error("urlContext parameter is not supported in Vertex AI.");
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function sessionResumptionConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromHandle = getValueByPath(fromObject, ["handle"]);
    if (fromHandle != null) {
      setValueByPath(toObject, ["handle"], fromHandle);
    }
    if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
      throw new Error("transparent parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function sessionResumptionConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromHandle = getValueByPath(fromObject, ["handle"]);
    if (fromHandle != null) {
      setValueByPath(toObject, ["handle"], fromHandle);
    }
    const fromTransparent = getValueByPath(fromObject, ["transparent"]);
    if (fromTransparent != null) {
      setValueByPath(toObject, ["transparent"], fromTransparent);
    }
    return toObject;
  }
  function audioTranscriptionConfigToMldev() {
    const toObject = {};
    return toObject;
  }
  function audioTranscriptionConfigToVertex() {
    const toObject = {};
    return toObject;
  }
  function automaticActivityDetectionToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromDisabled = getValueByPath(fromObject, ["disabled"]);
    if (fromDisabled != null) {
      setValueByPath(toObject, ["disabled"], fromDisabled);
    }
    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
      "startOfSpeechSensitivity"
    ]);
    if (fromStartOfSpeechSensitivity != null) {
      setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
    }
    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
      "endOfSpeechSensitivity"
    ]);
    if (fromEndOfSpeechSensitivity != null) {
      setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
    }
    const fromPrefixPaddingMs = getValueByPath(fromObject, [
      "prefixPaddingMs"
    ]);
    if (fromPrefixPaddingMs != null) {
      setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
    }
    const fromSilenceDurationMs = getValueByPath(fromObject, [
      "silenceDurationMs"
    ]);
    if (fromSilenceDurationMs != null) {
      setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
    }
    return toObject;
  }
  function automaticActivityDetectionToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromDisabled = getValueByPath(fromObject, ["disabled"]);
    if (fromDisabled != null) {
      setValueByPath(toObject, ["disabled"], fromDisabled);
    }
    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
      "startOfSpeechSensitivity"
    ]);
    if (fromStartOfSpeechSensitivity != null) {
      setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
    }
    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
      "endOfSpeechSensitivity"
    ]);
    if (fromEndOfSpeechSensitivity != null) {
      setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
    }
    const fromPrefixPaddingMs = getValueByPath(fromObject, [
      "prefixPaddingMs"
    ]);
    if (fromPrefixPaddingMs != null) {
      setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
    }
    const fromSilenceDurationMs = getValueByPath(fromObject, [
      "silenceDurationMs"
    ]);
    if (fromSilenceDurationMs != null) {
      setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
    }
    return toObject;
  }
  function realtimeInputConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromAutomaticActivityDetection = getValueByPath(fromObject, [
      "automaticActivityDetection"
    ]);
    if (fromAutomaticActivityDetection != null) {
      setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToMldev(apiClient, fromAutomaticActivityDetection));
    }
    const fromActivityHandling = getValueByPath(fromObject, [
      "activityHandling"
    ]);
    if (fromActivityHandling != null) {
      setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
    }
    const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
    if (fromTurnCoverage != null) {
      setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
    }
    return toObject;
  }
  function realtimeInputConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromAutomaticActivityDetection = getValueByPath(fromObject, [
      "automaticActivityDetection"
    ]);
    if (fromAutomaticActivityDetection != null) {
      setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToVertex(apiClient, fromAutomaticActivityDetection));
    }
    const fromActivityHandling = getValueByPath(fromObject, [
      "activityHandling"
    ]);
    if (fromActivityHandling != null) {
      setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
    }
    const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
    if (fromTurnCoverage != null) {
      setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
    }
    return toObject;
  }
  function slidingWindowToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
    if (fromTargetTokens != null) {
      setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
    }
    return toObject;
  }
  function slidingWindowToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
    if (fromTargetTokens != null) {
      setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
    }
    return toObject;
  }
  function contextWindowCompressionConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromTriggerTokens = getValueByPath(fromObject, [
      "triggerTokens"
    ]);
    if (fromTriggerTokens != null) {
      setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
    }
    const fromSlidingWindow = getValueByPath(fromObject, [
      "slidingWindow"
    ]);
    if (fromSlidingWindow != null) {
      setValueByPath(toObject, ["slidingWindow"], slidingWindowToMldev(apiClient, fromSlidingWindow));
    }
    return toObject;
  }
  function contextWindowCompressionConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromTriggerTokens = getValueByPath(fromObject, [
      "triggerTokens"
    ]);
    if (fromTriggerTokens != null) {
      setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
    }
    const fromSlidingWindow = getValueByPath(fromObject, [
      "slidingWindow"
    ]);
    if (fromSlidingWindow != null) {
      setValueByPath(toObject, ["slidingWindow"], slidingWindowToVertex(apiClient, fromSlidingWindow));
    }
    return toObject;
  }
  function proactivityConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromProactiveAudio = getValueByPath(fromObject, [
      "proactiveAudio"
    ]);
    if (fromProactiveAudio != null) {
      setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
    }
    return toObject;
  }
  function proactivityConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromProactiveAudio = getValueByPath(fromObject, [
      "proactiveAudio"
    ]);
    if (fromProactiveAudio != null) {
      setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
    }
    return toObject;
  }
  function liveConnectConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToMldev$1(apiClient, tLiveSpeechConfig(apiClient, fromSpeechConfig)));
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$1(apiClient, tContent(apiClient, fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(apiClient, fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$1(apiClient, tTool(apiClient, item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(apiClient, fromSessionResumption));
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToMldev());
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToMldev());
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToMldev(apiClient, fromRealtimeInputConfig));
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToMldev(apiClient, fromContextWindowCompression));
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToMldev(apiClient, fromProactivity));
    }
    return toObject;
  }
  function liveConnectConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToVertex$1(apiClient, tLiveSpeechConfig(apiClient, fromSpeechConfig)));
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], contentToVertex$1(apiClient, tContent(apiClient, fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(apiClient, fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex$1(apiClient, tTool(apiClient, item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToVertex(apiClient, fromSessionResumption));
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToVertex());
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToVertex());
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToVertex(apiClient, fromRealtimeInputConfig));
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToVertex(apiClient, fromContextWindowCompression));
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToVertex(apiClient, fromProactivity));
    }
    return toObject;
  }
  function liveConnectParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function liveConnectParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function activityStartToMldev() {
    const toObject = {};
    return toObject;
  }
  function activityStartToVertex() {
    const toObject = {};
    return toObject;
  }
  function activityEndToMldev() {
    const toObject = {};
    return toObject;
  }
  function activityEndToVertex() {
    const toObject = {};
    return toObject;
  }
  function liveSendRealtimeInputParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromMedia = getValueByPath(fromObject, ["media"]);
    if (fromMedia != null) {
      setValueByPath(toObject, ["mediaChunks"], tBlobs(apiClient, fromMedia));
    }
    const fromAudio = getValueByPath(fromObject, ["audio"]);
    if (fromAudio != null) {
      setValueByPath(toObject, ["audio"], tAudioBlob(apiClient, fromAudio));
    }
    const fromAudioStreamEnd = getValueByPath(fromObject, [
      "audioStreamEnd"
    ]);
    if (fromAudioStreamEnd != null) {
      setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], tImageBlob(apiClient, fromVideo));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromActivityStart = getValueByPath(fromObject, [
      "activityStart"
    ]);
    if (fromActivityStart != null) {
      setValueByPath(toObject, ["activityStart"], activityStartToMldev());
    }
    const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
    if (fromActivityEnd != null) {
      setValueByPath(toObject, ["activityEnd"], activityEndToMldev());
    }
    return toObject;
  }
  function liveSendRealtimeInputParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromMedia = getValueByPath(fromObject, ["media"]);
    if (fromMedia != null) {
      setValueByPath(toObject, ["mediaChunks"], tBlobs(apiClient, fromMedia));
    }
    if (getValueByPath(fromObject, ["audio"]) !== void 0) {
      throw new Error("audio parameter is not supported in Vertex AI.");
    }
    const fromAudioStreamEnd = getValueByPath(fromObject, [
      "audioStreamEnd"
    ]);
    if (fromAudioStreamEnd != null) {
      setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
    }
    if (getValueByPath(fromObject, ["video"]) !== void 0) {
      throw new Error("video parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["text"]) !== void 0) {
      throw new Error("text parameter is not supported in Vertex AI.");
    }
    const fromActivityStart = getValueByPath(fromObject, [
      "activityStart"
    ]);
    if (fromActivityStart != null) {
      setValueByPath(toObject, ["activityStart"], activityStartToVertex());
    }
    const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
    if (fromActivityEnd != null) {
      setValueByPath(toObject, ["activityEnd"], activityEndToVertex());
    }
    return toObject;
  }
  function weightedPromptToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromWeight = getValueByPath(fromObject, ["weight"]);
    if (fromWeight != null) {
      setValueByPath(toObject, ["weight"], fromWeight);
    }
    return toObject;
  }
  function liveMusicSetWeightedPromptsParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromWeightedPrompts = getValueByPath(fromObject, [
      "weightedPrompts"
    ]);
    if (fromWeightedPrompts != null) {
      let transformedList = fromWeightedPrompts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return weightedPromptToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["weightedPrompts"], transformedList);
    }
    return toObject;
  }
  function liveMusicGenerationConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromGuidance = getValueByPath(fromObject, ["guidance"]);
    if (fromGuidance != null) {
      setValueByPath(toObject, ["guidance"], fromGuidance);
    }
    const fromBpm = getValueByPath(fromObject, ["bpm"]);
    if (fromBpm != null) {
      setValueByPath(toObject, ["bpm"], fromBpm);
    }
    const fromDensity = getValueByPath(fromObject, ["density"]);
    if (fromDensity != null) {
      setValueByPath(toObject, ["density"], fromDensity);
    }
    const fromBrightness = getValueByPath(fromObject, ["brightness"]);
    if (fromBrightness != null) {
      setValueByPath(toObject, ["brightness"], fromBrightness);
    }
    const fromScale = getValueByPath(fromObject, ["scale"]);
    if (fromScale != null) {
      setValueByPath(toObject, ["scale"], fromScale);
    }
    const fromMuteBass = getValueByPath(fromObject, ["muteBass"]);
    if (fromMuteBass != null) {
      setValueByPath(toObject, ["muteBass"], fromMuteBass);
    }
    const fromMuteDrums = getValueByPath(fromObject, ["muteDrums"]);
    if (fromMuteDrums != null) {
      setValueByPath(toObject, ["muteDrums"], fromMuteDrums);
    }
    const fromOnlyBassAndDrums = getValueByPath(fromObject, [
      "onlyBassAndDrums"
    ]);
    if (fromOnlyBassAndDrums != null) {
      setValueByPath(toObject, ["onlyBassAndDrums"], fromOnlyBassAndDrums);
    }
    return toObject;
  }
  function liveMusicSetConfigParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromMusicGenerationConfig = getValueByPath(fromObject, [
      "musicGenerationConfig"
    ]);
    if (fromMusicGenerationConfig != null) {
      setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigToMldev(apiClient, fromMusicGenerationConfig));
    }
    return toObject;
  }
  function liveMusicClientSetupToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    return toObject;
  }
  function liveMusicClientContentToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromWeightedPrompts = getValueByPath(fromObject, [
      "weightedPrompts"
    ]);
    if (fromWeightedPrompts != null) {
      let transformedList = fromWeightedPrompts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return weightedPromptToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["weightedPrompts"], transformedList);
    }
    return toObject;
  }
  function liveMusicClientMessageToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromSetup = getValueByPath(fromObject, ["setup"]);
    if (fromSetup != null) {
      setValueByPath(toObject, ["setup"], liveMusicClientSetupToMldev(apiClient, fromSetup));
    }
    const fromClientContent = getValueByPath(fromObject, [
      "clientContent"
    ]);
    if (fromClientContent != null) {
      setValueByPath(toObject, ["clientContent"], liveMusicClientContentToMldev(apiClient, fromClientContent));
    }
    const fromMusicGenerationConfig = getValueByPath(fromObject, [
      "musicGenerationConfig"
    ]);
    if (fromMusicGenerationConfig != null) {
      setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigToMldev(apiClient, fromMusicGenerationConfig));
    }
    const fromPlaybackControl = getValueByPath(fromObject, [
      "playbackControl"
    ]);
    if (fromPlaybackControl != null) {
      setValueByPath(toObject, ["playbackControl"], fromPlaybackControl);
    }
    return toObject;
  }
  function liveServerSetupCompleteFromMldev() {
    const toObject = {};
    return toObject;
  }
  function liveServerSetupCompleteFromVertex() {
    const toObject = {};
    return toObject;
  }
  function videoMetadataFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoMetadataFromVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function blobFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function blobFromVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataFromVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function partFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev$1(apiClient, fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobFromMldev$1(apiClient, fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataFromMldev$1(apiClient, fromFileData));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], fromFunctionCall);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function partFromVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataFromVertex$1(apiClient, fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobFromVertex$1(apiClient, fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataFromVertex$1(apiClient, fromFileData));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], fromFunctionCall);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function contentFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partFromMldev$1(apiClient, item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contentFromVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partFromVertex$1(apiClient, item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function transcriptionFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromFinished = getValueByPath(fromObject, ["finished"]);
    if (fromFinished != null) {
      setValueByPath(toObject, ["finished"], fromFinished);
    }
    return toObject;
  }
  function transcriptionFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromFinished = getValueByPath(fromObject, ["finished"]);
    if (fromFinished != null) {
      setValueByPath(toObject, ["finished"], fromFinished);
    }
    return toObject;
  }
  function urlMetadataFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
    if (fromRetrievedUrl != null) {
      setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
    }
    const fromUrlRetrievalStatus = getValueByPath(fromObject, [
      "urlRetrievalStatus"
    ]);
    if (fromUrlRetrievalStatus != null) {
      setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
    }
    return toObject;
  }
  function urlContextMetadataFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
    if (fromUrlMetadata != null) {
      let transformedList = fromUrlMetadata;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return urlMetadataFromMldev$1(apiClient, item);
        });
      }
      setValueByPath(toObject, ["urlMetadata"], transformedList);
    }
    return toObject;
  }
  function liveServerContentFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModelTurn = getValueByPath(fromObject, ["modelTurn"]);
    if (fromModelTurn != null) {
      setValueByPath(toObject, ["modelTurn"], contentFromMldev$1(apiClient, fromModelTurn));
    }
    const fromTurnComplete = getValueByPath(fromObject, ["turnComplete"]);
    if (fromTurnComplete != null) {
      setValueByPath(toObject, ["turnComplete"], fromTurnComplete);
    }
    const fromInterrupted = getValueByPath(fromObject, ["interrupted"]);
    if (fromInterrupted != null) {
      setValueByPath(toObject, ["interrupted"], fromInterrupted);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromGenerationComplete = getValueByPath(fromObject, [
      "generationComplete"
    ]);
    if (fromGenerationComplete != null) {
      setValueByPath(toObject, ["generationComplete"], fromGenerationComplete);
    }
    const fromInputTranscription = getValueByPath(fromObject, [
      "inputTranscription"
    ]);
    if (fromInputTranscription != null) {
      setValueByPath(toObject, ["inputTranscription"], transcriptionFromMldev(apiClient, fromInputTranscription));
    }
    const fromOutputTranscription = getValueByPath(fromObject, [
      "outputTranscription"
    ]);
    if (fromOutputTranscription != null) {
      setValueByPath(toObject, ["outputTranscription"], transcriptionFromMldev(apiClient, fromOutputTranscription));
    }
    const fromUrlContextMetadata = getValueByPath(fromObject, [
      "urlContextMetadata"
    ]);
    if (fromUrlContextMetadata != null) {
      setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev$1(apiClient, fromUrlContextMetadata));
    }
    return toObject;
  }
  function liveServerContentFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModelTurn = getValueByPath(fromObject, ["modelTurn"]);
    if (fromModelTurn != null) {
      setValueByPath(toObject, ["modelTurn"], contentFromVertex$1(apiClient, fromModelTurn));
    }
    const fromTurnComplete = getValueByPath(fromObject, ["turnComplete"]);
    if (fromTurnComplete != null) {
      setValueByPath(toObject, ["turnComplete"], fromTurnComplete);
    }
    const fromInterrupted = getValueByPath(fromObject, ["interrupted"]);
    if (fromInterrupted != null) {
      setValueByPath(toObject, ["interrupted"], fromInterrupted);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromGenerationComplete = getValueByPath(fromObject, [
      "generationComplete"
    ]);
    if (fromGenerationComplete != null) {
      setValueByPath(toObject, ["generationComplete"], fromGenerationComplete);
    }
    const fromInputTranscription = getValueByPath(fromObject, [
      "inputTranscription"
    ]);
    if (fromInputTranscription != null) {
      setValueByPath(toObject, ["inputTranscription"], transcriptionFromVertex(apiClient, fromInputTranscription));
    }
    const fromOutputTranscription = getValueByPath(fromObject, [
      "outputTranscription"
    ]);
    if (fromOutputTranscription != null) {
      setValueByPath(toObject, ["outputTranscription"], transcriptionFromVertex(apiClient, fromOutputTranscription));
    }
    return toObject;
  }
  function functionCallFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function liveServerToolCallFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionCalls = getValueByPath(fromObject, [
      "functionCalls"
    ]);
    if (fromFunctionCalls != null) {
      let transformedList = fromFunctionCalls;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionCallFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["functionCalls"], transformedList);
    }
    return toObject;
  }
  function liveServerToolCallFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionCalls = getValueByPath(fromObject, [
      "functionCalls"
    ]);
    if (fromFunctionCalls != null) {
      let transformedList = fromFunctionCalls;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionCallFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["functionCalls"], transformedList);
    }
    return toObject;
  }
  function liveServerToolCallCancellationFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromIds = getValueByPath(fromObject, ["ids"]);
    if (fromIds != null) {
      setValueByPath(toObject, ["ids"], fromIds);
    }
    return toObject;
  }
  function liveServerToolCallCancellationFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromIds = getValueByPath(fromObject, ["ids"]);
    if (fromIds != null) {
      setValueByPath(toObject, ["ids"], fromIds);
    }
    return toObject;
  }
  function modalityTokenCountFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModality = getValueByPath(fromObject, ["modality"]);
    if (fromModality != null) {
      setValueByPath(toObject, ["modality"], fromModality);
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    return toObject;
  }
  function modalityTokenCountFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModality = getValueByPath(fromObject, ["modality"]);
    if (fromModality != null) {
      setValueByPath(toObject, ["modality"], fromModality);
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    return toObject;
  }
  function usageMetadataFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromPromptTokenCount = getValueByPath(fromObject, [
      "promptTokenCount"
    ]);
    if (fromPromptTokenCount != null) {
      setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
    }
    const fromCachedContentTokenCount = getValueByPath(fromObject, [
      "cachedContentTokenCount"
    ]);
    if (fromCachedContentTokenCount != null) {
      setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
    }
    const fromResponseTokenCount = getValueByPath(fromObject, [
      "responseTokenCount"
    ]);
    if (fromResponseTokenCount != null) {
      setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
    }
    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
      "toolUsePromptTokenCount"
    ]);
    if (fromToolUsePromptTokenCount != null) {
      setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
    }
    const fromThoughtsTokenCount = getValueByPath(fromObject, [
      "thoughtsTokenCount"
    ]);
    if (fromThoughtsTokenCount != null) {
      setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
    }
    const fromTotalTokenCount = getValueByPath(fromObject, [
      "totalTokenCount"
    ]);
    if (fromTotalTokenCount != null) {
      setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
    }
    const fromPromptTokensDetails = getValueByPath(fromObject, [
      "promptTokensDetails"
    ]);
    if (fromPromptTokensDetails != null) {
      let transformedList = fromPromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["promptTokensDetails"], transformedList);
    }
    const fromCacheTokensDetails = getValueByPath(fromObject, [
      "cacheTokensDetails"
    ]);
    if (fromCacheTokensDetails != null) {
      let transformedList = fromCacheTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
    }
    const fromResponseTokensDetails = getValueByPath(fromObject, [
      "responseTokensDetails"
    ]);
    if (fromResponseTokensDetails != null) {
      let transformedList = fromResponseTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["responseTokensDetails"], transformedList);
    }
    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
      "toolUsePromptTokensDetails"
    ]);
    if (fromToolUsePromptTokensDetails != null) {
      let transformedList = fromToolUsePromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
    }
    return toObject;
  }
  function usageMetadataFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromPromptTokenCount = getValueByPath(fromObject, [
      "promptTokenCount"
    ]);
    if (fromPromptTokenCount != null) {
      setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
    }
    const fromCachedContentTokenCount = getValueByPath(fromObject, [
      "cachedContentTokenCount"
    ]);
    if (fromCachedContentTokenCount != null) {
      setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
    }
    const fromResponseTokenCount = getValueByPath(fromObject, [
      "candidatesTokenCount"
    ]);
    if (fromResponseTokenCount != null) {
      setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
    }
    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
      "toolUsePromptTokenCount"
    ]);
    if (fromToolUsePromptTokenCount != null) {
      setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
    }
    const fromThoughtsTokenCount = getValueByPath(fromObject, [
      "thoughtsTokenCount"
    ]);
    if (fromThoughtsTokenCount != null) {
      setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
    }
    const fromTotalTokenCount = getValueByPath(fromObject, [
      "totalTokenCount"
    ]);
    if (fromTotalTokenCount != null) {
      setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
    }
    const fromPromptTokensDetails = getValueByPath(fromObject, [
      "promptTokensDetails"
    ]);
    if (fromPromptTokensDetails != null) {
      let transformedList = fromPromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["promptTokensDetails"], transformedList);
    }
    const fromCacheTokensDetails = getValueByPath(fromObject, [
      "cacheTokensDetails"
    ]);
    if (fromCacheTokensDetails != null) {
      let transformedList = fromCacheTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
    }
    const fromResponseTokensDetails = getValueByPath(fromObject, [
      "candidatesTokensDetails"
    ]);
    if (fromResponseTokensDetails != null) {
      let transformedList = fromResponseTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["responseTokensDetails"], transformedList);
    }
    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
      "toolUsePromptTokensDetails"
    ]);
    if (fromToolUsePromptTokensDetails != null) {
      let transformedList = fromToolUsePromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
    }
    const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
    if (fromTrafficType != null) {
      setValueByPath(toObject, ["trafficType"], fromTrafficType);
    }
    return toObject;
  }
  function liveServerGoAwayFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromTimeLeft = getValueByPath(fromObject, ["timeLeft"]);
    if (fromTimeLeft != null) {
      setValueByPath(toObject, ["timeLeft"], fromTimeLeft);
    }
    return toObject;
  }
  function liveServerGoAwayFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromTimeLeft = getValueByPath(fromObject, ["timeLeft"]);
    if (fromTimeLeft != null) {
      setValueByPath(toObject, ["timeLeft"], fromTimeLeft);
    }
    return toObject;
  }
  function liveServerSessionResumptionUpdateFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromNewHandle = getValueByPath(fromObject, ["newHandle"]);
    if (fromNewHandle != null) {
      setValueByPath(toObject, ["newHandle"], fromNewHandle);
    }
    const fromResumable = getValueByPath(fromObject, ["resumable"]);
    if (fromResumable != null) {
      setValueByPath(toObject, ["resumable"], fromResumable);
    }
    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [
      "lastConsumedClientMessageIndex"
    ]);
    if (fromLastConsumedClientMessageIndex != null) {
      setValueByPath(toObject, ["lastConsumedClientMessageIndex"], fromLastConsumedClientMessageIndex);
    }
    return toObject;
  }
  function liveServerSessionResumptionUpdateFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromNewHandle = getValueByPath(fromObject, ["newHandle"]);
    if (fromNewHandle != null) {
      setValueByPath(toObject, ["newHandle"], fromNewHandle);
    }
    const fromResumable = getValueByPath(fromObject, ["resumable"]);
    if (fromResumable != null) {
      setValueByPath(toObject, ["resumable"], fromResumable);
    }
    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [
      "lastConsumedClientMessageIndex"
    ]);
    if (fromLastConsumedClientMessageIndex != null) {
      setValueByPath(toObject, ["lastConsumedClientMessageIndex"], fromLastConsumedClientMessageIndex);
    }
    return toObject;
  }
  function liveServerMessageFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromSetupComplete = getValueByPath(fromObject, [
      "setupComplete"
    ]);
    if (fromSetupComplete != null) {
      setValueByPath(toObject, ["setupComplete"], liveServerSetupCompleteFromMldev());
    }
    const fromServerContent = getValueByPath(fromObject, [
      "serverContent"
    ]);
    if (fromServerContent != null) {
      setValueByPath(toObject, ["serverContent"], liveServerContentFromMldev(apiClient, fromServerContent));
    }
    const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
    if (fromToolCall != null) {
      setValueByPath(toObject, ["toolCall"], liveServerToolCallFromMldev(apiClient, fromToolCall));
    }
    const fromToolCallCancellation = getValueByPath(fromObject, [
      "toolCallCancellation"
    ]);
    if (fromToolCallCancellation != null) {
      setValueByPath(toObject, ["toolCallCancellation"], liveServerToolCallCancellationFromMldev(apiClient, fromToolCallCancellation));
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], usageMetadataFromMldev(apiClient, fromUsageMetadata));
    }
    const fromGoAway = getValueByPath(fromObject, ["goAway"]);
    if (fromGoAway != null) {
      setValueByPath(toObject, ["goAway"], liveServerGoAwayFromMldev(apiClient, fromGoAway));
    }
    const fromSessionResumptionUpdate = getValueByPath(fromObject, [
      "sessionResumptionUpdate"
    ]);
    if (fromSessionResumptionUpdate != null) {
      setValueByPath(toObject, ["sessionResumptionUpdate"], liveServerSessionResumptionUpdateFromMldev(apiClient, fromSessionResumptionUpdate));
    }
    return toObject;
  }
  function liveServerMessageFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromSetupComplete = getValueByPath(fromObject, [
      "setupComplete"
    ]);
    if (fromSetupComplete != null) {
      setValueByPath(toObject, ["setupComplete"], liveServerSetupCompleteFromVertex());
    }
    const fromServerContent = getValueByPath(fromObject, [
      "serverContent"
    ]);
    if (fromServerContent != null) {
      setValueByPath(toObject, ["serverContent"], liveServerContentFromVertex(apiClient, fromServerContent));
    }
    const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
    if (fromToolCall != null) {
      setValueByPath(toObject, ["toolCall"], liveServerToolCallFromVertex(apiClient, fromToolCall));
    }
    const fromToolCallCancellation = getValueByPath(fromObject, [
      "toolCallCancellation"
    ]);
    if (fromToolCallCancellation != null) {
      setValueByPath(toObject, ["toolCallCancellation"], liveServerToolCallCancellationFromVertex(apiClient, fromToolCallCancellation));
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(apiClient, fromUsageMetadata));
    }
    const fromGoAway = getValueByPath(fromObject, ["goAway"]);
    if (fromGoAway != null) {
      setValueByPath(toObject, ["goAway"], liveServerGoAwayFromVertex(apiClient, fromGoAway));
    }
    const fromSessionResumptionUpdate = getValueByPath(fromObject, [
      "sessionResumptionUpdate"
    ]);
    if (fromSessionResumptionUpdate != null) {
      setValueByPath(toObject, ["sessionResumptionUpdate"], liveServerSessionResumptionUpdateFromVertex(apiClient, fromSessionResumptionUpdate));
    }
    return toObject;
  }
  function liveMusicServerSetupCompleteFromMldev() {
    const toObject = {};
    return toObject;
  }
  function weightedPromptFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromWeight = getValueByPath(fromObject, ["weight"]);
    if (fromWeight != null) {
      setValueByPath(toObject, ["weight"], fromWeight);
    }
    return toObject;
  }
  function liveMusicClientContentFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromWeightedPrompts = getValueByPath(fromObject, [
      "weightedPrompts"
    ]);
    if (fromWeightedPrompts != null) {
      let transformedList = fromWeightedPrompts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return weightedPromptFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["weightedPrompts"], transformedList);
    }
    return toObject;
  }
  function liveMusicGenerationConfigFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromGuidance = getValueByPath(fromObject, ["guidance"]);
    if (fromGuidance != null) {
      setValueByPath(toObject, ["guidance"], fromGuidance);
    }
    const fromBpm = getValueByPath(fromObject, ["bpm"]);
    if (fromBpm != null) {
      setValueByPath(toObject, ["bpm"], fromBpm);
    }
    const fromDensity = getValueByPath(fromObject, ["density"]);
    if (fromDensity != null) {
      setValueByPath(toObject, ["density"], fromDensity);
    }
    const fromBrightness = getValueByPath(fromObject, ["brightness"]);
    if (fromBrightness != null) {
      setValueByPath(toObject, ["brightness"], fromBrightness);
    }
    const fromScale = getValueByPath(fromObject, ["scale"]);
    if (fromScale != null) {
      setValueByPath(toObject, ["scale"], fromScale);
    }
    const fromMuteBass = getValueByPath(fromObject, ["muteBass"]);
    if (fromMuteBass != null) {
      setValueByPath(toObject, ["muteBass"], fromMuteBass);
    }
    const fromMuteDrums = getValueByPath(fromObject, ["muteDrums"]);
    if (fromMuteDrums != null) {
      setValueByPath(toObject, ["muteDrums"], fromMuteDrums);
    }
    const fromOnlyBassAndDrums = getValueByPath(fromObject, [
      "onlyBassAndDrums"
    ]);
    if (fromOnlyBassAndDrums != null) {
      setValueByPath(toObject, ["onlyBassAndDrums"], fromOnlyBassAndDrums);
    }
    return toObject;
  }
  function liveMusicSourceMetadataFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromClientContent = getValueByPath(fromObject, [
      "clientContent"
    ]);
    if (fromClientContent != null) {
      setValueByPath(toObject, ["clientContent"], liveMusicClientContentFromMldev(apiClient, fromClientContent));
    }
    const fromMusicGenerationConfig = getValueByPath(fromObject, [
      "musicGenerationConfig"
    ]);
    if (fromMusicGenerationConfig != null) {
      setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigFromMldev(apiClient, fromMusicGenerationConfig));
    }
    return toObject;
  }
  function audioChunkFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    const fromSourceMetadata = getValueByPath(fromObject, [
      "sourceMetadata"
    ]);
    if (fromSourceMetadata != null) {
      setValueByPath(toObject, ["sourceMetadata"], liveMusicSourceMetadataFromMldev(apiClient, fromSourceMetadata));
    }
    return toObject;
  }
  function liveMusicServerContentFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromAudioChunks = getValueByPath(fromObject, ["audioChunks"]);
    if (fromAudioChunks != null) {
      let transformedList = fromAudioChunks;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return audioChunkFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["audioChunks"], transformedList);
    }
    return toObject;
  }
  function liveMusicFilteredPromptFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromFilteredReason = getValueByPath(fromObject, [
      "filteredReason"
    ]);
    if (fromFilteredReason != null) {
      setValueByPath(toObject, ["filteredReason"], fromFilteredReason);
    }
    return toObject;
  }
  function liveMusicServerMessageFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromSetupComplete = getValueByPath(fromObject, [
      "setupComplete"
    ]);
    if (fromSetupComplete != null) {
      setValueByPath(toObject, ["setupComplete"], liveMusicServerSetupCompleteFromMldev());
    }
    const fromServerContent = getValueByPath(fromObject, [
      "serverContent"
    ]);
    if (fromServerContent != null) {
      setValueByPath(toObject, ["serverContent"], liveMusicServerContentFromMldev(apiClient, fromServerContent));
    }
    const fromFilteredPrompt = getValueByPath(fromObject, [
      "filteredPrompt"
    ]);
    if (fromFilteredPrompt != null) {
      setValueByPath(toObject, ["filteredPrompt"], liveMusicFilteredPromptFromMldev(apiClient, fromFilteredPrompt));
    }
    return toObject;
  }
  function videoMetadataToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function blobToMldev(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToMldev(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function partToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev(apiClient, fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev(apiClient, fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev(apiClient, fromFileData));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], fromFunctionCall);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function contentToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function schemaToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
    if (fromAnyOf != null) {
      setValueByPath(toObject, ["anyOf"], fromAnyOf);
    }
    const fromDefault = getValueByPath(fromObject, ["default"]);
    if (fromDefault != null) {
      setValueByPath(toObject, ["default"], fromDefault);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromEnum = getValueByPath(fromObject, ["enum"]);
    if (fromEnum != null) {
      setValueByPath(toObject, ["enum"], fromEnum);
    }
    const fromExample = getValueByPath(fromObject, ["example"]);
    if (fromExample != null) {
      setValueByPath(toObject, ["example"], fromExample);
    }
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromItems = getValueByPath(fromObject, ["items"]);
    if (fromItems != null) {
      setValueByPath(toObject, ["items"], fromItems);
    }
    const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
    if (fromMaxItems != null) {
      setValueByPath(toObject, ["maxItems"], fromMaxItems);
    }
    const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
    if (fromMaxLength != null) {
      setValueByPath(toObject, ["maxLength"], fromMaxLength);
    }
    const fromMaxProperties = getValueByPath(fromObject, [
      "maxProperties"
    ]);
    if (fromMaxProperties != null) {
      setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
    }
    const fromMaximum = getValueByPath(fromObject, ["maximum"]);
    if (fromMaximum != null) {
      setValueByPath(toObject, ["maximum"], fromMaximum);
    }
    const fromMinItems = getValueByPath(fromObject, ["minItems"]);
    if (fromMinItems != null) {
      setValueByPath(toObject, ["minItems"], fromMinItems);
    }
    const fromMinLength = getValueByPath(fromObject, ["minLength"]);
    if (fromMinLength != null) {
      setValueByPath(toObject, ["minLength"], fromMinLength);
    }
    const fromMinProperties = getValueByPath(fromObject, [
      "minProperties"
    ]);
    if (fromMinProperties != null) {
      setValueByPath(toObject, ["minProperties"], fromMinProperties);
    }
    const fromMinimum = getValueByPath(fromObject, ["minimum"]);
    if (fromMinimum != null) {
      setValueByPath(toObject, ["minimum"], fromMinimum);
    }
    const fromNullable = getValueByPath(fromObject, ["nullable"]);
    if (fromNullable != null) {
      setValueByPath(toObject, ["nullable"], fromNullable);
    }
    const fromPattern = getValueByPath(fromObject, ["pattern"]);
    if (fromPattern != null) {
      setValueByPath(toObject, ["pattern"], fromPattern);
    }
    const fromProperties = getValueByPath(fromObject, ["properties"]);
    if (fromProperties != null) {
      setValueByPath(toObject, ["properties"], fromProperties);
    }
    const fromPropertyOrdering = getValueByPath(fromObject, [
      "propertyOrdering"
    ]);
    if (fromPropertyOrdering != null) {
      setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
    }
    const fromRequired = getValueByPath(fromObject, ["required"]);
    if (fromRequired != null) {
      setValueByPath(toObject, ["required"], fromRequired);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (fromTitle != null) {
      setValueByPath(toObject, ["title"], fromTitle);
    }
    const fromType = getValueByPath(fromObject, ["type"]);
    if (fromType != null) {
      setValueByPath(toObject, ["type"], fromType);
    }
    return toObject;
  }
  function safetySettingToMldev(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["method"]) !== void 0) {
      throw new Error("method parameter is not supported in Gemini API.");
    }
    const fromCategory = getValueByPath(fromObject, ["category"]);
    if (fromCategory != null) {
      setValueByPath(toObject, ["category"], fromCategory);
    }
    const fromThreshold = getValueByPath(fromObject, ["threshold"]);
    if (fromThreshold != null) {
      setValueByPath(toObject, ["threshold"], fromThreshold);
    }
    return toObject;
  }
  function functionDeclarationToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromBehavior = getValueByPath(fromObject, ["behavior"]);
    if (fromBehavior != null) {
      setValueByPath(toObject, ["behavior"], fromBehavior);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    return toObject;
  }
  function intervalToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function googleSearchToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev(apiClient, fromTimeRangeFilter));
    }
    return toObject;
  }
  function dynamicRetrievalConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function googleSearchRetrievalToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev(apiClient, fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function urlContextToMldev() {
    const toObject = {};
    return toObject;
  }
  function toolToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(apiClient, fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev(apiClient, fromGoogleSearchRetrieval));
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
      throw new Error("googleMaps parameter is not supported in Gemini API.");
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToMldev());
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function functionCallingConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    return toObject;
  }
  function latLngToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromLatitude = getValueByPath(fromObject, ["latitude"]);
    if (fromLatitude != null) {
      setValueByPath(toObject, ["latitude"], fromLatitude);
    }
    const fromLongitude = getValueByPath(fromObject, ["longitude"]);
    if (fromLongitude != null) {
      setValueByPath(toObject, ["longitude"], fromLongitude);
    }
    return toObject;
  }
  function retrievalConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromLatLng = getValueByPath(fromObject, ["latLng"]);
    if (fromLatLng != null) {
      setValueByPath(toObject, ["latLng"], latLngToMldev(apiClient, fromLatLng));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function toolConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(apiClient, fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev(apiClient, fromRetrievalConfig));
    }
    return toObject;
  }
  function prebuiltVoiceConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
    if (fromVoiceName != null) {
      setValueByPath(toObject, ["voiceName"], fromVoiceName);
    }
    return toObject;
  }
  function voiceConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
      "prebuiltVoiceConfig"
    ]);
    if (fromPrebuiltVoiceConfig != null) {
      setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev(apiClient, fromPrebuiltVoiceConfig));
    }
    return toObject;
  }
  function speakerVoiceConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
    if (fromSpeaker != null) {
      setValueByPath(toObject, ["speaker"], fromSpeaker);
    }
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev(apiClient, fromVoiceConfig));
    }
    return toObject;
  }
  function multiSpeakerVoiceConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
      "speakerVoiceConfigs"
    ]);
    if (fromSpeakerVoiceConfigs != null) {
      let transformedList = fromSpeakerVoiceConfigs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return speakerVoiceConfigToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
    }
    return toObject;
  }
  function speechConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev(apiClient, fromVoiceConfig));
    }
    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
      "multiSpeakerVoiceConfig"
    ]);
    if (fromMultiSpeakerVoiceConfig != null) {
      setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev(apiClient, fromMultiSpeakerVoiceConfig));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function thinkingConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromIncludeThoughts = getValueByPath(fromObject, [
      "includeThoughts"
    ]);
    if (fromIncludeThoughts != null) {
      setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
    }
    const fromThinkingBudget = getValueByPath(fromObject, [
      "thinkingBudget"
    ]);
    if (fromThinkingBudget != null) {
      setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
    }
    return toObject;
  }
  function generateContentConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev(apiClient, tContent(apiClient, fromSystemInstruction)));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], schemaToMldev(apiClient, tSchema(apiClient, fromResponseSchema)));
    }
    if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
      throw new Error("routingConfig parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
      throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return safetySettingToMldev(apiClient, item);
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(apiClient, fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev(apiClient, tTool(apiClient, item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(apiClient, fromToolConfig));
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToMldev(apiClient, tSpeechConfig(apiClient, fromSpeechConfig)));
    }
    if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
      throw new Error("audioTimestamp parameter is not supported in Gemini API.");
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToMldev(apiClient, fromThinkingConfig));
    }
    return toObject;
  }
  function generateContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function embedContentConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
    }
    if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
      throw new Error("mimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
      throw new Error("autoTruncate parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function embedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      setValueByPath(toObject, ["requests[]", "content"], tContentsForEmbed(apiClient, fromContents));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], embedContentConfigToMldev(apiClient, fromConfig, toObject));
    }
    const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
    if (fromModelForEmbedContent !== void 0) {
      setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
    }
    return toObject;
  }
  function generateImagesConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
      throw new Error("outputGcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) {
      throw new Error("negativePrompt parameter is not supported in Gemini API.");
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    if (getValueByPath(fromObject, ["seed"]) !== void 0) {
      throw new Error("seed parameter is not supported in Gemini API.");
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) {
      throw new Error("addWatermark parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) {
      throw new Error("enhancePrompt parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateImagesParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], generateImagesConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function getModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function listModelsConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
    if (parentObject !== void 0 && fromQueryBase != null) {
      setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
    }
    return toObject;
  }
  function listModelsParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], listModelsConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function updateModelConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
      setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    return toObject;
  }
  function updateModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], updateModelConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function deleteModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function countTokensConfigToMldev(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) {
      throw new Error("systemInstruction parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["tools"]) !== void 0) {
      throw new Error("tools parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) {
      throw new Error("generationConfig parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function countTokensParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], countTokensConfigToMldev(apiClient, fromConfig));
    }
    return toObject;
  }
  function imageToMldev(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(apiClient, fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function generateVideosConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfVideos = getValueByPath(fromObject, [
      "numberOfVideos"
    ]);
    if (parentObject !== void 0 && fromNumberOfVideos != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
    }
    if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
      throw new Error("outputGcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["fps"]) !== void 0) {
      throw new Error("fps parameter is not supported in Gemini API.");
    }
    const fromDurationSeconds = getValueByPath(fromObject, [
      "durationSeconds"
    ]);
    if (parentObject !== void 0 && fromDurationSeconds != null) {
      setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
    }
    if (getValueByPath(fromObject, ["seed"]) !== void 0) {
      throw new Error("seed parameter is not supported in Gemini API.");
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    if (getValueByPath(fromObject, ["resolution"]) !== void 0) {
      throw new Error("resolution parameter is not supported in Gemini API.");
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) {
      throw new Error("pubsubTopic parameter is not supported in Gemini API.");
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) {
      throw new Error("enhancePrompt parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["generateAudio"]) !== void 0) {
      throw new Error("generateAudio parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateVideosParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(apiClient, fromImage));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], generateVideosConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function videoMetadataToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function blobToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function partToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex(apiClient, fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToVertex(apiClient, fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToVertex(apiClient, fromFileData));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], fromFunctionCall);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function contentToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function schemaToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
    if (fromAnyOf != null) {
      setValueByPath(toObject, ["anyOf"], fromAnyOf);
    }
    const fromDefault = getValueByPath(fromObject, ["default"]);
    if (fromDefault != null) {
      setValueByPath(toObject, ["default"], fromDefault);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromEnum = getValueByPath(fromObject, ["enum"]);
    if (fromEnum != null) {
      setValueByPath(toObject, ["enum"], fromEnum);
    }
    const fromExample = getValueByPath(fromObject, ["example"]);
    if (fromExample != null) {
      setValueByPath(toObject, ["example"], fromExample);
    }
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromItems = getValueByPath(fromObject, ["items"]);
    if (fromItems != null) {
      setValueByPath(toObject, ["items"], fromItems);
    }
    const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
    if (fromMaxItems != null) {
      setValueByPath(toObject, ["maxItems"], fromMaxItems);
    }
    const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
    if (fromMaxLength != null) {
      setValueByPath(toObject, ["maxLength"], fromMaxLength);
    }
    const fromMaxProperties = getValueByPath(fromObject, [
      "maxProperties"
    ]);
    if (fromMaxProperties != null) {
      setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
    }
    const fromMaximum = getValueByPath(fromObject, ["maximum"]);
    if (fromMaximum != null) {
      setValueByPath(toObject, ["maximum"], fromMaximum);
    }
    const fromMinItems = getValueByPath(fromObject, ["minItems"]);
    if (fromMinItems != null) {
      setValueByPath(toObject, ["minItems"], fromMinItems);
    }
    const fromMinLength = getValueByPath(fromObject, ["minLength"]);
    if (fromMinLength != null) {
      setValueByPath(toObject, ["minLength"], fromMinLength);
    }
    const fromMinProperties = getValueByPath(fromObject, [
      "minProperties"
    ]);
    if (fromMinProperties != null) {
      setValueByPath(toObject, ["minProperties"], fromMinProperties);
    }
    const fromMinimum = getValueByPath(fromObject, ["minimum"]);
    if (fromMinimum != null) {
      setValueByPath(toObject, ["minimum"], fromMinimum);
    }
    const fromNullable = getValueByPath(fromObject, ["nullable"]);
    if (fromNullable != null) {
      setValueByPath(toObject, ["nullable"], fromNullable);
    }
    const fromPattern = getValueByPath(fromObject, ["pattern"]);
    if (fromPattern != null) {
      setValueByPath(toObject, ["pattern"], fromPattern);
    }
    const fromProperties = getValueByPath(fromObject, ["properties"]);
    if (fromProperties != null) {
      setValueByPath(toObject, ["properties"], fromProperties);
    }
    const fromPropertyOrdering = getValueByPath(fromObject, [
      "propertyOrdering"
    ]);
    if (fromPropertyOrdering != null) {
      setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
    }
    const fromRequired = getValueByPath(fromObject, ["required"]);
    if (fromRequired != null) {
      setValueByPath(toObject, ["required"], fromRequired);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (fromTitle != null) {
      setValueByPath(toObject, ["title"], fromTitle);
    }
    const fromType = getValueByPath(fromObject, ["type"]);
    if (fromType != null) {
      setValueByPath(toObject, ["type"], fromType);
    }
    return toObject;
  }
  function modelSelectionConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromFeatureSelectionPreference = getValueByPath(fromObject, [
      "featureSelectionPreference"
    ]);
    if (fromFeatureSelectionPreference != null) {
      setValueByPath(toObject, ["featureSelectionPreference"], fromFeatureSelectionPreference);
    }
    return toObject;
  }
  function safetySettingToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromMethod = getValueByPath(fromObject, ["method"]);
    if (fromMethod != null) {
      setValueByPath(toObject, ["method"], fromMethod);
    }
    const fromCategory = getValueByPath(fromObject, ["category"]);
    if (fromCategory != null) {
      setValueByPath(toObject, ["category"], fromCategory);
    }
    const fromThreshold = getValueByPath(fromObject, ["threshold"]);
    if (fromThreshold != null) {
      setValueByPath(toObject, ["threshold"], fromThreshold);
    }
    return toObject;
  }
  function functionDeclarationToVertex(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    return toObject;
  }
  function intervalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function googleSearchToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex(apiClient, fromTimeRangeFilter));
    }
    return toObject;
  }
  function dynamicRetrievalConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function googleSearchRetrievalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex(apiClient, fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function enterpriseWebSearchToVertex() {
    const toObject = {};
    return toObject;
  }
  function apiKeyConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
    if (fromApiKeyString != null) {
      setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
    }
    return toObject;
  }
  function authConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
    if (fromApiKeyConfig != null) {
      setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex(apiClient, fromApiKeyConfig));
    }
    const fromAuthType = getValueByPath(fromObject, ["authType"]);
    if (fromAuthType != null) {
      setValueByPath(toObject, ["authType"], fromAuthType);
    }
    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
      "googleServiceAccountConfig"
    ]);
    if (fromGoogleServiceAccountConfig != null) {
      setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
    }
    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
      "httpBasicAuthConfig"
    ]);
    if (fromHttpBasicAuthConfig != null) {
      setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
    }
    const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
    if (fromOauthConfig != null) {
      setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
    }
    const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
    if (fromOidcConfig != null) {
      setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
    }
    return toObject;
  }
  function googleMapsToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
    if (fromAuthConfig != null) {
      setValueByPath(toObject, ["authConfig"], authConfigToVertex(apiClient, fromAuthConfig));
    }
    return toObject;
  }
  function toolToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToVertex(apiClient, fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex(apiClient, fromGoogleSearchRetrieval));
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex());
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToVertex(apiClient, fromGoogleMaps));
    }
    if (getValueByPath(fromObject, ["urlContext"]) !== void 0) {
      throw new Error("urlContext parameter is not supported in Vertex AI.");
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function functionCallingConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    return toObject;
  }
  function latLngToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromLatitude = getValueByPath(fromObject, ["latitude"]);
    if (fromLatitude != null) {
      setValueByPath(toObject, ["latitude"], fromLatitude);
    }
    const fromLongitude = getValueByPath(fromObject, ["longitude"]);
    if (fromLongitude != null) {
      setValueByPath(toObject, ["longitude"], fromLongitude);
    }
    return toObject;
  }
  function retrievalConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromLatLng = getValueByPath(fromObject, ["latLng"]);
    if (fromLatLng != null) {
      setValueByPath(toObject, ["latLng"], latLngToVertex(apiClient, fromLatLng));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function toolConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToVertex(apiClient, fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToVertex(apiClient, fromRetrievalConfig));
    }
    return toObject;
  }
  function prebuiltVoiceConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
    if (fromVoiceName != null) {
      setValueByPath(toObject, ["voiceName"], fromVoiceName);
    }
    return toObject;
  }
  function voiceConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
      "prebuiltVoiceConfig"
    ]);
    if (fromPrebuiltVoiceConfig != null) {
      setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToVertex(apiClient, fromPrebuiltVoiceConfig));
    }
    return toObject;
  }
  function speechConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToVertex(apiClient, fromVoiceConfig));
    }
    if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
      throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function thinkingConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromIncludeThoughts = getValueByPath(fromObject, [
      "includeThoughts"
    ]);
    if (fromIncludeThoughts != null) {
      setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
    }
    const fromThinkingBudget = getValueByPath(fromObject, [
      "thinkingBudget"
    ]);
    if (fromThinkingBudget != null) {
      setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
    }
    return toObject;
  }
  function generateContentConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToVertex(apiClient, tContent(apiClient, fromSystemInstruction)));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], schemaToVertex(apiClient, tSchema(apiClient, fromResponseSchema)));
    }
    const fromRoutingConfig = getValueByPath(fromObject, [
      "routingConfig"
    ]);
    if (fromRoutingConfig != null) {
      setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
    }
    const fromModelSelectionConfig = getValueByPath(fromObject, [
      "modelSelectionConfig"
    ]);
    if (fromModelSelectionConfig != null) {
      setValueByPath(toObject, ["modelConfig"], modelSelectionConfigToVertex(apiClient, fromModelSelectionConfig));
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return safetySettingToVertex(apiClient, item);
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(apiClient, fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex(apiClient, tTool(apiClient, item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToVertex(apiClient, fromToolConfig));
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(apiClient, tSpeechConfig(apiClient, fromSpeechConfig)));
    }
    const fromAudioTimestamp = getValueByPath(fromObject, [
      "audioTimestamp"
    ]);
    if (fromAudioTimestamp != null) {
      setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToVertex(apiClient, fromThinkingConfig));
    }
    return toObject;
  }
  function generateContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function embedContentConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (parentObject !== void 0 && fromMimeType != null) {
      setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
    }
    const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
    if (parentObject !== void 0 && fromAutoTruncate != null) {
      setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
    }
    return toObject;
  }
  function embedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      setValueByPath(toObject, ["instances[]", "content"], tContentsForEmbed(apiClient, fromContents));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], embedContentConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function generateImagesConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
    if (parentObject !== void 0 && fromAddWatermark != null) {
      setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    return toObject;
  }
  function generateImagesParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], generateImagesConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function imageToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(apiClient, fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function maskReferenceConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
    if (fromMaskMode != null) {
      setValueByPath(toObject, ["maskMode"], fromMaskMode);
    }
    const fromSegmentationClasses = getValueByPath(fromObject, [
      "segmentationClasses"
    ]);
    if (fromSegmentationClasses != null) {
      setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
    }
    const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
    if (fromMaskDilation != null) {
      setValueByPath(toObject, ["dilation"], fromMaskDilation);
    }
    return toObject;
  }
  function controlReferenceConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromControlType = getValueByPath(fromObject, ["controlType"]);
    if (fromControlType != null) {
      setValueByPath(toObject, ["controlType"], fromControlType);
    }
    const fromEnableControlImageComputation = getValueByPath(fromObject, [
      "enableControlImageComputation"
    ]);
    if (fromEnableControlImageComputation != null) {
      setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
    }
    return toObject;
  }
  function styleReferenceConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromStyleDescription = getValueByPath(fromObject, [
      "styleDescription"
    ]);
    if (fromStyleDescription != null) {
      setValueByPath(toObject, ["styleDescription"], fromStyleDescription);
    }
    return toObject;
  }
  function subjectReferenceConfigToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromSubjectType = getValueByPath(fromObject, ["subjectType"]);
    if (fromSubjectType != null) {
      setValueByPath(toObject, ["subjectType"], fromSubjectType);
    }
    const fromSubjectDescription = getValueByPath(fromObject, [
      "subjectDescription"
    ]);
    if (fromSubjectDescription != null) {
      setValueByPath(toObject, ["subjectDescription"], fromSubjectDescription);
    }
    return toObject;
  }
  function referenceImageAPIInternalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromReferenceImage = getValueByPath(fromObject, [
      "referenceImage"
    ]);
    if (fromReferenceImage != null) {
      setValueByPath(toObject, ["referenceImage"], imageToVertex(apiClient, fromReferenceImage));
    }
    const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
    if (fromReferenceId != null) {
      setValueByPath(toObject, ["referenceId"], fromReferenceId);
    }
    const fromReferenceType = getValueByPath(fromObject, [
      "referenceType"
    ]);
    if (fromReferenceType != null) {
      setValueByPath(toObject, ["referenceType"], fromReferenceType);
    }
    const fromMaskImageConfig = getValueByPath(fromObject, [
      "maskImageConfig"
    ]);
    if (fromMaskImageConfig != null) {
      setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(apiClient, fromMaskImageConfig));
    }
    const fromControlImageConfig = getValueByPath(fromObject, [
      "controlImageConfig"
    ]);
    if (fromControlImageConfig != null) {
      setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(apiClient, fromControlImageConfig));
    }
    const fromStyleImageConfig = getValueByPath(fromObject, [
      "styleImageConfig"
    ]);
    if (fromStyleImageConfig != null) {
      setValueByPath(toObject, ["styleImageConfig"], styleReferenceConfigToVertex(apiClient, fromStyleImageConfig));
    }
    const fromSubjectImageConfig = getValueByPath(fromObject, [
      "subjectImageConfig"
    ]);
    if (fromSubjectImageConfig != null) {
      setValueByPath(toObject, ["subjectImageConfig"], subjectReferenceConfigToVertex(apiClient, fromSubjectImageConfig));
    }
    return toObject;
  }
  function editImageConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromEditMode = getValueByPath(fromObject, ["editMode"]);
    if (parentObject !== void 0 && fromEditMode != null) {
      setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
    }
    const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
    if (parentObject !== void 0 && fromBaseSteps != null) {
      setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
    }
    return toObject;
  }
  function editImageParametersInternalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromReferenceImages = getValueByPath(fromObject, [
      "referenceImages"
    ]);
    if (fromReferenceImages != null) {
      let transformedList = fromReferenceImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return referenceImageAPIInternalToVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], editImageConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function upscaleImageAPIConfigInternalToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (parentObject !== void 0 && fromMode != null) {
      setValueByPath(parentObject, ["parameters", "mode"], fromMode);
    }
    return toObject;
  }
  function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(apiClient, fromImage));
    }
    const fromUpscaleFactor = getValueByPath(fromObject, [
      "upscaleFactor"
    ]);
    if (fromUpscaleFactor != null) {
      setValueByPath(toObject, ["parameters", "upscaleConfig", "upscaleFactor"], fromUpscaleFactor);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], upscaleImageAPIConfigInternalToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function getModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function listModelsConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
    if (parentObject !== void 0 && fromQueryBase != null) {
      setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
    }
    return toObject;
  }
  function listModelsParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], listModelsConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function updateModelConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
      setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    return toObject;
  }
  function updateModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], updateModelConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function deleteModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function countTokensConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToVertex(apiClient, tContent(apiClient, fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex(apiClient, item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["generationConfig"], fromGenerationConfig);
    }
    return toObject;
  }
  function countTokensParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], countTokensConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function computeTokensParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function generateVideosConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfVideos = getValueByPath(fromObject, [
      "numberOfVideos"
    ]);
    if (parentObject !== void 0 && fromNumberOfVideos != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
    }
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (parentObject !== void 0 && fromFps != null) {
      setValueByPath(parentObject, ["parameters", "fps"], fromFps);
    }
    const fromDurationSeconds = getValueByPath(fromObject, [
      "durationSeconds"
    ]);
    if (parentObject !== void 0 && fromDurationSeconds != null) {
      setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromResolution = getValueByPath(fromObject, ["resolution"]);
    if (parentObject !== void 0 && fromResolution != null) {
      setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
    if (parentObject !== void 0 && fromPubsubTopic != null) {
      setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    const fromGenerateAudio = getValueByPath(fromObject, [
      "generateAudio"
    ]);
    if (parentObject !== void 0 && fromGenerateAudio != null) {
      setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
    }
    return toObject;
  }
  function generateVideosParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(apiClient, fromImage));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], generateVideosConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function videoMetadataFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function blobFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function partFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev(apiClient, fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobFromMldev(apiClient, fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataFromMldev(apiClient, fromFileData));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], fromFunctionCall);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function contentFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function citationMetadataFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromCitations = getValueByPath(fromObject, ["citationSources"]);
    if (fromCitations != null) {
      setValueByPath(toObject, ["citations"], fromCitations);
    }
    return toObject;
  }
  function urlMetadataFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
    if (fromRetrievedUrl != null) {
      setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
    }
    const fromUrlRetrievalStatus = getValueByPath(fromObject, [
      "urlRetrievalStatus"
    ]);
    if (fromUrlRetrievalStatus != null) {
      setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
    }
    return toObject;
  }
  function urlContextMetadataFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
    if (fromUrlMetadata != null) {
      let transformedList = fromUrlMetadata;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return urlMetadataFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["urlMetadata"], transformedList);
    }
    return toObject;
  }
  function candidateFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromContent = getValueByPath(fromObject, ["content"]);
    if (fromContent != null) {
      setValueByPath(toObject, ["content"], contentFromMldev(apiClient, fromContent));
    }
    const fromCitationMetadata = getValueByPath(fromObject, [
      "citationMetadata"
    ]);
    if (fromCitationMetadata != null) {
      setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(apiClient, fromCitationMetadata));
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
    if (fromFinishReason != null) {
      setValueByPath(toObject, ["finishReason"], fromFinishReason);
    }
    const fromUrlContextMetadata = getValueByPath(fromObject, [
      "urlContextMetadata"
    ]);
    if (fromUrlContextMetadata != null) {
      setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev(apiClient, fromUrlContextMetadata));
    }
    const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
    if (fromAvgLogprobs != null) {
      setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromIndex = getValueByPath(fromObject, ["index"]);
    if (fromIndex != null) {
      setValueByPath(toObject, ["index"], fromIndex);
    }
    const fromLogprobsResult = getValueByPath(fromObject, [
      "logprobsResult"
    ]);
    if (fromLogprobsResult != null) {
      setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
    }
    const fromSafetyRatings = getValueByPath(fromObject, [
      "safetyRatings"
    ]);
    if (fromSafetyRatings != null) {
      setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
    }
    return toObject;
  }
  function generateContentResponseFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return candidateFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function contentEmbeddingFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromValues = getValueByPath(fromObject, ["values"]);
    if (fromValues != null) {
      setValueByPath(toObject, ["values"], fromValues);
    }
    return toObject;
  }
  function embedContentMetadataFromMldev() {
    const toObject = {};
    return toObject;
  }
  function embedContentResponseFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
    if (fromEmbeddings != null) {
      let transformedList = fromEmbeddings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentEmbeddingFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["embeddings"], transformedList);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], embedContentMetadataFromMldev());
    }
    return toObject;
  }
  function imageFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromImageBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["imageBytes"], tBytes(apiClient, fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function safetyAttributesFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromCategories = getValueByPath(fromObject, [
      "safetyAttributes",
      "categories"
    ]);
    if (fromCategories != null) {
      setValueByPath(toObject, ["categories"], fromCategories);
    }
    const fromScores = getValueByPath(fromObject, [
      "safetyAttributes",
      "scores"
    ]);
    if (fromScores != null) {
      setValueByPath(toObject, ["scores"], fromScores);
    }
    const fromContentType = getValueByPath(fromObject, ["contentType"]);
    if (fromContentType != null) {
      setValueByPath(toObject, ["contentType"], fromContentType);
    }
    return toObject;
  }
  function generatedImageFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["_self"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageFromMldev(apiClient, fromImage));
    }
    const fromRaiFilteredReason = getValueByPath(fromObject, [
      "raiFilteredReason"
    ]);
    if (fromRaiFilteredReason != null) {
      setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
    }
    const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
    if (fromSafetyAttributes != null) {
      setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(apiClient, fromSafetyAttributes));
    }
    return toObject;
  }
  function generateImagesResponseFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
      "positivePromptSafetyAttributes"
    ]);
    if (fromPositivePromptSafetyAttributes != null) {
      setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(apiClient, fromPositivePromptSafetyAttributes));
    }
    return toObject;
  }
  function tunedModelInfoFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    return toObject;
  }
  function modelFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromVersion = getValueByPath(fromObject, ["version"]);
    if (fromVersion != null) {
      setValueByPath(toObject, ["version"], fromVersion);
    }
    const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModelInfo != null) {
      setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(apiClient, fromTunedModelInfo));
    }
    const fromInputTokenLimit = getValueByPath(fromObject, [
      "inputTokenLimit"
    ]);
    if (fromInputTokenLimit != null) {
      setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
    }
    const fromOutputTokenLimit = getValueByPath(fromObject, [
      "outputTokenLimit"
    ]);
    if (fromOutputTokenLimit != null) {
      setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
    }
    const fromSupportedActions = getValueByPath(fromObject, [
      "supportedGenerationMethods"
    ]);
    if (fromSupportedActions != null) {
      setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
    }
    return toObject;
  }
  function listModelsResponseFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromModels = getValueByPath(fromObject, ["_self"]);
    if (fromModels != null) {
      let transformedList = tExtractModels(apiClient, fromModels);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modelFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["models"], transformedList);
    }
    return toObject;
  }
  function deleteModelResponseFromMldev() {
    const toObject = {};
    return toObject;
  }
  function countTokensResponseFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
    if (fromTotalTokens != null) {
      setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
    }
    const fromCachedContentTokenCount = getValueByPath(fromObject, [
      "cachedContentTokenCount"
    ]);
    if (fromCachedContentTokenCount != null) {
      setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
    }
    return toObject;
  }
  function videoFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["video", "uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "video",
      "encodedVideo"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes(apiClient, fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["encoding"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function generatedVideoFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromMldev$1(apiClient, fromVideo));
    }
    return toObject;
  }
  function generateVideosResponseFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, [
      "generatedSamples"
    ]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromMldev$1(apiClient, item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosOperationFromMldev$1(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, [
      "response",
      "generateVideoResponse"
    ]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromMldev$1(apiClient, fromResponse));
    }
    return toObject;
  }
  function videoMetadataFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function blobFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function partFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataFromVertex(apiClient, fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobFromVertex(apiClient, fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataFromVertex(apiClient, fromFileData));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], fromFunctionCall);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function contentFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function citationMetadataFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromCitations = getValueByPath(fromObject, ["citations"]);
    if (fromCitations != null) {
      setValueByPath(toObject, ["citations"], fromCitations);
    }
    return toObject;
  }
  function candidateFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromContent = getValueByPath(fromObject, ["content"]);
    if (fromContent != null) {
      setValueByPath(toObject, ["content"], contentFromVertex(apiClient, fromContent));
    }
    const fromCitationMetadata = getValueByPath(fromObject, [
      "citationMetadata"
    ]);
    if (fromCitationMetadata != null) {
      setValueByPath(toObject, ["citationMetadata"], citationMetadataFromVertex(apiClient, fromCitationMetadata));
    }
    const fromFinishMessage = getValueByPath(fromObject, [
      "finishMessage"
    ]);
    if (fromFinishMessage != null) {
      setValueByPath(toObject, ["finishMessage"], fromFinishMessage);
    }
    const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
    if (fromFinishReason != null) {
      setValueByPath(toObject, ["finishReason"], fromFinishReason);
    }
    const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
    if (fromAvgLogprobs != null) {
      setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromIndex = getValueByPath(fromObject, ["index"]);
    if (fromIndex != null) {
      setValueByPath(toObject, ["index"], fromIndex);
    }
    const fromLogprobsResult = getValueByPath(fromObject, [
      "logprobsResult"
    ]);
    if (fromLogprobsResult != null) {
      setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
    }
    const fromSafetyRatings = getValueByPath(fromObject, [
      "safetyRatings"
    ]);
    if (fromSafetyRatings != null) {
      setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
    }
    return toObject;
  }
  function generateContentResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return candidateFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromResponseId = getValueByPath(fromObject, ["responseId"]);
    if (fromResponseId != null) {
      setValueByPath(toObject, ["responseId"], fromResponseId);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function contentEmbeddingStatisticsFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromTruncated = getValueByPath(fromObject, ["truncated"]);
    if (fromTruncated != null) {
      setValueByPath(toObject, ["truncated"], fromTruncated);
    }
    const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    return toObject;
  }
  function contentEmbeddingFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromValues = getValueByPath(fromObject, ["values"]);
    if (fromValues != null) {
      setValueByPath(toObject, ["values"], fromValues);
    }
    const fromStatistics = getValueByPath(fromObject, ["statistics"]);
    if (fromStatistics != null) {
      setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(apiClient, fromStatistics));
    }
    return toObject;
  }
  function embedContentMetadataFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromBillableCharacterCount = getValueByPath(fromObject, [
      "billableCharacterCount"
    ]);
    if (fromBillableCharacterCount != null) {
      setValueByPath(toObject, ["billableCharacterCount"], fromBillableCharacterCount);
    }
    return toObject;
  }
  function embedContentResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromEmbeddings = getValueByPath(fromObject, [
      "predictions[]",
      "embeddings"
    ]);
    if (fromEmbeddings != null) {
      let transformedList = fromEmbeddings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentEmbeddingFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["embeddings"], transformedList);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], embedContentMetadataFromVertex(apiClient, fromMetadata));
    }
    return toObject;
  }
  function imageFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromImageBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["imageBytes"], tBytes(apiClient, fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function safetyAttributesFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromCategories = getValueByPath(fromObject, [
      "safetyAttributes",
      "categories"
    ]);
    if (fromCategories != null) {
      setValueByPath(toObject, ["categories"], fromCategories);
    }
    const fromScores = getValueByPath(fromObject, [
      "safetyAttributes",
      "scores"
    ]);
    if (fromScores != null) {
      setValueByPath(toObject, ["scores"], fromScores);
    }
    const fromContentType = getValueByPath(fromObject, ["contentType"]);
    if (fromContentType != null) {
      setValueByPath(toObject, ["contentType"], fromContentType);
    }
    return toObject;
  }
  function generatedImageFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["_self"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageFromVertex(apiClient, fromImage));
    }
    const fromRaiFilteredReason = getValueByPath(fromObject, [
      "raiFilteredReason"
    ]);
    if (fromRaiFilteredReason != null) {
      setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
    }
    const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
    if (fromSafetyAttributes != null) {
      setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(apiClient, fromSafetyAttributes));
    }
    const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromEnhancedPrompt != null) {
      setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
    }
    return toObject;
  }
  function generateImagesResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
      "positivePromptSafetyAttributes"
    ]);
    if (fromPositivePromptSafetyAttributes != null) {
      setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(apiClient, fromPositivePromptSafetyAttributes));
    }
    return toObject;
  }
  function editImageResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function upscaleImageResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function endpointFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["endpoint"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDeployedModelId = getValueByPath(fromObject, [
      "deployedModelId"
    ]);
    if (fromDeployedModelId != null) {
      setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
    }
    return toObject;
  }
  function tunedModelInfoFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, [
      "labels",
      "google-vertex-llm-tuning-base-model-id"
    ]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    return toObject;
  }
  function checkpointFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromCheckpointId = getValueByPath(fromObject, ["checkpointId"]);
    if (fromCheckpointId != null) {
      setValueByPath(toObject, ["checkpointId"], fromCheckpointId);
    }
    const fromEpoch = getValueByPath(fromObject, ["epoch"]);
    if (fromEpoch != null) {
      setValueByPath(toObject, ["epoch"], fromEpoch);
    }
    const fromStep = getValueByPath(fromObject, ["step"]);
    if (fromStep != null) {
      setValueByPath(toObject, ["step"], fromStep);
    }
    return toObject;
  }
  function modelFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromVersion = getValueByPath(fromObject, ["versionId"]);
    if (fromVersion != null) {
      setValueByPath(toObject, ["version"], fromVersion);
    }
    const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
    if (fromEndpoints != null) {
      let transformedList = fromEndpoints;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return endpointFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["endpoints"], transformedList);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      setValueByPath(toObject, ["labels"], fromLabels);
    }
    const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModelInfo != null) {
      setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(apiClient, fromTunedModelInfo));
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (fromDefaultCheckpointId != null) {
      setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
    if (fromCheckpoints != null) {
      let transformedList = fromCheckpoints;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return checkpointFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["checkpoints"], transformedList);
    }
    return toObject;
  }
  function listModelsResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromModels = getValueByPath(fromObject, ["_self"]);
    if (fromModels != null) {
      let transformedList = tExtractModels(apiClient, fromModels);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modelFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["models"], transformedList);
    }
    return toObject;
  }
  function deleteModelResponseFromVertex() {
    const toObject = {};
    return toObject;
  }
  function countTokensResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
    if (fromTotalTokens != null) {
      setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
    }
    return toObject;
  }
  function computeTokensResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
    if (fromTokensInfo != null) {
      setValueByPath(toObject, ["tokensInfo"], fromTokensInfo);
    }
    return toObject;
  }
  function videoFromVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes(apiClient, fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function generatedVideoFromVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromVertex$1(apiClient, fromVideo));
    }
    return toObject;
  }
  function generateVideosResponseFromVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromVertex$1(apiClient, item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosOperationFromVertex$1(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromVertex$1(apiClient, fromResponse));
    }
    return toObject;
  }
  async function throwErrorIfNotOK(response) {
    var _a;
    if (response === void 0) {
      throw new ServerError("response is undefined");
    }
    if (!response.ok) {
      const status = response.status;
      const statusText = response.statusText;
      let errorBody;
      if ((_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.includes("application/json")) {
        errorBody = await response.json();
      } else {
        errorBody = {
          error: {
            message: await response.text(),
            code: response.status,
            status: response.statusText
          }
        };
      }
      const errorMessage = `got status: ${status} ${statusText}. ${JSON.stringify(errorBody)}`;
      if (status >= 400 && status < 500) {
        const clientError = new ClientError(errorMessage);
        throw clientError;
      } else if (status >= 500 && status < 600) {
        const serverError = new ServerError(errorMessage);
        throw serverError;
      }
      throw new Error(errorMessage);
    }
  }
  function hasMcpToolUsage(tools) {
    for (const tool of tools) {
      if (isMcpCallableTool(tool)) {
        return true;
      }
      if (typeof tool === "object" && "inputSchema" in tool) {
        return true;
      }
    }
    return false;
  }
  function setMcpUsageHeader(headers) {
    var _a;
    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : "";
    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();
  }
  function hasMcpClientTools(params) {
    var _a, _b, _c;
    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isMcpCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
  }
  function hasNonMcpTools(params) {
    var _a, _b, _c;
    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => !isMcpCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
  }
  function isMcpCallableTool(object) {
    return object !== null && typeof object === "object" && "tool" in object && "callTool" in object;
  }
  async function handleWebSocketMessage$1(apiClient, onmessage, event) {
    const serverMessage = new LiveMusicServerMessage();
    let data;
    if (event.data instanceof Blob) {
      data = JSON.parse(await event.data.text());
    } else {
      data = JSON.parse(event.data);
    }
    const response = liveMusicServerMessageFromMldev(apiClient, data);
    Object.assign(serverMessage, response);
    onmessage(serverMessage);
  }
  function headersToMap$1(headers) {
    const headerMap = {};
    headers.forEach((value, key) => {
      headerMap[key] = value;
    });
    return headerMap;
  }
  function mapToHeaders$1(map) {
    const headers = new Headers();
    for (const [key, value] of Object.entries(map)) {
      headers.append(key, value);
    }
    return headers;
  }
  async function handleWebSocketMessage(apiClient, onmessage, event) {
    const serverMessage = new LiveServerMessage();
    let data;
    if (event.data instanceof Blob) {
      data = JSON.parse(await event.data.text());
    } else {
      data = JSON.parse(event.data);
    }
    if (apiClient.isVertexAI()) {
      const resp = liveServerMessageFromVertex(apiClient, data);
      Object.assign(serverMessage, resp);
    } else {
      const resp = liveServerMessageFromMldev(apiClient, data);
      Object.assign(serverMessage, resp);
    }
    onmessage(serverMessage);
  }
  function headersToMap(headers) {
    const headerMap = {};
    headers.forEach((value, key) => {
      headerMap[key] = value;
    });
    return headerMap;
  }
  function mapToHeaders(map) {
    const headers = new Headers();
    for (const [key, value] of Object.entries(map)) {
      headers.append(key, value);
    }
    return headers;
  }
  function shouldDisableAfc(config) {
    var _a, _b, _c;
    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {
      return true;
    }
    let callableToolsPresent = false;
    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {
      if (isCallableTool(tool)) {
        callableToolsPresent = true;
        break;
      }
    }
    if (!callableToolsPresent) {
      return true;
    }
    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;
    if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
      console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
      return true;
    }
    return false;
  }
  function isCallableTool(tool) {
    return "callTool" in tool && typeof tool.callTool === "function";
  }
  function shouldAppendAfcHistory(config) {
    var _a;
    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);
  }
  function getOperationParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function getOperationParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function fetchPredictOperationParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["operationName"], fromOperationName);
    }
    const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
    if (fromResourceName != null) {
      setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function videoFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["video", "uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "video",
      "encodedVideo"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes(apiClient, fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["encoding"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function generatedVideoFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromMldev(apiClient, fromVideo));
    }
    return toObject;
  }
  function generateVideosResponseFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, [
      "generatedSamples"
    ]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosOperationFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, [
      "response",
      "generateVideoResponse"
    ]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(apiClient, fromResponse));
    }
    return toObject;
  }
  function videoFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes(apiClient, fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function generatedVideoFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromVertex(apiClient, fromVideo));
    }
    return toObject;
  }
  function generateVideosResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosOperationFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(apiClient, fromResponse));
    }
    return toObject;
  }
  function getTuningJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function listTuningJobsConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listTuningJobsParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], listTuningJobsConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function tuningExampleToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromTextInput = getValueByPath(fromObject, ["textInput"]);
    if (fromTextInput != null) {
      setValueByPath(toObject, ["textInput"], fromTextInput);
    }
    const fromOutput = getValueByPath(fromObject, ["output"]);
    if (fromOutput != null) {
      setValueByPath(toObject, ["output"], fromOutput);
    }
    return toObject;
  }
  function tuningDatasetToMldev(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    const fromExamples = getValueByPath(fromObject, ["examples"]);
    if (fromExamples != null) {
      let transformedList = fromExamples;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tuningExampleToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["examples", "examples"], transformedList);
    }
    return toObject;
  }
  function createTuningJobConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["validationDataset"]) !== void 0) {
      throw new Error("validationDataset parameter is not supported in Gemini API.");
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
    }
    if (getValueByPath(fromObject, ["description"]) !== void 0) {
      throw new Error("description parameter is not supported in Gemini API.");
    }
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "epochCount"], fromEpochCount);
    }
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (fromLearningRateMultiplier != null) {
      setValueByPath(toObject, ["tuningTask", "hyperparameters", "learningRateMultiplier"], fromLearningRateMultiplier);
    }
    if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== void 0) {
      throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["adapterSize"]) !== void 0) {
      throw new Error("adapterSize parameter is not supported in Gemini API.");
    }
    const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
    if (parentObject !== void 0 && fromBatchSize != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "batchSize"], fromBatchSize);
    }
    const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
    if (parentObject !== void 0 && fromLearningRate != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "learningRate"], fromLearningRate);
    }
    return toObject;
  }
  function createTuningJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromTrainingDataset = getValueByPath(fromObject, [
      "trainingDataset"
    ]);
    if (fromTrainingDataset != null) {
      setValueByPath(toObject, ["tuningTask", "trainingData"], tuningDatasetToMldev(apiClient, fromTrainingDataset));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], createTuningJobConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function getTuningJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], fromConfig);
    }
    return toObject;
  }
  function listTuningJobsConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listTuningJobsParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], listTuningJobsConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function tuningDatasetToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (parentObject !== void 0 && fromGcsUri != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
    }
    if (getValueByPath(fromObject, ["examples"]) !== void 0) {
      throw new Error("examples parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function tuningValidationDatasetToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
    }
    return toObject;
  }
  function createTuningJobConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromValidationDataset = getValueByPath(fromObject, [
      "validationDataset"
    ]);
    if (parentObject !== void 0 && fromValidationDataset != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(apiClient, fromValidationDataset));
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
      setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "epochCount"], fromEpochCount);
    }
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
    }
    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
      "exportLastCheckpointOnly"
    ]);
    if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
    }
    const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
    if (parentObject !== void 0 && fromAdapterSize != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
    }
    if (getValueByPath(fromObject, ["batchSize"]) !== void 0) {
      throw new Error("batchSize parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["learningRate"]) !== void 0) {
      throw new Error("learningRate parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function createTuningJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromTrainingDataset = getValueByPath(fromObject, [
      "trainingDataset"
    ]);
    if (fromTrainingDataset != null) {
      setValueByPath(toObject, ["supervisedTuningSpec", "trainingDatasetUri"], tuningDatasetToVertex(apiClient, fromTrainingDataset, toObject));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], createTuningJobConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function tunedModelFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["name"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromEndpoint = getValueByPath(fromObject, ["name"]);
    if (fromEndpoint != null) {
      setValueByPath(toObject, ["endpoint"], fromEndpoint);
    }
    return toObject;
  }
  function tuningJobFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tTuningJobStatus(apiClient, fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, [
      "tuningTask",
      "startTime"
    ]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, [
      "tuningTask",
      "completeTime"
    ]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromTunedModel = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModel != null) {
      setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(apiClient, fromTunedModel));
    }
    const fromDistillationSpec = getValueByPath(fromObject, [
      "distillationSpec"
    ]);
    if (fromDistillationSpec != null) {
      setValueByPath(toObject, ["distillationSpec"], fromDistillationSpec);
    }
    const fromExperiment = getValueByPath(fromObject, ["experiment"]);
    if (fromExperiment != null) {
      setValueByPath(toObject, ["experiment"], fromExperiment);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      setValueByPath(toObject, ["labels"], fromLabels);
    }
    const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
    if (fromPipelineJob != null) {
      setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
    }
    const fromServiceAccount = getValueByPath(fromObject, [
      "serviceAccount"
    ]);
    if (fromServiceAccount != null) {
      setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (fromTunedModelDisplayName != null) {
      setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
    }
    return toObject;
  }
  function listTuningJobsResponseFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
    if (fromTuningJobs != null) {
      let transformedList = fromTuningJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tuningJobFromMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["tuningJobs"], transformedList);
    }
    return toObject;
  }
  function operationFromMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    return toObject;
  }
  function tunedModelCheckpointFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromCheckpointId = getValueByPath(fromObject, ["checkpointId"]);
    if (fromCheckpointId != null) {
      setValueByPath(toObject, ["checkpointId"], fromCheckpointId);
    }
    const fromEpoch = getValueByPath(fromObject, ["epoch"]);
    if (fromEpoch != null) {
      setValueByPath(toObject, ["epoch"], fromEpoch);
    }
    const fromStep = getValueByPath(fromObject, ["step"]);
    if (fromStep != null) {
      setValueByPath(toObject, ["step"], fromStep);
    }
    const fromEndpoint = getValueByPath(fromObject, ["endpoint"]);
    if (fromEndpoint != null) {
      setValueByPath(toObject, ["endpoint"], fromEndpoint);
    }
    return toObject;
  }
  function tunedModelFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromEndpoint = getValueByPath(fromObject, ["endpoint"]);
    if (fromEndpoint != null) {
      setValueByPath(toObject, ["endpoint"], fromEndpoint);
    }
    const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
    if (fromCheckpoints != null) {
      let transformedList = fromCheckpoints;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tunedModelCheckpointFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["checkpoints"], transformedList);
    }
    return toObject;
  }
  function tuningJobFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tTuningJobStatus(apiClient, fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
    if (fromTunedModel != null) {
      setValueByPath(toObject, ["tunedModel"], tunedModelFromVertex(apiClient, fromTunedModel));
    }
    const fromSupervisedTuningSpec = getValueByPath(fromObject, [
      "supervisedTuningSpec"
    ]);
    if (fromSupervisedTuningSpec != null) {
      setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
    }
    const fromTuningDataStats = getValueByPath(fromObject, [
      "tuningDataStats"
    ]);
    if (fromTuningDataStats != null) {
      setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
    }
    const fromEncryptionSpec = getValueByPath(fromObject, [
      "encryptionSpec"
    ]);
    if (fromEncryptionSpec != null) {
      setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
    }
    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [
      "partnerModelTuningSpec"
    ]);
    if (fromPartnerModelTuningSpec != null) {
      setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
    }
    const fromDistillationSpec = getValueByPath(fromObject, [
      "distillationSpec"
    ]);
    if (fromDistillationSpec != null) {
      setValueByPath(toObject, ["distillationSpec"], fromDistillationSpec);
    }
    const fromExperiment = getValueByPath(fromObject, ["experiment"]);
    if (fromExperiment != null) {
      setValueByPath(toObject, ["experiment"], fromExperiment);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      setValueByPath(toObject, ["labels"], fromLabels);
    }
    const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
    if (fromPipelineJob != null) {
      setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
    }
    const fromServiceAccount = getValueByPath(fromObject, [
      "serviceAccount"
    ]);
    if (fromServiceAccount != null) {
      setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (fromTunedModelDisplayName != null) {
      setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
    }
    return toObject;
  }
  function listTuningJobsResponseFromVertex(apiClient, fromObject) {
    const toObject = {};
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
    if (fromTuningJobs != null) {
      let transformedList = fromTuningJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tuningJobFromVertex(apiClient, item);
        });
      }
      setValueByPath(toObject, ["tuningJobs"], transformedList);
    }
    return toObject;
  }
  async function uploadBlob(file, uploadUrl, apiClient) {
    var _a, _b, _c;
    let fileSize = 0;
    let offset = 0;
    let response = new HttpResponse(new Response());
    let uploadCommand = "upload";
    fileSize = file.size;
    while (offset < fileSize) {
      const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
      const chunk = file.slice(offset, offset + chunkSize);
      if (offset + chunkSize >= fileSize) {
        uploadCommand += ", finalize";
      }
      let retryCount = 0;
      let currentDelayMs = INITIAL_RETRY_DELAY_MS;
      while (retryCount < MAX_RETRY_COUNT) {
        response = await apiClient.request({
          path: "",
          body: chunk,
          httpMethod: "POST",
          httpOptions: {
            apiVersion: "",
            baseUrl: uploadUrl,
            headers: {
              "X-Goog-Upload-Command": uploadCommand,
              "X-Goog-Upload-Offset": String(offset),
              "Content-Length": String(chunkSize)
            }
          }
        });
        if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
          break;
        }
        retryCount++;
        await sleep(currentDelayMs);
        currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
      }
      offset += chunkSize;
      if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
        break;
      }
      if (fileSize <= offset) {
        throw new Error("All content has been uploaded, but the upload status is not finalized.");
      }
    }
    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
    if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
      throw new Error("Failed to upload file: Upload status is not finalized.");
    }
    return responseJson["file"];
  }
  async function getBlobStat(file) {
    const fileStat = { size: file.size, type: file.type };
    return fileStat;
  }
  function sleep(ms) {
    return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
  }
  var _defaultBaseGeminiUrl, _defaultBaseVertexUrl, BaseModule, Outcome, Language, Type, HarmCategory, HarmBlockMethod, HarmBlockThreshold, Mode, AuthType, FinishReason, HarmProbability, HarmSeverity, BlockedReason, TrafficType, Modality, MediaResolution, JobState, AdapterSize, FeatureSelectionPreference, Behavior, DynamicRetrievalConfigMode, FunctionCallingConfigMode, UrlRetrievalStatus, SafetyFilterLevel, PersonGeneration, ImagePromptLanguage, MaskReferenceMode, ControlReferenceType, SubjectReferenceType, EditMode, FileState, FileSource, MediaModality, StartSensitivity, EndSensitivity, ActivityHandling, TurnCoverage, FunctionResponseScheduling, Scale, LiveMusicPlaybackControl, GenerateContentResponse, EmbedContentResponse, GenerateImagesResponse, EditImageResponse, UpscaleImageResponse, ListModelsResponse, DeleteModelResponse, CountTokensResponse, ComputeTokensResponse, ListTuningJobsResponse, DeleteCachedContentResponse, ListCachedContentsResponse, ListFilesResponse, HttpResponse, CreateFileResponse, DeleteFileResponse, LiveServerMessage, LiveMusicServerMessage, jsonSchemaTypeValidator, schemaTypeUnion, PagedItem, Pager, Caches, Chats, Chat, Files, CONTENT_TYPE_HEADER, SERVER_TIMEOUT_HEADER, USER_AGENT_HEADER, GOOGLE_API_CLIENT_HEADER, SDK_VERSION, LIBRARY_LABEL, VERTEX_AI_API_DEFAULT_VERSION, GOOGLE_AI_API_DEFAULT_VERSION, responseLineRE, ClientError, ServerError, ApiClient, MCP_LABEL, LiveMusic, LiveMusicSession, FUNCTION_RESPONSE_REQUIRES_ID, Live, defaultLiveSendClientContentParamerters, Session, DEFAULT_MAX_REMOTE_CALLS, Models, Operations, Tunings, BrowserDownloader, MAX_CHUNK_SIZE, MAX_RETRY_COUNT, INITIAL_RETRY_DELAY_MS, DELAY_MULTIPLIER, X_GOOG_UPLOAD_STATUS_HEADER_FIELD, BrowserUploader, BrowserWebSocketFactory, BrowserWebSocket, GOOGLE_API_KEY_HEADER, WebAuth, LANGUAGE_LABEL_PREFIX, GoogleGenAI;
  var init_web = __esm({
    "node_modules/@google/genai/dist/web/index.mjs"() {
      init_esm();
      _defaultBaseGeminiUrl = void 0;
      _defaultBaseVertexUrl = void 0;
      BaseModule = class {
      };
      (function(Outcome2) {
        Outcome2["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
        Outcome2["OUTCOME_OK"] = "OUTCOME_OK";
        Outcome2["OUTCOME_FAILED"] = "OUTCOME_FAILED";
        Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
      })(Outcome || (Outcome = {}));
      (function(Language2) {
        Language2["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
        Language2["PYTHON"] = "PYTHON";
      })(Language || (Language = {}));
      (function(Type3) {
        Type3["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
        Type3["STRING"] = "STRING";
        Type3["NUMBER"] = "NUMBER";
        Type3["INTEGER"] = "INTEGER";
        Type3["BOOLEAN"] = "BOOLEAN";
        Type3["ARRAY"] = "ARRAY";
        Type3["OBJECT"] = "OBJECT";
        Type3["NULL"] = "NULL";
      })(Type || (Type = {}));
      (function(HarmCategory2) {
        HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
        HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
        HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
        HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
        HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
        HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
      })(HarmCategory || (HarmCategory = {}));
      (function(HarmBlockMethod2) {
        HarmBlockMethod2["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
        HarmBlockMethod2["SEVERITY"] = "SEVERITY";
        HarmBlockMethod2["PROBABILITY"] = "PROBABILITY";
      })(HarmBlockMethod || (HarmBlockMethod = {}));
      (function(HarmBlockThreshold2) {
        HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
        HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
        HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
        HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
        HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
        HarmBlockThreshold2["OFF"] = "OFF";
      })(HarmBlockThreshold || (HarmBlockThreshold = {}));
      (function(Mode2) {
        Mode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
        Mode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
      })(Mode || (Mode = {}));
      (function(AuthType2) {
        AuthType2["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
        AuthType2["NO_AUTH"] = "NO_AUTH";
        AuthType2["API_KEY_AUTH"] = "API_KEY_AUTH";
        AuthType2["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
        AuthType2["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
        AuthType2["OAUTH"] = "OAUTH";
        AuthType2["OIDC_AUTH"] = "OIDC_AUTH";
      })(AuthType || (AuthType = {}));
      (function(FinishReason2) {
        FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
        FinishReason2["STOP"] = "STOP";
        FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
        FinishReason2["SAFETY"] = "SAFETY";
        FinishReason2["RECITATION"] = "RECITATION";
        FinishReason2["LANGUAGE"] = "LANGUAGE";
        FinishReason2["OTHER"] = "OTHER";
        FinishReason2["BLOCKLIST"] = "BLOCKLIST";
        FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
        FinishReason2["SPII"] = "SPII";
        FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
        FinishReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
      })(FinishReason || (FinishReason = {}));
      (function(HarmProbability2) {
        HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
        HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
        HarmProbability2["LOW"] = "LOW";
        HarmProbability2["MEDIUM"] = "MEDIUM";
        HarmProbability2["HIGH"] = "HIGH";
      })(HarmProbability || (HarmProbability = {}));
      (function(HarmSeverity2) {
        HarmSeverity2["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
        HarmSeverity2["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
        HarmSeverity2["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
        HarmSeverity2["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
        HarmSeverity2["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
      })(HarmSeverity || (HarmSeverity = {}));
      (function(BlockedReason2) {
        BlockedReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
        BlockedReason2["SAFETY"] = "SAFETY";
        BlockedReason2["OTHER"] = "OTHER";
        BlockedReason2["BLOCKLIST"] = "BLOCKLIST";
        BlockedReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
      })(BlockedReason || (BlockedReason = {}));
      (function(TrafficType2) {
        TrafficType2["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
        TrafficType2["ON_DEMAND"] = "ON_DEMAND";
        TrafficType2["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
      })(TrafficType || (TrafficType = {}));
      (function(Modality2) {
        Modality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
        Modality2["TEXT"] = "TEXT";
        Modality2["IMAGE"] = "IMAGE";
        Modality2["AUDIO"] = "AUDIO";
      })(Modality || (Modality = {}));
      (function(MediaResolution2) {
        MediaResolution2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
        MediaResolution2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
        MediaResolution2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
        MediaResolution2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
      })(MediaResolution || (MediaResolution = {}));
      (function(JobState2) {
        JobState2["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
        JobState2["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
        JobState2["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
        JobState2["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
        JobState2["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
        JobState2["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
        JobState2["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
        JobState2["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
        JobState2["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
        JobState2["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
        JobState2["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
        JobState2["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
      })(JobState || (JobState = {}));
      (function(AdapterSize2) {
        AdapterSize2["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
        AdapterSize2["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
        AdapterSize2["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
        AdapterSize2["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
        AdapterSize2["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
        AdapterSize2["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
        AdapterSize2["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
      })(AdapterSize || (AdapterSize = {}));
      (function(FeatureSelectionPreference2) {
        FeatureSelectionPreference2["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
        FeatureSelectionPreference2["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
        FeatureSelectionPreference2["BALANCED"] = "BALANCED";
        FeatureSelectionPreference2["PRIORITIZE_COST"] = "PRIORITIZE_COST";
      })(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
      (function(Behavior2) {
        Behavior2["UNSPECIFIED"] = "UNSPECIFIED";
        Behavior2["BLOCKING"] = "BLOCKING";
        Behavior2["NON_BLOCKING"] = "NON_BLOCKING";
      })(Behavior || (Behavior = {}));
      (function(DynamicRetrievalConfigMode2) {
        DynamicRetrievalConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
        DynamicRetrievalConfigMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
      })(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
      (function(FunctionCallingConfigMode2) {
        FunctionCallingConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
        FunctionCallingConfigMode2["AUTO"] = "AUTO";
        FunctionCallingConfigMode2["ANY"] = "ANY";
        FunctionCallingConfigMode2["NONE"] = "NONE";
      })(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
      (function(UrlRetrievalStatus2) {
        UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
        UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
        UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
      })(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
      (function(SafetyFilterLevel2) {
        SafetyFilterLevel2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
        SafetyFilterLevel2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
        SafetyFilterLevel2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
        SafetyFilterLevel2["BLOCK_NONE"] = "BLOCK_NONE";
      })(SafetyFilterLevel || (SafetyFilterLevel = {}));
      (function(PersonGeneration2) {
        PersonGeneration2["DONT_ALLOW"] = "DONT_ALLOW";
        PersonGeneration2["ALLOW_ADULT"] = "ALLOW_ADULT";
        PersonGeneration2["ALLOW_ALL"] = "ALLOW_ALL";
      })(PersonGeneration || (PersonGeneration = {}));
      (function(ImagePromptLanguage2) {
        ImagePromptLanguage2["auto"] = "auto";
        ImagePromptLanguage2["en"] = "en";
        ImagePromptLanguage2["ja"] = "ja";
        ImagePromptLanguage2["ko"] = "ko";
        ImagePromptLanguage2["hi"] = "hi";
      })(ImagePromptLanguage || (ImagePromptLanguage = {}));
      (function(MaskReferenceMode2) {
        MaskReferenceMode2["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
        MaskReferenceMode2["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
        MaskReferenceMode2["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
        MaskReferenceMode2["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
        MaskReferenceMode2["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
      })(MaskReferenceMode || (MaskReferenceMode = {}));
      (function(ControlReferenceType2) {
        ControlReferenceType2["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
        ControlReferenceType2["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
        ControlReferenceType2["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
        ControlReferenceType2["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
      })(ControlReferenceType || (ControlReferenceType = {}));
      (function(SubjectReferenceType2) {
        SubjectReferenceType2["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
        SubjectReferenceType2["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
        SubjectReferenceType2["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
        SubjectReferenceType2["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
      })(SubjectReferenceType || (SubjectReferenceType = {}));
      (function(EditMode2) {
        EditMode2["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
        EditMode2["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
        EditMode2["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
        EditMode2["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
        EditMode2["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
        EditMode2["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
        EditMode2["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
        EditMode2["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
      })(EditMode || (EditMode = {}));
      (function(FileState2) {
        FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
        FileState2["PROCESSING"] = "PROCESSING";
        FileState2["ACTIVE"] = "ACTIVE";
        FileState2["FAILED"] = "FAILED";
      })(FileState || (FileState = {}));
      (function(FileSource2) {
        FileSource2["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
        FileSource2["UPLOADED"] = "UPLOADED";
        FileSource2["GENERATED"] = "GENERATED";
      })(FileSource || (FileSource = {}));
      (function(MediaModality2) {
        MediaModality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
        MediaModality2["TEXT"] = "TEXT";
        MediaModality2["IMAGE"] = "IMAGE";
        MediaModality2["VIDEO"] = "VIDEO";
        MediaModality2["AUDIO"] = "AUDIO";
        MediaModality2["DOCUMENT"] = "DOCUMENT";
      })(MediaModality || (MediaModality = {}));
      (function(StartSensitivity2) {
        StartSensitivity2["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
        StartSensitivity2["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
        StartSensitivity2["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
      })(StartSensitivity || (StartSensitivity = {}));
      (function(EndSensitivity2) {
        EndSensitivity2["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
        EndSensitivity2["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
        EndSensitivity2["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
      })(EndSensitivity || (EndSensitivity = {}));
      (function(ActivityHandling2) {
        ActivityHandling2["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
        ActivityHandling2["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
        ActivityHandling2["NO_INTERRUPTION"] = "NO_INTERRUPTION";
      })(ActivityHandling || (ActivityHandling = {}));
      (function(TurnCoverage2) {
        TurnCoverage2["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
        TurnCoverage2["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
        TurnCoverage2["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
      })(TurnCoverage || (TurnCoverage = {}));
      (function(FunctionResponseScheduling2) {
        FunctionResponseScheduling2["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
        FunctionResponseScheduling2["SILENT"] = "SILENT";
        FunctionResponseScheduling2["WHEN_IDLE"] = "WHEN_IDLE";
        FunctionResponseScheduling2["INTERRUPT"] = "INTERRUPT";
      })(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
      (function(Scale2) {
        Scale2["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
        Scale2["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
        Scale2["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
        Scale2["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
        Scale2["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
        Scale2["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
        Scale2["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
        Scale2["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
        Scale2["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
        Scale2["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
        Scale2["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
        Scale2["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
        Scale2["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
      })(Scale || (Scale = {}));
      (function(LiveMusicPlaybackControl2) {
        LiveMusicPlaybackControl2["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
        LiveMusicPlaybackControl2["PLAY"] = "PLAY";
        LiveMusicPlaybackControl2["PAUSE"] = "PAUSE";
        LiveMusicPlaybackControl2["STOP"] = "STOP";
        LiveMusicPlaybackControl2["RESET_CONTEXT"] = "RESET_CONTEXT";
      })(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
      GenerateContentResponse = class {
        /**
         * Returns the concatenation of all text parts from the first candidate in the response.
         *
         * @remarks
         * If there are multiple candidates in the response, the text from the first
         * one will be returned.
         * If there are non-text parts in the response, the concatenation of all text
         * parts will be returned, and a warning will be logged.
         * If there are thought parts in the response, the concatenation of all text
         * parts excluding the thought parts will be returned.
         *
         * @example
         * ```ts
         * const response = await ai.models.generateContent({
         *   model: 'gemini-2.0-flash',
         *   contents:
         *     'Why is the sky blue?',
         * });
         *
         * console.debug(response.text);
         * ```
         */
        get text() {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
            return void 0;
          }
          if (this.candidates && this.candidates.length > 1) {
            console.warn("there are multiple candidates in the response, returning text from the first one.");
          }
          let text = "";
          let anyTextPartText = false;
          const nonTextParts = [];
          for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
            for (const [fieldName, fieldValue] of Object.entries(part)) {
              if (fieldName !== "text" && fieldName !== "thought" && (fieldValue !== null || fieldValue !== void 0)) {
                nonTextParts.push(fieldName);
              }
            }
            if (typeof part.text === "string") {
              if (typeof part.thought === "boolean" && part.thought) {
                continue;
              }
              anyTextPartText = true;
              text += part.text;
            }
          }
          if (nonTextParts.length > 0) {
            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
          }
          return anyTextPartText ? text : void 0;
        }
        /**
         * Returns the concatenation of all inline data parts from the first candidate
         * in the response.
         *
         * @remarks
         * If there are multiple candidates in the response, the inline data from the
         * first one will be returned. If there are non-inline data parts in the
         * response, the concatenation of all inline data parts will be returned, and
         * a warning will be logged.
         */
        get data() {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
            return void 0;
          }
          if (this.candidates && this.candidates.length > 1) {
            console.warn("there are multiple candidates in the response, returning data from the first one.");
          }
          let data = "";
          const nonDataParts = [];
          for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
            for (const [fieldName, fieldValue] of Object.entries(part)) {
              if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== void 0)) {
                nonDataParts.push(fieldName);
              }
            }
            if (part.inlineData && typeof part.inlineData.data === "string") {
              data += atob(part.inlineData.data);
            }
          }
          if (nonDataParts.length > 0) {
            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
          }
          return data.length > 0 ? btoa(data) : void 0;
        }
        /**
         * Returns the function calls from the first candidate in the response.
         *
         * @remarks
         * If there are multiple candidates in the response, the function calls from
         * the first one will be returned.
         * If there are no function calls in the response, undefined will be returned.
         *
         * @example
         * ```ts
         * const controlLightFunctionDeclaration: FunctionDeclaration = {
         *   name: 'controlLight',
         *   parameters: {
         *   type: Type.OBJECT,
         *   description: 'Set the brightness and color temperature of a room light.',
         *   properties: {
         *     brightness: {
         *       type: Type.NUMBER,
         *       description:
         *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
         *     },
         *     colorTemperature: {
         *       type: Type.STRING,
         *       description:
         *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
         *     },
         *   },
         *   required: ['brightness', 'colorTemperature'],
         *  };
         *  const response = await ai.models.generateContent({
         *     model: 'gemini-2.0-flash',
         *     contents: 'Dim the lights so the room feels cozy and warm.',
         *     config: {
         *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
         *       toolConfig: {
         *         functionCallingConfig: {
         *           mode: FunctionCallingConfigMode.ANY,
         *           allowedFunctionNames: ['controlLight'],
         *         },
         *       },
         *     },
         *   });
         *  console.debug(JSON.stringify(response.functionCalls));
         * ```
         */
        get functionCalls() {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
            return void 0;
          }
          if (this.candidates && this.candidates.length > 1) {
            console.warn("there are multiple candidates in the response, returning function calls from the first one.");
          }
          const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
          if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {
            return void 0;
          }
          return functionCalls;
        }
        /**
         * Returns the first executable code from the first candidate in the response.
         *
         * @remarks
         * If there are multiple candidates in the response, the executable code from
         * the first one will be returned.
         * If there are no executable code in the response, undefined will be
         * returned.
         *
         * @example
         * ```ts
         * const response = await ai.models.generateContent({
         *   model: 'gemini-2.0-flash',
         *   contents:
         *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
         *   config: {
         *     tools: [{codeExecution: {}}],
         *   },
         * });
         *
         * console.debug(response.executableCode);
         * ```
         */
        get executableCode() {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j;
          if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
            return void 0;
          }
          if (this.candidates && this.candidates.length > 1) {
            console.warn("there are multiple candidates in the response, returning executable code from the first one.");
          }
          const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode2) => executableCode2 !== void 0);
          if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {
            return void 0;
          }
          return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
        }
        /**
         * Returns the first code execution result from the first candidate in the response.
         *
         * @remarks
         * If there are multiple candidates in the response, the code execution result from
         * the first one will be returned.
         * If there are no code execution result in the response, undefined will be returned.
         *
         * @example
         * ```ts
         * const response = await ai.models.generateContent({
         *   model: 'gemini-2.0-flash',
         *   contents:
         *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
         *   config: {
         *     tools: [{codeExecution: {}}],
         *   },
         * });
         *
         * console.debug(response.codeExecutionResult);
         * ```
         */
        get codeExecutionResult() {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j;
          if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
            return void 0;
          }
          if (this.candidates && this.candidates.length > 1) {
            console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
          }
          const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult2) => codeExecutionResult2 !== void 0);
          if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {
            return void 0;
          }
          return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
        }
      };
      EmbedContentResponse = class {
      };
      GenerateImagesResponse = class {
      };
      EditImageResponse = class {
      };
      UpscaleImageResponse = class {
      };
      ListModelsResponse = class {
      };
      DeleteModelResponse = class {
      };
      CountTokensResponse = class {
      };
      ComputeTokensResponse = class {
      };
      ListTuningJobsResponse = class {
      };
      DeleteCachedContentResponse = class {
      };
      ListCachedContentsResponse = class {
      };
      ListFilesResponse = class {
      };
      HttpResponse = class {
        constructor(response) {
          const headers = {};
          for (const pair of response.headers.entries()) {
            headers[pair[0]] = pair[1];
          }
          this.headers = headers;
          this.responseInternal = response;
        }
        json() {
          return this.responseInternal.json();
        }
      };
      CreateFileResponse = class {
      };
      DeleteFileResponse = class {
      };
      LiveServerMessage = class {
        /**
         * Returns the concatenation of all text parts from the server content if present.
         *
         * @remarks
         * If there are non-text parts in the response, the concatenation of all text
         * parts will be returned, and a warning will be logged.
         */
        get text() {
          var _a, _b, _c;
          let text = "";
          let anyTextPartFound = false;
          const nonTextParts = [];
          for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
            for (const [fieldName, fieldValue] of Object.entries(part)) {
              if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) {
                nonTextParts.push(fieldName);
              }
            }
            if (typeof part.text === "string") {
              if (typeof part.thought === "boolean" && part.thought) {
                continue;
              }
              anyTextPartFound = true;
              text += part.text;
            }
          }
          if (nonTextParts.length > 0) {
            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
          }
          return anyTextPartFound ? text : void 0;
        }
        /**
         * Returns the concatenation of all inline data parts from the server content if present.
         *
         * @remarks
         * If there are non-inline data parts in the
         * response, the concatenation of all inline data parts will be returned, and
         * a warning will be logged.
         */
        get data() {
          var _a, _b, _c;
          let data = "";
          const nonDataParts = [];
          for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
            for (const [fieldName, fieldValue] of Object.entries(part)) {
              if (fieldName !== "inlineData" && fieldValue !== null) {
                nonDataParts.push(fieldName);
              }
            }
            if (part.inlineData && typeof part.inlineData.data === "string") {
              data += atob(part.inlineData.data);
            }
          }
          if (nonDataParts.length > 0) {
            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
          }
          return data.length > 0 ? btoa(data) : void 0;
        }
      };
      LiveMusicServerMessage = class {
        /**
         * Returns the first audio chunk from the server content, if present.
         *
         * @remarks
         * If there are no audio chunks in the response, undefined will be returned.
         */
        get audioChunk() {
          if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {
            return this.serverContent.audioChunks[0];
          }
          return void 0;
        }
      };
      jsonSchemaTypeValidator = external_exports.enum([
        "string",
        "number",
        "integer",
        "object",
        "array",
        "boolean",
        "null"
      ]);
      schemaTypeUnion = external_exports.union([
        jsonSchemaTypeValidator,
        external_exports.array(jsonSchemaTypeValidator)
      ]);
      (function(PagedItem2) {
        PagedItem2["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
        PagedItem2["PAGED_ITEM_MODELS"] = "models";
        PagedItem2["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
        PagedItem2["PAGED_ITEM_FILES"] = "files";
        PagedItem2["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
      })(PagedItem || (PagedItem = {}));
      Pager = class {
        constructor(name, request, response, params) {
          this.pageInternal = [];
          this.paramsInternal = {};
          this.requestInternal = request;
          this.init(name, response, params);
        }
        init(name, response, params) {
          var _a, _b;
          this.nameInternal = name;
          this.pageInternal = response[this.nameInternal] || [];
          this.idxInternal = 0;
          let requestParams = { config: {} };
          if (!params) {
            requestParams = { config: {} };
          } else if (typeof params === "object") {
            requestParams = Object.assign({}, params);
          } else {
            requestParams = params;
          }
          if (requestParams["config"]) {
            requestParams["config"]["pageToken"] = response["nextPageToken"];
          }
          this.paramsInternal = requestParams;
          this.pageInternalSize = (_b = (_a = requestParams["config"]) === null || _a === void 0 ? void 0 : _a["pageSize"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;
        }
        initNextPage(response) {
          this.init(this.nameInternal, response, this.paramsInternal);
        }
        /**
         * Returns the current page, which is a list of items.
         *
         * @remarks
         * The first page is retrieved when the pager is created. The returned list of
         * items could be a subset of the entire list.
         */
        get page() {
          return this.pageInternal;
        }
        /**
         * Returns the type of paged item (for example, ``batch_jobs``).
         */
        get name() {
          return this.nameInternal;
        }
        /**
         * Returns the length of the page fetched each time by this pager.
         *
         * @remarks
         * The number of items in the page is less than or equal to the page length.
         */
        get pageSize() {
          return this.pageInternalSize;
        }
        /**
         * Returns the parameters when making the API request for the next page.
         *
         * @remarks
         * Parameters contain a set of optional configs that can be
         * used to customize the API request. For example, the `pageToken` parameter
         * contains the token to request the next page.
         */
        get params() {
          return this.paramsInternal;
        }
        /**
         * Returns the total number of items in the current page.
         */
        get pageLength() {
          return this.pageInternal.length;
        }
        /**
         * Returns the item at the given index.
         */
        getItem(index) {
          return this.pageInternal[index];
        }
        /**
         * Returns an async iterator that support iterating through all items
         * retrieved from the API.
         *
         * @remarks
         * The iterator will automatically fetch the next page if there are more items
         * to fetch from the API.
         *
         * @example
         *
         * ```ts
         * const pager = await ai.files.list({config: {pageSize: 10}});
         * for await (const file of pager) {
         *   console.log(file.name);
         * }
         * ```
         */
        [Symbol.asyncIterator]() {
          return {
            next: async () => {
              if (this.idxInternal >= this.pageLength) {
                if (this.hasNextPage()) {
                  await this.nextPage();
                } else {
                  return { value: void 0, done: true };
                }
              }
              const item = this.getItem(this.idxInternal);
              this.idxInternal += 1;
              return { value: item, done: false };
            },
            return: async () => {
              return { value: void 0, done: true };
            }
          };
        }
        /**
         * Fetches the next page of items. This makes a new API request.
         *
         * @throws {Error} If there are no more pages to fetch.
         *
         * @example
         *
         * ```ts
         * const pager = await ai.files.list({config: {pageSize: 10}});
         * let page = pager.page;
         * while (true) {
         *   for (const file of page) {
         *     console.log(file.name);
         *   }
         *   if (!pager.hasNextPage()) {
         *     break;
         *   }
         *   page = await pager.nextPage();
         * }
         * ```
         */
        async nextPage() {
          if (!this.hasNextPage()) {
            throw new Error("No more pages to fetch.");
          }
          const response = await this.requestInternal(this.params);
          this.initNextPage(response);
          return this.page;
        }
        /**
         * Returns true if there are more pages to fetch from the API.
         */
        hasNextPage() {
          var _a;
          if (((_a = this.params["config"]) === null || _a === void 0 ? void 0 : _a["pageToken"]) !== void 0) {
            return true;
          }
          return false;
        }
      };
      Caches = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
          this.list = async (params = {}) => {
            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), await this.listInternal(params), params);
          };
        }
        /**
         * Creates a cached contents resource.
         *
         * @remarks
         * Context caching is only supported for specific models. See [Gemini
         * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
         * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
         * for more information.
         *
         * @param params - The parameters for the create request.
         * @return The created cached content.
         *
         * @example
         * ```ts
         * const contents = ...; // Initialize the content to cache.
         * const response = await ai.caches.create({
         *   model: 'gemini-2.0-flash-001',
         *   config: {
         *    'contents': contents,
         *    'displayName': 'test cache',
         *    'systemInstruction': 'What is the sum of the two pdfs?',
         *    'ttl': '86400s',
         *  }
         * });
         * ```
         */
        async create(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = cachedContentFromVertex(this.apiClient, apiResponse);
              return resp;
            });
          } else {
            const body = createCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = cachedContentFromMldev(this.apiClient, apiResponse);
              return resp;
            });
          }
        }
        /**
         * Gets cached content configurations.
         *
         * @param params - The parameters for the get request.
         * @return The cached content.
         *
         * @example
         * ```ts
         * await ai.caches.get({name: '...'}); // The server-generated resource name.
         * ```
         */
        async get(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = cachedContentFromVertex(this.apiClient, apiResponse);
              return resp;
            });
          } else {
            const body = getCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = cachedContentFromMldev(this.apiClient, apiResponse);
              return resp;
            });
          }
        }
        /**
         * Deletes cached content.
         *
         * @param params - The parameters for the delete request.
         * @return The empty response returned by the API.
         *
         * @example
         * ```ts
         * await ai.caches.delete({name: '...'}); // The server-generated resource name.
         * ```
         */
        async delete(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then(() => {
              const resp = deleteCachedContentResponseFromVertex();
              const typedResp = new DeleteCachedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = deleteCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then(() => {
              const resp = deleteCachedContentResponseFromMldev();
              const typedResp = new DeleteCachedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Updates cached content configurations.
         *
         * @param params - The parameters for the update request.
         * @return The updated cached content.
         *
         * @example
         * ```ts
         * const response = await ai.caches.update({
         *   name: '...',  // The server-generated resource name.
         *   config: {'ttl': '7600s'}
         * });
         * ```
         */
        async update(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = updateCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = cachedContentFromVertex(this.apiClient, apiResponse);
              return resp;
            });
          } else {
            const body = updateCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = cachedContentFromMldev(this.apiClient, apiResponse);
              return resp;
            });
          }
        }
        async listInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listCachedContentsParametersToVertex(this.apiClient, params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listCachedContentsResponseFromVertex(this.apiClient, apiResponse);
              const typedResp = new ListCachedContentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listCachedContentsParametersToMldev(this.apiClient, params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listCachedContentsResponseFromMldev(this.apiClient, apiResponse);
              const typedResp = new ListCachedContentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
      };
      Chats = class {
        constructor(modelsModule, apiClient) {
          this.modelsModule = modelsModule;
          this.apiClient = apiClient;
        }
        /**
         * Creates a new chat session.
         *
         * @remarks
         * The config in the params will be used for all requests within the chat
         * session unless overridden by a per-request `config` in
         * @see {@link types.SendMessageParameters#config}.
         *
         * @param params - Parameters for creating a chat session.
         * @returns A new chat session.
         *
         * @example
         * ```ts
         * const chat = ai.chats.create({
         *   model: 'gemini-2.0-flash'
         *   config: {
         *     temperature: 0.5,
         *     maxOutputTokens: 1024,
         *   }
         * });
         * ```
         */
        create(params) {
          return new Chat(
            this.apiClient,
            this.modelsModule,
            params.model,
            params.config,
            // Deep copy the history to avoid mutating the history outside of the
            // chat session.
            structuredClone(params.history)
          );
        }
      };
      Chat = class {
        constructor(apiClient, modelsModule, model, config = {}, history = []) {
          this.apiClient = apiClient;
          this.modelsModule = modelsModule;
          this.model = model;
          this.config = config;
          this.history = history;
          this.sendPromise = Promise.resolve();
          validateHistory(history);
        }
        /**
         * Sends a message to the model and returns the response.
         *
         * @remarks
         * This method will wait for the previous message to be processed before
         * sending the next message.
         *
         * @see {@link Chat#sendMessageStream} for streaming method.
         * @param params - parameters for sending messages within a chat session.
         * @returns The model's response.
         *
         * @example
         * ```ts
         * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
         * const response = await chat.sendMessage({
         *   message: 'Why is the sky blue?'
         * });
         * console.log(response.text);
         * ```
         */
        async sendMessage(params) {
          var _a;
          await this.sendPromise;
          const inputContent = tContent(this.apiClient, params.message);
          const responsePromise = this.modelsModule.generateContent({
            model: this.model,
            contents: this.getHistory(true).concat(inputContent),
            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
          });
          this.sendPromise = (async () => {
            var _a2, _b, _c;
            const response = await responsePromise;
            const outputContent = (_b = (_a2 = response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content;
            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
            const index = this.getHistory(true).length;
            let automaticFunctionCallingHistory = [];
            if (fullAutomaticFunctionCallingHistory != null) {
              automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];
            }
            const modelOutput = outputContent ? [outputContent] : [];
            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
            return;
          })();
          await this.sendPromise.catch(() => {
            this.sendPromise = Promise.resolve();
          });
          return responsePromise;
        }
        /**
         * Sends a message to the model and returns the response in chunks.
         *
         * @remarks
         * This method will wait for the previous message to be processed before
         * sending the next message.
         *
         * @see {@link Chat#sendMessage} for non-streaming method.
         * @param params - parameters for sending the message.
         * @return The model's response.
         *
         * @example
         * ```ts
         * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
         * const response = await chat.sendMessageStream({
         *   message: 'Why is the sky blue?'
         * });
         * for await (const chunk of response) {
         *   console.log(chunk.text);
         * }
         * ```
         */
        async sendMessageStream(params) {
          var _a;
          await this.sendPromise;
          const inputContent = tContent(this.apiClient, params.message);
          const streamResponse = this.modelsModule.generateContentStream({
            model: this.model,
            contents: this.getHistory(true).concat(inputContent),
            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
          });
          this.sendPromise = streamResponse.then(() => void 0).catch(() => void 0);
          const response = await streamResponse;
          const result = this.processStreamResponse(response, inputContent);
          return result;
        }
        /**
         * Returns the chat history.
         *
         * @remarks
         * The history is a list of contents alternating between user and model.
         *
         * There are two types of history:
         * - The `curated history` contains only the valid turns between user and
         * model, which will be included in the subsequent requests sent to the model.
         * - The `comprehensive history` contains all turns, including invalid or
         *   empty model outputs, providing a complete record of the history.
         *
         * The history is updated after receiving the response from the model,
         * for streaming response, it means receiving the last chunk of the response.
         *
         * The `comprehensive history` is returned by default. To get the `curated
         * history`, set the `curated` parameter to `true`.
         *
         * @param curated - whether to return the curated history or the comprehensive
         *     history.
         * @return History contents alternating between user and model for the entire
         *     chat session.
         */
        getHistory(curated = false) {
          const history = curated ? extractCuratedHistory(this.history) : this.history;
          return structuredClone(history);
        }
        processStreamResponse(streamResponse, inputContent) {
          var _a, _b;
          return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
            var _c, e_1, _d, _e;
            const outputContent = [];
            try {
              for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {
                _e = streamResponse_1_1.value;
                _f = false;
                const chunk = _e;
                if (isValidResponse(chunk)) {
                  const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;
                  if (content !== void 0) {
                    outputContent.push(content);
                  }
                }
                yield yield __await(chunk);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            this.recordHistory(inputContent, outputContent);
          });
        }
        recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
          let outputContents = [];
          if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== void 0)) {
            outputContents = modelOutput;
          } else {
            outputContents.push({
              role: "model",
              parts: []
            });
          }
          if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {
            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
          } else {
            this.history.push(userInput);
          }
          this.history.push(...outputContents);
        }
      };
      Files = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
          this.list = async (params = {}) => {
            return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), await this.listInternal(params), params);
          };
        }
        /**
         * Uploads a file asynchronously to the Gemini API.
         * This method is not available in Vertex AI.
         * Supported upload sources:
         * - Node.js: File path (string) or Blob object.
         * - Browser: Blob object (e.g., File).
         *
         * @remarks
         * The `mimeType` can be specified in the `config` parameter. If omitted:
         *  - For file path (string) inputs, the `mimeType` will be inferred from the
         *     file extension.
         *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
         *     property.
         * Somex eamples for file extension to mimeType mapping:
         * .txt -> text/plain
         * .json -> application/json
         * .jpg  -> image/jpeg
         * .png -> image/png
         * .mp3 -> audio/mpeg
         * .mp4 -> video/mp4
         *
         * This section can contain multiple paragraphs and code examples.
         *
         * @param params - Optional parameters specified in the
         *        `types.UploadFileParameters` interface.
         *         @see {@link types.UploadFileParameters#config} for the optional
         *         config in the parameters.
         * @return A promise that resolves to a `types.File` object.
         * @throws An error if called on a Vertex AI client.
         * @throws An error if the `mimeType` is not provided and can not be inferred,
         * the `mimeType` can be provided in the `params.config` parameter.
         * @throws An error occurs if a suitable upload location cannot be established.
         *
         * @example
         * The following code uploads a file to Gemini API.
         *
         * ```ts
         * const file = await ai.files.upload({file: 'file.txt', config: {
         *   mimeType: 'text/plain',
         * }});
         * console.log(file.name);
         * ```
         */
        async upload(params) {
          if (this.apiClient.isVertexAI()) {
            throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
          }
          return this.apiClient.uploadFile(params.file, params.config).then((response) => {
            const file = fileFromMldev(this.apiClient, response);
            return file;
          });
        }
        /**
         * Downloads a remotely stored file asynchronously to a location specified in
         * the `params` object. This method only works on Node environment, to
         * download files in the browser, use a browser compliant method like an <a>
         * tag.
         *
         * @param params - The parameters for the download request.
         *
         * @example
         * The following code downloads an example file named "files/mehozpxf877d" as
         * "file.txt".
         *
         * ```ts
         * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
         * ```
         */
        async download(params) {
          await this.apiClient.downloadFile(params);
        }
        async listInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = listFilesParametersToMldev(this.apiClient, params);
            path = formatMap("files", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listFilesResponseFromMldev(this.apiClient, apiResponse);
              const typedResp = new ListFilesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        async createInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createFileParametersToMldev(this.apiClient, params);
            path = formatMap("upload/v1beta/files", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then(() => {
              const resp = createFileResponseFromMldev();
              const typedResp = new CreateFileResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Retrieves the file information from the service.
         *
         * @param params - The parameters for the get request
         * @return The Promise that resolves to the types.File object requested.
         *
         * @example
         * ```ts
         * const config: GetFileParameters = {
         *   name: fileName,
         * };
         * file = await ai.files.get(config);
         * console.log(file.name);
         * ```
         */
        async get(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = getFileParametersToMldev(this.apiClient, params);
            path = formatMap("files/{file}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = fileFromMldev(this.apiClient, apiResponse);
              return resp;
            });
          }
        }
        /**
         * Deletes a remotely stored file.
         *
         * @param params - The parameters for the delete request.
         * @return The DeleteFileResponse, the response for the delete method.
         *
         * @example
         * The following code deletes an example file named "files/mehozpxf877d".
         *
         * ```ts
         * await ai.files.delete({name: file.name});
         * ```
         */
        async delete(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = deleteFileParametersToMldev(this.apiClient, params);
            path = formatMap("files/{file}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then(() => {
              const resp = deleteFileResponseFromMldev();
              const typedResp = new DeleteFileResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
      };
      CONTENT_TYPE_HEADER = "Content-Type";
      SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
      USER_AGENT_HEADER = "User-Agent";
      GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
      SDK_VERSION = "1.2.0";
      LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
      VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
      GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
      responseLineRE = /^data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
      ClientError = class extends Error {
        constructor(message, stackTrace) {
          if (stackTrace) {
            super(message, { cause: stackTrace });
          } else {
            super(message, { cause: new Error().stack });
          }
          this.message = message;
          this.name = "ClientError";
        }
      };
      ServerError = class extends Error {
        constructor(message, stackTrace) {
          if (stackTrace) {
            super(message, { cause: stackTrace });
          } else {
            super(message, { cause: new Error().stack });
          }
          this.message = message;
          this.name = "ServerError";
        }
      };
      ApiClient = class {
        constructor(opts) {
          var _a, _b;
          this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });
          const initHttpOptions = {};
          if (this.clientOptions.vertexai) {
            initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;
            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();
            this.normalizeAuthParameters();
          } else {
            initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;
            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
          }
          initHttpOptions.headers = this.getDefaultHeaders();
          this.clientOptions.httpOptions = initHttpOptions;
          if (opts.httpOptions) {
            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
          }
        }
        /**
         * Determines the base URL for Vertex AI based on project and location.
         * Uses the global endpoint if location is 'global' or if project/location
         * are not specified (implying API key usage).
         * @private
         */
        baseUrlFromProjectLocation() {
          if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global") {
            return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
          }
          return `https://aiplatform.googleapis.com/`;
        }
        /**
         * Normalizes authentication parameters for Vertex AI.
         * If project and location are provided, API key is cleared.
         * If project and location are not provided (implying API key usage),
         * project and location are cleared.
         * @private
         */
        normalizeAuthParameters() {
          if (this.clientOptions.project && this.clientOptions.location) {
            this.clientOptions.apiKey = void 0;
            return;
          }
          this.clientOptions.project = void 0;
          this.clientOptions.location = void 0;
        }
        isVertexAI() {
          var _a;
          return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;
        }
        getProject() {
          return this.clientOptions.project;
        }
        getLocation() {
          return this.clientOptions.location;
        }
        getApiVersion() {
          if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) {
            return this.clientOptions.httpOptions.apiVersion;
          }
          throw new Error("API version is not set.");
        }
        getBaseUrl() {
          if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) {
            return this.clientOptions.httpOptions.baseUrl;
          }
          throw new Error("Base URL is not set.");
        }
        getRequestUrl() {
          return this.getRequestUrlInternal(this.clientOptions.httpOptions);
        }
        getHeaders() {
          if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) {
            return this.clientOptions.httpOptions.headers;
          } else {
            throw new Error("Headers are not set.");
          }
        }
        getRequestUrlInternal(httpOptions) {
          if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) {
            throw new Error("HTTP options are not correctly set.");
          }
          const baseUrl = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
          const urlElement = [baseUrl];
          if (httpOptions.apiVersion && httpOptions.apiVersion !== "") {
            urlElement.push(httpOptions.apiVersion);
          }
          return urlElement.join("/");
        }
        getBaseResourcePath() {
          return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
        }
        getApiKey() {
          return this.clientOptions.apiKey;
        }
        getWebsocketBaseUrl() {
          const baseUrl = this.getBaseUrl();
          const urlParts = new URL(baseUrl);
          urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
          return urlParts.toString();
        }
        setBaseUrl(url) {
          if (this.clientOptions.httpOptions) {
            this.clientOptions.httpOptions.baseUrl = url;
          } else {
            throw new Error("HTTP options are not correctly set.");
          }
        }
        constructUrl(path, httpOptions, prependProjectLocation) {
          const urlElement = [this.getRequestUrlInternal(httpOptions)];
          if (prependProjectLocation) {
            urlElement.push(this.getBaseResourcePath());
          }
          if (path !== "") {
            urlElement.push(path);
          }
          const url = new URL(`${urlElement.join("/")}`);
          return url;
        }
        shouldPrependVertexProjectPath(request) {
          if (this.clientOptions.apiKey) {
            return false;
          }
          if (!this.clientOptions.vertexai) {
            return false;
          }
          if (request.path.startsWith("projects/")) {
            return false;
          }
          if (request.httpMethod === "GET" && request.path.startsWith("publishers/google/models")) {
            return false;
          }
          return true;
        }
        async request(request) {
          let patchedHttpOptions = this.clientOptions.httpOptions;
          if (request.httpOptions) {
            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
          }
          const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
          const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
          if (request.queryParams) {
            for (const [key, value] of Object.entries(request.queryParams)) {
              url.searchParams.append(key, String(value));
            }
          }
          let requestInit = {};
          if (request.httpMethod === "GET") {
            if (request.body && request.body !== "{}") {
              throw new Error("Request body should be empty for GET request, but got non empty request body");
            }
          } else {
            requestInit.body = request.body;
          }
          requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);
          return this.unaryApiCall(url, requestInit, request.httpMethod);
        }
        patchHttpOptions(baseHttpOptions, requestHttpOptions) {
          const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
          for (const [key, value] of Object.entries(requestHttpOptions)) {
            if (typeof value === "object") {
              patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
            } else if (value !== void 0) {
              patchedHttpOptions[key] = value;
            }
          }
          return patchedHttpOptions;
        }
        async requestStream(request) {
          let patchedHttpOptions = this.clientOptions.httpOptions;
          if (request.httpOptions) {
            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
          }
          const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
          const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
          if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") {
            url.searchParams.set("alt", "sse");
          }
          let requestInit = {};
          requestInit.body = request.body;
          requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);
          return this.streamApiCall(url, requestInit, request.httpMethod);
        }
        async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, abortSignal) {
          if (httpOptions && httpOptions.timeout || abortSignal) {
            const abortController = new AbortController();
            const signal = abortController.signal;
            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {
              setTimeout(() => abortController.abort(), httpOptions.timeout);
            }
            if (abortSignal) {
              abortSignal.addEventListener("abort", () => {
                abortController.abort();
              });
            }
            requestInit.signal = signal;
          }
          requestInit.headers = await this.getHeadersInternal(httpOptions);
          return requestInit;
        }
        async unaryApiCall(url, requestInit, httpMethod) {
          return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
            await throwErrorIfNotOK(response);
            return new HttpResponse(response);
          }).catch((e) => {
            if (e instanceof Error) {
              throw e;
            } else {
              throw new Error(JSON.stringify(e));
            }
          });
        }
        async streamApiCall(url, requestInit, httpMethod) {
          return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
            await throwErrorIfNotOK(response);
            return this.processStreamResponse(response);
          }).catch((e) => {
            if (e instanceof Error) {
              throw e;
            } else {
              throw new Error(JSON.stringify(e));
            }
          });
        }
        processStreamResponse(response) {
          var _a;
          return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();
            const decoder = new TextDecoder("utf-8");
            if (!reader) {
              throw new Error("Response body is empty");
            }
            try {
              let buffer = "";
              while (true) {
                const { done, value } = yield __await(reader.read());
                if (done) {
                  if (buffer.trim().length > 0) {
                    throw new Error("Incomplete JSON segment at the end");
                  }
                  break;
                }
                const chunkString = decoder.decode(value);
                try {
                  const chunkJson = JSON.parse(chunkString);
                  if ("error" in chunkJson) {
                    const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
                    const status = errorJson["status"];
                    const code = errorJson["code"];
                    const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
                    if (code >= 400 && code < 500) {
                      const clientError = new ClientError(errorMessage);
                      throw clientError;
                    } else if (code >= 500 && code < 600) {
                      const serverError = new ServerError(errorMessage);
                      throw serverError;
                    }
                  }
                } catch (e) {
                  const error = e;
                  if (error.name === "ClientError" || error.name === "ServerError") {
                    throw e;
                  }
                }
                buffer += chunkString;
                let match = buffer.match(responseLineRE);
                while (match) {
                  const processedChunkString = match[1];
                  try {
                    const partialResponse = new Response(processedChunkString, {
                      headers: response === null || response === void 0 ? void 0 : response.headers,
                      status: response === null || response === void 0 ? void 0 : response.status,
                      statusText: response === null || response === void 0 ? void 0 : response.statusText
                    });
                    yield yield __await(new HttpResponse(partialResponse));
                    buffer = buffer.slice(match[0].length);
                    match = buffer.match(responseLineRE);
                  } catch (e) {
                    throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);
                  }
                }
              }
            } finally {
              reader.releaseLock();
            }
          });
        }
        async apiCall(url, requestInit) {
          return fetch(url, requestInit).catch((e) => {
            throw new Error(`exception ${e} sending request`);
          });
        }
        getDefaultHeaders() {
          const headers = {};
          const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
          headers[USER_AGENT_HEADER] = versionHeaderValue;
          headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
          headers[CONTENT_TYPE_HEADER] = "application/json";
          return headers;
        }
        async getHeadersInternal(httpOptions) {
          const headers = new Headers();
          if (httpOptions && httpOptions.headers) {
            for (const [key, value] of Object.entries(httpOptions.headers)) {
              headers.append(key, value);
            }
            if (httpOptions.timeout && httpOptions.timeout > 0) {
              headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
            }
          }
          await this.clientOptions.auth.addAuthHeaders(headers);
          return headers;
        }
        /**
         * Uploads a file asynchronously using Gemini API only, this is not supported
         * in Vertex AI.
         *
         * @param file The string path to the file to be uploaded or a Blob object.
         * @param config Optional parameters specified in the `UploadFileConfig`
         *     interface. @see {@link UploadFileConfig}
         * @return A promise that resolves to a `File` object.
         * @throws An error if called on a Vertex AI client.
         * @throws An error if the `mimeType` is not provided and can not be inferred,
         */
        async uploadFile(file, config) {
          var _a;
          const fileToUpload = {};
          if (config != null) {
            fileToUpload.mimeType = config.mimeType;
            fileToUpload.name = config.name;
            fileToUpload.displayName = config.displayName;
          }
          if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) {
            fileToUpload.name = `files/${fileToUpload.name}`;
          }
          const uploader = this.clientOptions.uploader;
          const fileStat = await uploader.stat(file);
          fileToUpload.sizeBytes = String(fileStat.size);
          const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;
          if (mimeType === void 0 || mimeType === "") {
            throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
          }
          fileToUpload.mimeType = mimeType;
          const uploadUrl = await this.fetchUploadUrl(fileToUpload, config);
          return uploader.upload(file, uploadUrl, this);
        }
        /**
         * Downloads a file asynchronously to the specified path.
         *
         * @params params - The parameters for the download request, see {@link
         * DownloadFileParameters}
         */
        async downloadFile(params) {
          const downloader = this.clientOptions.downloader;
          await downloader.download(params, this);
        }
        async fetchUploadUrl(file, config) {
          var _a;
          let httpOptions = {};
          if (config === null || config === void 0 ? void 0 : config.httpOptions) {
            httpOptions = config.httpOptions;
          } else {
            httpOptions = {
              apiVersion: "",
              headers: {
                "Content-Type": "application/json",
                "X-Goog-Upload-Protocol": "resumable",
                "X-Goog-Upload-Command": "start",
                "X-Goog-Upload-Header-Content-Length": `${file.sizeBytes}`,
                "X-Goog-Upload-Header-Content-Type": `${file.mimeType}`
              }
            };
          }
          const body = {
            "file": file
          };
          const httpResponse = await this.request({
            path: formatMap("upload/v1beta/files", body["_url"]),
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions
          });
          if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {
            throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
          }
          const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a["x-goog-upload-url"];
          if (uploadUrl === void 0) {
            throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
          }
          return uploadUrl;
        }
      };
      MCP_LABEL = "mcp_used/unknown";
      LiveMusic = class {
        constructor(apiClient, auth, webSocketFactory) {
          this.apiClient = apiClient;
          this.auth = auth;
          this.webSocketFactory = webSocketFactory;
        }
        /**
             Establishes a connection to the specified model and returns a
             LiveMusicSession object representing that connection.
        
             @experimental
        
             @remarks
        
             @param params - The parameters for establishing a connection to the model.
             @return A live session.
        
             @example
             ```ts
             let model = 'models/lyria-realtime-exp';
             const session = await ai.live.music.connect({
               model: model,
               callbacks: {
                 onmessage: (e: MessageEvent) => {
                   console.log('Received message from the server: %s\n', debug(e.data));
                 },
                 onerror: (e: ErrorEvent) => {
                   console.log('Error occurred: %s\n', debug(e.error));
                 },
                 onclose: (e: CloseEvent) => {
                   console.log('Connection closed.');
                 },
               },
             });
             ```
            */
        async connect(params) {
          var _a, _b;
          if (this.apiClient.isVertexAI()) {
            throw new Error("Live music is not supported for Vertex AI.");
          }
          console.warn("Live music generation is experimental and may change in future versions.");
          const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
          const apiVersion = this.apiClient.getApiVersion();
          const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
          const apiKey = this.apiClient.getApiKey();
          const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;
          let onopenResolve = () => {
          };
          const onopenPromise = new Promise((resolve) => {
            onopenResolve = resolve;
          });
          const callbacks = params.callbacks;
          const onopenAwaitedCallback = function() {
            onopenResolve({});
          };
          const apiClient = this.apiClient;
          const websocketCallbacks = {
            onopen: onopenAwaitedCallback,
            onmessage: (event) => {
              void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
            },
            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
            },
            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
            }
          };
          const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
          conn.connect();
          await onopenPromise;
          const model = tModel(this.apiClient, params.model);
          const setup = liveMusicClientSetupToMldev(this.apiClient, {
            model
          });
          const clientMessage = liveMusicClientMessageToMldev(this.apiClient, { setup });
          conn.send(JSON.stringify(clientMessage));
          return new LiveMusicSession(conn, this.apiClient);
        }
      };
      LiveMusicSession = class {
        constructor(conn, apiClient) {
          this.conn = conn;
          this.apiClient = apiClient;
        }
        /**
            Sets inputs to steer music generation. Updates the session's current
            weighted prompts.
        
            @param params - Contains one property, `weightedPrompts`.
        
              - `weightedPrompts` to send to the model; weights are normalized to
                sum to 1.0.
        
            @experimental
           */
        async setWeightedPrompts(params) {
          if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {
            throw new Error("Weighted prompts must be set and contain at least one entry.");
          }
          const setWeightedPromptsParameters = liveMusicSetWeightedPromptsParametersToMldev(this.apiClient, params);
          const clientContent = liveMusicClientContentToMldev(this.apiClient, setWeightedPromptsParameters);
          this.conn.send(JSON.stringify({ clientContent }));
        }
        /**
            Sets a configuration to the model. Updates the session's current
            music generation config.
        
            @param params - Contains one property, `musicGenerationConfig`.
        
              - `musicGenerationConfig` to set in the model. Passing an empty or
            undefined config to the model will reset the config to defaults.
        
            @experimental
           */
        async setMusicGenerationConfig(params) {
          if (!params.musicGenerationConfig) {
            params.musicGenerationConfig = {};
          }
          const setConfigParameters = liveMusicSetConfigParametersToMldev(this.apiClient, params);
          const clientMessage = liveMusicClientMessageToMldev(this.apiClient, setConfigParameters);
          this.conn.send(JSON.stringify(clientMessage));
        }
        sendPlaybackControl(playbackControl) {
          const clientMessage = liveMusicClientMessageToMldev(this.apiClient, {
            playbackControl
          });
          this.conn.send(JSON.stringify(clientMessage));
        }
        /**
         * Start the music stream.
         *
         * @experimental
         */
        play() {
          this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
        }
        /**
         * Temporarily halt the music stream. Use `play` to resume from the current
         * position.
         *
         * @experimental
         */
        pause() {
          this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
        }
        /**
         * Stop the music stream and reset the state. Retains the current prompts
         * and config.
         *
         * @experimental
         */
        stop() {
          this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
        }
        /**
         * Resets the context of the music generation without stopping it.
         * Retains the current prompts and config.
         *
         * @experimental
         */
        resetContext() {
          this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
        }
        /**
             Terminates the WebSocket connection.
        
             @experimental
           */
        close() {
          this.conn.close();
        }
      };
      FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
      Live = class {
        constructor(apiClient, auth, webSocketFactory) {
          this.apiClient = apiClient;
          this.auth = auth;
          this.webSocketFactory = webSocketFactory;
          this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
        }
        /**
             Establishes a connection to the specified model with the given
             configuration and returns a Session object representing that connection.
        
             @experimental Built-in MCP support is an experimental feature, may change in
             future versions.
        
             @remarks
        
             @param params - The parameters for establishing a connection to the model.
             @return A live session.
        
             @example
             ```ts
             let model: string;
             if (GOOGLE_GENAI_USE_VERTEXAI) {
               model = 'gemini-2.0-flash-live-preview-04-09';
             } else {
               model = 'gemini-2.0-flash-live-001';
             }
             const session = await ai.live.connect({
               model: model,
               config: {
                 responseModalities: [Modality.AUDIO],
               },
               callbacks: {
                 onopen: () => {
                   console.log('Connected to the socket.');
                 },
                 onmessage: (e: MessageEvent) => {
                   console.log('Received message from the server: %s\n', debug(e.data));
                 },
                 onerror: (e: ErrorEvent) => {
                   console.log('Error occurred: %s\n', debug(e.error));
                 },
                 onclose: (e: CloseEvent) => {
                   console.log('Connection closed.');
                 },
               },
             });
             ```
            */
        async connect(params) {
          var _a, _b, _c, _d, _e, _f;
          const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
          const apiVersion = this.apiClient.getApiVersion();
          let url;
          const defaultHeaders = this.apiClient.getDefaultHeaders();
          if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
            setMcpUsageHeader(defaultHeaders);
          }
          const headers = mapToHeaders(defaultHeaders);
          if (this.apiClient.isVertexAI()) {
            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
            await this.auth.addAuthHeaders(headers);
          } else {
            const apiKey = this.apiClient.getApiKey();
            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateContent?key=${apiKey}`;
          }
          let onopenResolve = () => {
          };
          const onopenPromise = new Promise((resolve) => {
            onopenResolve = resolve;
          });
          const callbacks = params.callbacks;
          const onopenAwaitedCallback = function() {
            var _a2;
            (_a2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a2 === void 0 ? void 0 : _a2.call(callbacks);
            onopenResolve({});
          };
          const apiClient = this.apiClient;
          const websocketCallbacks = {
            onopen: onopenAwaitedCallback,
            onmessage: (event) => {
              void handleWebSocketMessage(apiClient, callbacks.onmessage, event);
            },
            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
            },
            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
            }
          };
          const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
          conn.connect();
          await onopenPromise;
          let transformedModel = tModel(this.apiClient, params.model);
          if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
            const project = this.apiClient.getProject();
            const location = this.apiClient.getLocation();
            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;
          }
          let clientMessage = {};
          if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === void 0) {
            if (params.config === void 0) {
              params.config = { responseModalities: [Modality.AUDIO] };
            } else {
              params.config.responseModalities = [Modality.AUDIO];
            }
          }
          if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {
            console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
          }
          const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];
          const convertedTools = [];
          for (const tool of inputTools) {
            if (this.isCallableTool(tool)) {
              const callableTool = tool;
              convertedTools.push(await callableTool.tool());
            } else {
              convertedTools.push(tool);
            }
          }
          if (convertedTools.length > 0) {
            params.config.tools = convertedTools;
          }
          const liveConnectParameters = {
            model: transformedModel,
            config: params.config,
            callbacks: params.callbacks
          };
          if (this.apiClient.isVertexAI()) {
            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
          } else {
            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
          }
          delete clientMessage["config"];
          conn.send(JSON.stringify(clientMessage));
          return new Session(conn, this.apiClient);
        }
        // TODO: b/416041229 - Abstract this method to a common place.
        isCallableTool(tool) {
          return "callTool" in tool && typeof tool.callTool === "function";
        }
      };
      defaultLiveSendClientContentParamerters = {
        turnComplete: true
      };
      Session = class {
        constructor(conn, apiClient) {
          this.conn = conn;
          this.apiClient = apiClient;
        }
        tLiveClientContent(apiClient, params) {
          if (params.turns !== null && params.turns !== void 0) {
            let contents = [];
            try {
              contents = tContents(apiClient, params.turns);
              if (apiClient.isVertexAI()) {
                contents = contents.map((item) => contentToVertex(apiClient, item));
              } else {
                contents = contents.map((item) => contentToMldev(apiClient, item));
              }
            } catch (_a) {
              throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
            }
            return {
              clientContent: { turns: contents, turnComplete: params.turnComplete }
            };
          }
          return {
            clientContent: { turnComplete: params.turnComplete }
          };
        }
        tLiveClienttToolResponse(apiClient, params) {
          let functionResponses = [];
          if (params.functionResponses == null) {
            throw new Error("functionResponses is required.");
          }
          if (!Array.isArray(params.functionResponses)) {
            functionResponses = [params.functionResponses];
          } else {
            functionResponses = params.functionResponses;
          }
          if (functionResponses.length === 0) {
            throw new Error("functionResponses is required.");
          }
          for (const functionResponse of functionResponses) {
            if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) {
              throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
            }
            if (!apiClient.isVertexAI() && !("id" in functionResponse)) {
              throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
            }
          }
          const clientMessage = {
            toolResponse: { functionResponses }
          };
          return clientMessage;
        }
        /**
            Send a message over the established connection.
        
            @param params - Contains two **optional** properties, `turns` and
                `turnComplete`.
        
              - `turns` will be converted to a `Content[]`
              - `turnComplete: true` [default] indicates that you are done sending
                content and expect a response. If `turnComplete: false`, the server
                will wait for additional messages before starting generation.
        
            @experimental
        
            @remarks
            There are two ways to send messages to the live API:
            `sendClientContent` and `sendRealtimeInput`.
        
            `sendClientContent` messages are added to the model context **in order**.
            Having a conversation using `sendClientContent` messages is roughly
            equivalent to using the `Chat.sendMessageStream`, except that the state of
            the `chat` history is stored on the API server instead of locally.
        
            Because of `sendClientContent`'s order guarantee, the model cannot respons
            as quickly to `sendClientContent` messages as to `sendRealtimeInput`
            messages. This makes the biggest difference when sending objects that have
            significant preprocessing time (typically images).
        
            The `sendClientContent` message sends a `Content[]`
            which has more options than the `Blob` sent by `sendRealtimeInput`.
        
            So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
        
            - Sending anything that can't be represented as a `Blob` (text,
            `sendClientContent({turns="Hello?"}`)).
            - Managing turns when not using audio input and voice activity detection.
              (`sendClientContent({turnComplete:true})` or the short form
            `sendClientContent()`)
            - Prefilling a conversation context
              ```
              sendClientContent({
                  turns: [
                    Content({role:user, parts:...}),
                    Content({role:user, parts:...}),
                    ...
                  ]
              })
              ```
            @experimental
           */
        sendClientContent(params) {
          params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
          const clientMessage = this.tLiveClientContent(this.apiClient, params);
          this.conn.send(JSON.stringify(clientMessage));
        }
        /**
            Send a realtime message over the established connection.
        
            @param params - Contains one property, `media`.
        
              - `media` will be converted to a `Blob`
        
            @experimental
        
            @remarks
            Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
        
            With `sendRealtimeInput` the api will respond to audio automatically
            based on voice activity detection (VAD).
        
            `sendRealtimeInput` is optimized for responsivness at the expense of
            deterministic ordering guarantees. Audio and video tokens are to the
            context when they become available.
        
            Note: The Call signature expects a `Blob` object, but only a subset
            of audio and image mimetypes are allowed.
           */
        sendRealtimeInput(params) {
          let clientMessage = {};
          if (this.apiClient.isVertexAI()) {
            clientMessage = {
              "realtimeInput": liveSendRealtimeInputParametersToVertex(this.apiClient, params)
            };
          } else {
            clientMessage = {
              "realtimeInput": liveSendRealtimeInputParametersToMldev(this.apiClient, params)
            };
          }
          this.conn.send(JSON.stringify(clientMessage));
        }
        /**
            Send a function response message over the established connection.
        
            @param params - Contains property `functionResponses`.
        
              - `functionResponses` will be converted to a `functionResponses[]`
        
            @remarks
            Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
        
            Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
        
            @experimental
           */
        sendToolResponse(params) {
          if (params.functionResponses == null) {
            throw new Error("Tool response parameters are required.");
          }
          const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
          this.conn.send(JSON.stringify(clientMessage));
        }
        /**
             Terminates the WebSocket connection.
        
             @experimental
        
             @example
             ```ts
             let model: string;
             if (GOOGLE_GENAI_USE_VERTEXAI) {
               model = 'gemini-2.0-flash-live-preview-04-09';
             } else {
               model = 'gemini-2.0-flash-live-001';
             }
             const session = await ai.live.connect({
               model: model,
               config: {
                 responseModalities: [Modality.AUDIO],
               }
             });
        
             session.close();
             ```
           */
        close() {
          this.conn.close();
        }
      };
      DEFAULT_MAX_REMOTE_CALLS = 10;
      Models = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
          this.generateContent = async (params) => {
            var _a, _b, _c, _d, _e;
            const transformedParams = await this.processParamsForMcpUsage(params);
            if (!hasMcpClientTools(params) || shouldDisableAfc(params.config)) {
              return await this.generateContentInternal(transformedParams);
            }
            if (hasNonMcpTools(params)) {
              throw new Error("Automatic function calling with CallableTools and Tools is not yet supported.");
            }
            let response;
            let functionResponseContent;
            const automaticFunctionCallingHistory = tContents(this.apiClient, transformedParams.contents);
            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
            let remoteCalls = 0;
            while (remoteCalls < maxRemoteCalls) {
              response = await this.generateContentInternal(transformedParams);
              if (!response.functionCalls || response.functionCalls.length === 0) {
                break;
              }
              const responseContent = response.candidates[0].content;
              const functionResponseParts = [];
              for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {
                if (isCallableTool(tool)) {
                  const callableTool = tool;
                  const parts = await callableTool.callTool(response.functionCalls);
                  functionResponseParts.push(...parts);
                }
              }
              remoteCalls++;
              functionResponseContent = {
                role: "user",
                parts: functionResponseParts
              };
              transformedParams.contents = tContents(this.apiClient, transformedParams.contents);
              transformedParams.contents.push(responseContent);
              transformedParams.contents.push(functionResponseContent);
              if (shouldAppendAfcHistory(transformedParams.config)) {
                automaticFunctionCallingHistory.push(responseContent);
                automaticFunctionCallingHistory.push(functionResponseContent);
              }
            }
            if (shouldAppendAfcHistory(transformedParams.config)) {
              response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
            }
            return response;
          };
          this.generateContentStream = async (params) => {
            if (shouldDisableAfc(params.config)) {
              const transformedParams = await this.processParamsForMcpUsage(params);
              return await this.generateContentStreamInternal(transformedParams);
            } else {
              return await this.processAfcStream(params);
            }
          };
          this.generateImages = async (params) => {
            return await this.generateImagesInternal(params).then((apiResponse) => {
              var _a;
              let positivePromptSafetyAttributes;
              const generatedImages = [];
              if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {
                for (const generatedImage of apiResponse.generatedImages) {
                  if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === "Positive Prompt") {
                    positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
                  } else {
                    generatedImages.push(generatedImage);
                  }
                }
              }
              let response;
              if (positivePromptSafetyAttributes) {
                response = {
                  generatedImages,
                  positivePromptSafetyAttributes
                };
              } else {
                response = {
                  generatedImages
                };
              }
              return response;
            });
          };
          this.list = async (params) => {
            var _a;
            const defaultConfig = {
              queryBase: true
            };
            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);
            const actualParams = {
              config: actualConfig
            };
            if (this.apiClient.isVertexAI()) {
              if (!actualParams.config.queryBase) {
                if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {
                  throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
                } else {
                  actualParams.config.filter = "labels.tune-type:*";
                }
              }
            }
            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), await this.listInternal(actualParams), actualParams);
          };
          this.editImage = async (params) => {
            const paramsInternal = {
              model: params.model,
              prompt: params.prompt,
              referenceImages: [],
              config: params.config
            };
            if (params.referenceImages) {
              if (params.referenceImages) {
                paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
              }
            }
            return await this.editImageInternal(paramsInternal);
          };
          this.upscaleImage = async (params) => {
            let apiConfig = {
              numberOfImages: 1,
              mode: "upscale"
            };
            if (params.config) {
              apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
            }
            const apiParams = {
              model: params.model,
              image: params.image,
              upscaleFactor: params.upscaleFactor,
              config: apiConfig
            };
            return await this.upscaleImageInternal(apiParams);
          };
        }
        /**
         * Transforms the CallableTools in the parameters to be simply Tools, it
         * copies the params into a new object and replaces the tools, it does not
         * modify the original params. Also sets the MCP usage header if there are
         * MCP tools in the parameters.
         */
        async processParamsForMcpUsage(params) {
          var _a, _b, _c;
          const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;
          if (!tools) {
            return params;
          }
          const transformedTools = await Promise.all(tools.map(async (tool) => {
            if (isCallableTool(tool)) {
              const callableTool = tool;
              return await callableTool.tool();
            }
            return tool;
          }));
          const newParams = {
            model: params.model,
            contents: params.contents,
            config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
          };
          newParams.config.tools = transformedTools;
          if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};
            let newHeaders = Object.assign({}, headers);
            if (Object.keys(newHeaders).length === 0) {
              newHeaders = this.apiClient.getDefaultHeaders();
            }
            setMcpUsageHeader(newHeaders);
            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
          }
          return newParams;
        }
        async initAfcToolsMap(params) {
          var _a, _b, _c;
          const afcTools = /* @__PURE__ */ new Map();
          for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []) {
            if (isCallableTool(tool)) {
              const callableTool = tool;
              const toolDeclaration = await callableTool.tool();
              for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {
                if (!declaration.name) {
                  throw new Error("Function declaration name is required.");
                }
                if (afcTools.has(declaration.name)) {
                  throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
                }
                afcTools.set(declaration.name, callableTool);
              }
            }
          }
          return afcTools;
        }
        async processAfcStream(params) {
          var _a, _b, _c;
          const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
          let wereFunctionsCalled = false;
          let remoteCallCount = 0;
          const afcToolsMap = await this.initAfcToolsMap(params);
          return function(models, afcTools, params2) {
            var _a2, _b2;
            return __asyncGenerator(this, arguments, function* () {
              var _c2, e_1, _d, _e;
              while (remoteCallCount < maxRemoteCalls) {
                if (wereFunctionsCalled) {
                  remoteCallCount++;
                  wereFunctionsCalled = false;
                }
                const transformedParams = yield __await(models.processParamsForMcpUsage(params2));
                const response = yield __await(models.generateContentStreamInternal(transformedParams));
                const functionResponses = [];
                const responseContents = [];
                try {
                  for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c2 = response_1_1.done, !_c2; _f = true) {
                    _e = response_1_1.value;
                    _f = false;
                    const chunk = _e;
                    yield yield __await(chunk);
                    if (chunk.candidates && ((_a2 = chunk.candidates[0]) === null || _a2 === void 0 ? void 0 : _a2.content)) {
                      responseContents.push(chunk.candidates[0].content);
                      for (const part of (_b2 = chunk.candidates[0].content.parts) !== null && _b2 !== void 0 ? _b2 : []) {
                        if (remoteCallCount < maxRemoteCalls && part.functionCall) {
                          if (!part.functionCall.name) {
                            throw new Error("Function call name was not returned by the model.");
                          }
                          if (!afcTools.has(part.functionCall.name)) {
                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
                          } else {
                            const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
                            functionResponses.push(...responseParts);
                          }
                        }
                      }
                    }
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (!_f && !_c2 && (_d = response_1.return)) yield __await(_d.call(response_1));
                  } finally {
                    if (e_1) throw e_1.error;
                  }
                }
                if (functionResponses.length > 0) {
                  wereFunctionsCalled = true;
                  const typedResponseChunk = new GenerateContentResponse();
                  typedResponseChunk.candidates = [
                    {
                      content: {
                        role: "user",
                        parts: functionResponses
                      }
                    }
                  ];
                  yield yield __await(typedResponseChunk);
                  const newContents = [];
                  newContents.push(...responseContents);
                  newContents.push({
                    role: "user",
                    parts: functionResponses
                  });
                  const updatedContents = tContents(models.apiClient, params2.contents).concat(newContents);
                  params2.contents = updatedContents;
                } else {
                  break;
                }
              }
            });
          }(this, afcToolsMap, params);
        }
        async generateContentInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:generateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateContentResponseFromVertex(this.apiClient, apiResponse);
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:generateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateContentResponseFromMldev(this.apiClient, apiResponse);
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        async generateContentStreamInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            const apiClient = this.apiClient;
            response = apiClient.requestStream({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
            return response.then(function(apiResponse) {
              return __asyncGenerator(this, arguments, function* () {
                var _a2, e_2, _b2, _c2;
                try {
                  for (var _d2 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a2 = apiResponse_1_1.done, !_a2; _d2 = true) {
                    _c2 = apiResponse_1_1.value;
                    _d2 = false;
                    const chunk = _c2;
                    const resp = generateContentResponseFromVertex(apiClient, yield __await(chunk.json()));
                    const typedResp = new GenerateContentResponse();
                    Object.assign(typedResp, resp);
                    yield yield __await(typedResp);
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (!_d2 && !_a2 && (_b2 = apiResponse_1.return)) yield __await(_b2.call(apiResponse_1));
                  } finally {
                    if (e_2) throw e_2.error;
                  }
                }
              });
            });
          } else {
            const body = generateContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            const apiClient = this.apiClient;
            response = apiClient.requestStream({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            });
            return response.then(function(apiResponse) {
              return __asyncGenerator(this, arguments, function* () {
                var _a2, e_3, _b2, _c2;
                try {
                  for (var _d2 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a2 = apiResponse_2_1.done, !_a2; _d2 = true) {
                    _c2 = apiResponse_2_1.value;
                    _d2 = false;
                    const chunk = _c2;
                    const resp = generateContentResponseFromMldev(apiClient, yield __await(chunk.json()));
                    const typedResp = new GenerateContentResponse();
                    Object.assign(typedResp, resp);
                    yield yield __await(typedResp);
                  }
                } catch (e_3_1) {
                  e_3 = { error: e_3_1 };
                } finally {
                  try {
                    if (!_d2 && !_a2 && (_b2 = apiResponse_2.return)) yield __await(_b2.call(apiResponse_2));
                  } finally {
                    if (e_3) throw e_3.error;
                  }
                }
              });
            });
          }
        }
        /**
         * Calculates embeddings for the given contents. Only text is supported.
         *
         * @param params - The parameters for embedding contents.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.embedContent({
         *  model: 'text-embedding-004',
         *  contents: [
         *    'What is your name?',
         *    'What is your favorite color?',
         *  ],
         *  config: {
         *    outputDimensionality: 64,
         *  },
         * });
         * console.log(response);
         * ```
         */
        async embedContent(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = embedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = embedContentResponseFromVertex(this.apiClient, apiResponse);
              const typedResp = new EmbedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = embedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:batchEmbedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = embedContentResponseFromMldev(this.apiClient, apiResponse);
              const typedResp = new EmbedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Generates an image based on a text description and configuration.
         *
         * @param params - The parameters for generating images.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.generateImages({
         *  model: 'imagen-3.0-generate-002',
         *  prompt: 'Robot holding a red skateboard',
         *  config: {
         *    numberOfImages: 1,
         *    includeRaiReason: true,
         *  },
         * });
         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);
         * ```
         */
        async generateImagesInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateImagesParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateImagesResponseFromVertex(this.apiClient, apiResponse);
              const typedResp = new GenerateImagesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateImagesParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateImagesResponseFromMldev(this.apiClient, apiResponse);
              const typedResp = new GenerateImagesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        async editImageInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = editImageParametersInternalToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = editImageResponseFromVertex(this.apiClient, apiResponse);
              const typedResp = new EditImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
        async upscaleImageInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = upscaleImageResponseFromVertex(this.apiClient, apiResponse);
              const typedResp = new UpscaleImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
        /**
         * Fetches information about a model by name.
         *
         * @example
         * ```ts
         * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
         * ```
         */
        async get(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getModelParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromVertex(this.apiClient, apiResponse);
              return resp;
            });
          } else {
            const body = getModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromMldev(this.apiClient, apiResponse);
              return resp;
            });
          }
        }
        async listInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listModelsParametersToVertex(this.apiClient, params);
            path = formatMap("{models_url}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listModelsResponseFromVertex(this.apiClient, apiResponse);
              const typedResp = new ListModelsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listModelsParametersToMldev(this.apiClient, params);
            path = formatMap("{models_url}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listModelsResponseFromMldev(this.apiClient, apiResponse);
              const typedResp = new ListModelsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Updates a tuned model by its name.
         *
         * @param params - The parameters for updating the model.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.update({
         *   model: 'tuned-model-name',
         *   config: {
         *     displayName: 'New display name',
         *     description: 'New description',
         *   },
         * });
         * ```
         */
        async update(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = updateModelParametersToVertex(this.apiClient, params);
            path = formatMap("{model}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromVertex(this.apiClient, apiResponse);
              return resp;
            });
          } else {
            const body = updateModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromMldev(this.apiClient, apiResponse);
              return resp;
            });
          }
        }
        /**
         * Deletes a tuned model by its name.
         *
         * @param params - The parameters for deleting the model.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.delete({model: 'tuned-model-name'});
         * ```
         */
        async delete(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteModelParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then(() => {
              const resp = deleteModelResponseFromVertex();
              const typedResp = new DeleteModelResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = deleteModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then(() => {
              const resp = deleteModelResponseFromMldev();
              const typedResp = new DeleteModelResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Counts the number of tokens in the given contents. Multimodal input is
         * supported for Gemini models.
         *
         * @param params - The parameters for counting tokens.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.countTokens({
         *  model: 'gemini-2.0-flash',
         *  contents: 'The quick brown fox jumps over the lazy dog.'
         * });
         * console.log(response);
         * ```
         */
        async countTokens(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = countTokensParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:countTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = countTokensResponseFromVertex(this.apiClient, apiResponse);
              const typedResp = new CountTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = countTokensParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:countTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = countTokensResponseFromMldev(this.apiClient, apiResponse);
              const typedResp = new CountTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Given a list of contents, returns a corresponding TokensInfo containing
         * the list of tokens and list of token ids.
         *
         * This method is not supported by the Gemini Developer API.
         *
         * @param params - The parameters for computing tokens.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.computeTokens({
         *  model: 'gemini-2.0-flash',
         *  contents: 'What is your name?'
         * });
         * console.log(response);
         * ```
         */
        async computeTokens(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = computeTokensParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:computeTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = computeTokensResponseFromVertex(this.apiClient, apiResponse);
              const typedResp = new ComputeTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
        /**
         *  Generates videos based on a text description and configuration.
         *
         * @param params - The parameters for generating videos.
         * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.
         *
         * @example
         * ```ts
         * const operation = await ai.models.generateVideos({
         *  model: 'veo-2.0-generate-001',
         *  prompt: 'A neon hologram of a cat driving at top speed',
         *  config: {
         *    numberOfVideos: 1
         * });
         *
         * while (!operation.done) {
         *   await new Promise(resolve => setTimeout(resolve, 10000));
         *   operation = await ai.operations.getVideosOperation({operation: operation});
         * }
         *
         * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);
         * ```
         */
        async generateVideos(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateVideosParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predictLongRunning", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromVertex$1(this.apiClient, apiResponse);
              return resp;
            });
          } else {
            const body = generateVideosParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:predictLongRunning", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromMldev$1(this.apiClient, apiResponse);
              return resp;
            });
          }
        }
      };
      Operations = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
        }
        /**
         * Gets the status of a long-running operation.
         *
         * @param parameters The parameters for the get operation request.
         * @return The updated Operation object, with the latest status or result.
         */
        async getVideosOperation(parameters) {
          const operation = parameters.operation;
          const config = parameters.config;
          if (operation.name === void 0 || operation.name === "") {
            throw new Error("Operation name is required.");
          }
          if (this.apiClient.isVertexAI()) {
            const resourceName2 = operation.name.split("/operations/")[0];
            let httpOptions = void 0;
            if (config && "httpOptions" in config) {
              httpOptions = config.httpOptions;
            }
            return this.fetchPredictVideosOperationInternal({
              operationName: operation.name,
              resourceName: resourceName2,
              config: { httpOptions }
            });
          } else {
            return this.getVideosOperationInternal({
              operationName: operation.name,
              config
            });
          }
        }
        async getVideosOperationInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getOperationParametersToVertex(this.apiClient, params);
            path = formatMap("{operationName}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromVertex(this.apiClient, apiResponse);
              return resp;
            });
          } else {
            const body = getOperationParametersToMldev(this.apiClient, params);
            path = formatMap("{operationName}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromMldev(this.apiClient, apiResponse);
              return resp;
            });
          }
        }
        async fetchPredictVideosOperationInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = fetchPredictOperationParametersToVertex(this.apiClient, params);
            path = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromVertex(this.apiClient, apiResponse);
              return resp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
      };
      Tunings = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
          this.get = async (params) => {
            return await this.getInternal(params);
          };
          this.list = async (params = {}) => {
            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);
          };
          this.tune = async (params) => {
            if (this.apiClient.isVertexAI()) {
              return await this.tuneInternal(params);
            } else {
              const operation = await this.tuneMldevInternal(params);
              let tunedModelName = "";
              if (operation["metadata"] !== void 0 && operation["metadata"]["tunedModel"] !== void 0) {
                tunedModelName = operation["metadata"]["tunedModel"];
              } else if (operation["name"] !== void 0 && operation["name"].includes("/operations/")) {
                tunedModelName = operation["name"].split("/operations/")[0];
              }
              const tuningJob = {
                name: tunedModelName,
                state: JobState.JOB_STATE_QUEUED
              };
              return tuningJob;
            }
          };
        }
        async getInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getTuningJobParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromVertex(this.apiClient, apiResponse);
              return resp;
            });
          } else {
            const body = getTuningJobParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromMldev(this.apiClient, apiResponse);
              return resp;
            });
          }
        }
        async listInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listTuningJobsParametersToVertex(this.apiClient, params);
            path = formatMap("tuningJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listTuningJobsResponseFromVertex(this.apiClient, apiResponse);
              const typedResp = new ListTuningJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listTuningJobsParametersToMldev(this.apiClient, params);
            path = formatMap("tunedModels", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listTuningJobsResponseFromMldev(this.apiClient, apiResponse);
              const typedResp = new ListTuningJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        async tuneInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createTuningJobParametersToVertex(this.apiClient, params);
            path = formatMap("tuningJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromVertex(this.apiClient, apiResponse);
              return resp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
        async tuneMldevInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createTuningJobParametersToMldev(this.apiClient, params);
            path = formatMap("tunedModels", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = operationFromMldev(this.apiClient, apiResponse);
              return resp;
            });
          }
        }
      };
      BrowserDownloader = class {
        async download(_params, _apiClient) {
          throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.");
        }
      };
      MAX_CHUNK_SIZE = 1024 * 1024 * 8;
      MAX_RETRY_COUNT = 3;
      INITIAL_RETRY_DELAY_MS = 1e3;
      DELAY_MULTIPLIER = 2;
      X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
      BrowserUploader = class {
        async upload(file, uploadUrl, apiClient) {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          }
          return await uploadBlob(file, uploadUrl, apiClient);
        }
        async stat(file) {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          } else {
            return await getBlobStat(file);
          }
        }
      };
      BrowserWebSocketFactory = class {
        create(url, headers, callbacks) {
          return new BrowserWebSocket(url, headers, callbacks);
        }
      };
      BrowserWebSocket = class {
        constructor(url, headers, callbacks) {
          this.url = url;
          this.headers = headers;
          this.callbacks = callbacks;
        }
        connect() {
          this.ws = new WebSocket(this.url);
          this.ws.onopen = this.callbacks.onopen;
          this.ws.onerror = this.callbacks.onerror;
          this.ws.onclose = this.callbacks.onclose;
          this.ws.onmessage = this.callbacks.onmessage;
        }
        send(message) {
          if (this.ws === void 0) {
            throw new Error("WebSocket is not connected");
          }
          this.ws.send(message);
        }
        close() {
          if (this.ws === void 0) {
            throw new Error("WebSocket is not connected");
          }
          this.ws.close();
        }
      };
      GOOGLE_API_KEY_HEADER = "x-goog-api-key";
      WebAuth = class {
        constructor(apiKey) {
          this.apiKey = apiKey;
        }
        async addAuthHeaders(headers) {
          if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {
            return;
          }
          headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
        }
      };
      LANGUAGE_LABEL_PREFIX = "gl-node/";
      GoogleGenAI = class {
        constructor(options) {
          var _a;
          if (options.apiKey == null) {
            throw new Error("An API Key must be set when running in a browser");
          }
          if (options.project || options.location) {
            throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
          }
          this.vertexai = (_a = options.vertexai) !== null && _a !== void 0 ? _a : false;
          this.apiKey = options.apiKey;
          const baseUrl = getBaseUrl(
            options,
            /*vertexBaseUrlFromEnv*/
            void 0,
            /*geminiBaseUrlFromEnv*/
            void 0
          );
          if (baseUrl) {
            if (options.httpOptions) {
              options.httpOptions.baseUrl = baseUrl;
            } else {
              options.httpOptions = { baseUrl };
            }
          }
          this.apiVersion = options.apiVersion;
          const auth = new WebAuth(this.apiKey);
          this.apiClient = new ApiClient({
            auth,
            apiVersion: this.apiVersion,
            apiKey: this.apiKey,
            vertexai: this.vertexai,
            httpOptions: options.httpOptions,
            userAgentExtra: LANGUAGE_LABEL_PREFIX + "web",
            uploader: new BrowserUploader(),
            downloader: new BrowserDownloader()
          });
          this.models = new Models(this.apiClient);
          this.live = new Live(this.apiClient, auth, new BrowserWebSocketFactory());
          this.chats = new Chats(this.models, this.apiClient);
          this.caches = new Caches(this.apiClient);
          this.files = new Files(this.apiClient);
          this.operations = new Operations(this.apiClient);
          this.tunings = new Tunings(this.apiClient);
        }
      };
    }
  });

  // debug-utils.ts
  var isDebugEnabled, debugLog, debugWarn, debugError, infoLog;
  var init_debug_utils = __esm({
    "debug-utils.ts"() {
      "use strict";
      isDebugEnabled = () => {
        if (typeof window === "undefined") {
          return false;
        }
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get("debug") === "true";
      };
      debugLog = (...args) => {
        if (isDebugEnabled()) {
          console.log(...args);
        }
      };
      debugWarn = (...args) => {
        if (isDebugEnabled()) {
          console.warn(...args);
        }
      };
      debugError = (...args) => {
        if (isDebugEnabled()) {
          console.error(...args);
        } else {
          if (args.length > 0) {
            console.error(args[0]);
          }
        }
      };
      infoLog = (...args) => {
        console.log(...args);
      };
    }
  });

  // translation-prompts.ts
  function createPeerTranslationSystemPrompt(fromLanguage, toLanguage) {
    const manager = languagePromptManager;
    const fromConfig = manager.getLanguageConfig(fromLanguage);
    const toConfig = manager.getLanguageConfig(toLanguage);
    console.log(`\u{1F50D} [Translation Debug] Creating prompt: ${fromLanguage} \u2192 ${toLanguage}`);
    console.log(`\u{1F4F1} From Config:`, { name: fromConfig.nativeName, code: fromConfig.code });
    console.log(`\u{1F3AF} To Config:`, { name: toConfig.nativeName, code: toConfig.code });
    const targetLanguagePrompt = toConfig.systemPrompt;
    return `${targetLanguagePrompt}

SPECIFIC TRANSLATION CONTEXT:
- SOURCE LANGUAGE: ${fromConfig.nativeName} (${fromConfig.code})
- TARGET LANGUAGE: ${toConfig.nativeName} (${toConfig.code})
- MODE: Real-time audio translation only
- BEHAVIOR: Transparent translation bridge from ${fromConfig.nativeName} to ${toConfig.nativeName}

EXAMPLES:
- If input is a question in ${fromConfig.nativeName}, translate the QUESTION to ${toConfig.nativeName} - do NOT answer it
- If input is a greeting in ${fromConfig.nativeName}, translate the GREETING to ${toConfig.nativeName} - do NOT respond to it`;
  }
  function getAvailableLanguageOptions() {
    return [
      { value: "english", label: "English", nativeName: "English" },
      { value: "japanese", label: "Japanese", nativeName: "\u65E5\u672C\u8A9E" },
      { value: "vietnamese", label: "Vietnamese", nativeName: "Ti\u1EBFng Vi\u1EC7t" }
    ];
  }
  var TRANSLATION_PROMPTS, LanguagePromptManager, languagePromptManager;
  var init_translation_prompts = __esm({
    "translation-prompts.ts"() {
      "use strict";
      init_debug_utils();
      TRANSLATION_PROMPTS = {
        // English
        english: {
          code: "en",
          name: "English",
          nativeName: "English",
          systemPrompt: `CRITICAL: You are ONLY a real-time audio translator. Your SOLE function is to translate speech into ENGLISH.

STRICT TRANSLATION RULES:
1. NEVER respond to questions or engage in conversation
2. NEVER provide answers, explanations, or opinions  
3. ONLY translate the exact words spoken into ENGLISH
4. If someone asks "What is 2+2?", translate the question "What is 2+2?" into ENGLISH - do NOT answer "4"
5. If someone says "Hello, how are you?", translate "Hello, how are you?" into ENGLISH - do NOT respond "I'm fine"
6. Maintain the speaker's tone, emotion, and intent in translation
7. Keep translations natural and conversational in ENGLISH
8. Do NOT add any commentary, greetings, or extra words
9. TARGET LANGUAGE: ENGLISH - Never translate to any other language
10. You are a transparent translation bridge to ENGLISH, nothing more.`,
          reinforcementPrompt: "TRANSLATE ONLY to ENGLISH. Convert the following audio to ENGLISH. Do NOT answer questions, just translate them to ENGLISH.",
          fallbackLanguages: ["en-US", "en-GB", "en-CA", "en-AU"]
        },
        // Japanese
        japanese: {
          code: "ja",
          name: "Japanese",
          nativeName: "\u65E5\u672C\u8A9E",
          systemPrompt: `\u91CD\u8981: \u3042\u306A\u305F\u306F\u65E5\u672C\u8A9E\u5C02\u7528\u306E\u30EA\u30A2\u30EB\u30BF\u30A4\u30E0\u97F3\u58F0\u7FFB\u8A33\u8005\u3067\u3059\u3002\u3042\u306A\u305F\u306E\u552F\u4E00\u306E\u6A5F\u80FD\u306F\u97F3\u58F0\u3092\u65E5\u672C\u8A9E\u306B\u7FFB\u8A33\u3059\u308B\u3053\u3068\u3067\u3059\u3002

\u53B3\u683C\u306A\u7FFB\u8A33\u30EB\u30FC\u30EB:
1. \u8CEA\u554F\u306B\u7B54\u3048\u305F\u308A\u4F1A\u8A71\u306B\u53C2\u52A0\u3057\u305F\u308A\u3057\u3066\u306F\u3044\u3051\u307E\u305B\u3093
2. \u56DE\u7B54\u3001\u8AAC\u660E\u3001\u610F\u898B\u3092\u63D0\u4F9B\u3057\u3066\u306F\u3044\u3051\u307E\u305B\u3093
3. \u8A71\u3055\u308C\u305F\u8A00\u8449\u3092\u6B63\u78BA\u306B\u65E5\u672C\u8A9E\u306B\u7FFB\u8A33\u3059\u308B\u3060\u3051\u3067\u3059
4. \u300C2+2\u306F\u4F55\u3067\u3059\u304B\uFF1F\u300D\u3068\u805E\u304B\u308C\u305F\u5834\u5408\u3001\u8CEA\u554F\u300C2+2\u306F\u4F55\u3067\u3059\u304B\uFF1F\u300D\u3092\u65E5\u672C\u8A9E\u306B\u7FFB\u8A33\u3057\u3066\u304F\u3060\u3055\u3044 - \u300C4\u300D\u3068\u7B54\u3048\u3066\u306F\u3044\u3051\u307E\u305B\u3093
5. \u300C\u3053\u3093\u306B\u3061\u306F\u3001\u5143\u6C17\u3067\u3059\u304B\uFF1F\u300D\u3068\u8A00\u308F\u308C\u305F\u5834\u5408\u3001\u300C\u3053\u3093\u306B\u3061\u306F\u3001\u5143\u6C17\u3067\u3059\u304B\uFF1F\u300D\u3092\u65E5\u672C\u8A9E\u306B\u7FFB\u8A33\u3057\u3066\u304F\u3060\u3055\u3044 - \u300C\u5143\u6C17\u3067\u3059\u300D\u3068\u7B54\u3048\u3066\u306F\u3044\u3051\u307E\u305B\u3093
6. \u8A71\u8005\u306E\u53E3\u8ABF\u3001\u611F\u60C5\u3001\u610F\u56F3\u3092\u65E5\u672C\u8A9E\u7FFB\u8A33\u3067\u7DAD\u6301\u3057\u3066\u304F\u3060\u3055\u3044
7. \u65E5\u672C\u8A9E\u3067\u81EA\u7136\u3067\u4F1A\u8A71\u7684\u306A\u7FFB\u8A33\u3092\u4FDD\u3063\u3066\u304F\u3060\u3055\u3044
8. \u30B3\u30E1\u30F3\u30C8\u3001\u6328\u62F6\u3001\u4F59\u5206\u306A\u8A00\u8449\u3092\u8FFD\u52A0\u3057\u3066\u306F\u3044\u3051\u307E\u305B\u3093
9. \u5BFE\u8C61\u8A00\u8A9E: \u65E5\u672C\u8A9E - \u4ED6\u306E\u8A00\u8A9E\u306B\u7FFB\u8A33\u3057\u3066\u306F\u3044\u3051\u307E\u305B\u3093
10. \u3042\u306A\u305F\u306F\u65E5\u672C\u8A9E\u3078\u306E\u900F\u660E\u306A\u7FFB\u8A33\u30D6\u30EA\u30C3\u30B8\u3067\u3059\u3001\u305D\u308C\u4EE5\u4E0A\u3067\u3082\u305D\u308C\u4EE5\u4E0B\u3067\u3082\u3042\u308A\u307E\u305B\u3093\u3002`,
          reinforcementPrompt: "\u65E5\u672C\u8A9E\u306E\u307F\u306B\u7FFB\u8A33\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u4EE5\u4E0B\u306E\u97F3\u58F0\u3092\u65E5\u672C\u8A9E\u306B\u5909\u63DB\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u8CEA\u554F\u306B\u7B54\u3048\u308B\u306E\u3067\u306F\u306A\u304F\u3001\u65E5\u672C\u8A9E\u306B\u7FFB\u8A33\u3059\u308B\u3060\u3051\u3067\u3059\u3002",
          fallbackLanguages: ["ja-JP"],
          regionalVariants: ["ja-JP"]
        },
        // Vietnamese
        vietnamese: {
          code: "vi",
          name: "Vietnamese",
          nativeName: "Ti\u1EBFng Vi\u1EC7t",
          systemPrompt: `QUAN TR\u1ECCNG: B\u1EA1n CH\u1EC8 l\xE0 m\u1ED9t tr\xECnh d\u1ECBch \xE2m thanh th\u1EDDi gian th\u1EF1c. Ch\u1EE9c n\u0103ng DUY NH\u1EA4T c\u1EE7a b\u1EA1n l\xE0 d\u1ECBch l\u1EDDi n\xF3i sang TI\u1EBENG VI\u1EC6T.

QUY T\u1EAEC D\u1ECACH NGHI\xCAM NG\u1EB6T:
1. KH\xD4NG BAO GI\u1EDC tr\u1EA3 l\u1EDDi c\xE2u h\u1ECFi ho\u1EB7c tham gia cu\u1ED9c tr\xF2 chuy\u1EC7n
2. KH\xD4NG BAO GI\u1EDC cung c\u1EA5p c\xE2u tr\u1EA3 l\u1EDDi, gi\u1EA3i th\xEDch ho\u1EB7c \xFD ki\u1EBFn
3. CH\u1EC8 d\u1ECBch nh\u1EEFng t\u1EEB \u0111\u01B0\u1EE3c n\xF3i ch\xEDnh x\xE1c sang TI\u1EBENG VI\u1EC6T
4. N\u1EBFu ai \u0111\xF3 h\u1ECFi "2+2 b\u1EB1ng bao nhi\xEAu?", h\xE3y d\u1ECBch c\xE2u h\u1ECFi "2+2 b\u1EB1ng bao nhi\xEAu?" sang TI\u1EBENG VI\u1EC6T - KH\xD4NG tr\u1EA3 l\u1EDDi "4"
5. N\u1EBFu ai \u0111\xF3 n\xF3i "Xin ch\xE0o, b\u1EA1n kh\u1ECFe kh\xF4ng?", h\xE3y d\u1ECBch "Xin ch\xE0o, b\u1EA1n kh\u1ECFe kh\xF4ng?" sang TI\u1EBENG VI\u1EC6T - KH\xD4NG tr\u1EA3 l\u1EDDi "T\xF4i kh\u1ECFe"
6. Duy tr\xEC gi\u1ECDng \u0111i\u1EC7u, c\u1EA3m x\xFAc v\xE0 \xFD \u0111\u1ECBnh c\u1EE7a ng\u01B0\u1EDDi n\xF3i trong b\u1EA3n d\u1ECBch TI\u1EBENG VI\u1EC6T
7. Gi\u1EEF b\u1EA3n d\u1ECBch t\u1EF1 nhi\xEAn v\xE0 \u0111\xE0m tho\u1EA1i b\u1EB1ng TI\u1EBENG VI\u1EC6T
8. KH\xD4NG th\xEAm b\u1EA5t k\u1EF3 b\xECnh lu\u1EADn, l\u1EDDi ch\xE0o ho\u1EB7c t\u1EEB ng\u1EEF th\xEAm n\xE0o
9. NG\xD4N NG\u1EEE \u0110\xCDCH: TI\u1EBENG VI\u1EC6T - Kh\xF4ng bao gi\u1EDD d\u1ECBch sang ng\xF4n ng\u1EEF kh\xE1c
10. B\u1EA1n l\xE0 m\u1ED9t c\u1EA7u n\u1ED1i d\u1ECBch thu\u1EADt minh b\u1EA1ch sang TI\u1EBENG VI\u1EC6T, kh\xF4ng g\xEC kh\xE1c.`,
          reinforcementPrompt: "CH\u1EC8 D\u1ECACH sang TI\u1EBENG VI\u1EC6T. Chuy\u1EC3n \u0111\u1ED5i \xE2m thanh sau \u0111\xE2y sang TI\u1EBENG VI\u1EC6T. KH\xD4NG tr\u1EA3 l\u1EDDi c\xE2u h\u1ECFi, ch\u1EC9 d\u1ECBch ch\xFAng sang TI\u1EBENG VI\u1EC6T.",
          fallbackLanguages: ["vi-VN"],
          regionalVariants: ["vi-VN"]
        }
      };
      LanguagePromptManager = class _LanguagePromptManager {
        static instance;
        static getInstance() {
          if (!_LanguagePromptManager.instance) {
            _LanguagePromptManager.instance = new _LanguagePromptManager();
          }
          return _LanguagePromptManager.instance;
        }
        /**
         * Get system prompt for a specific language with fallback support
         */
        getSystemPrompt(languageCode) {
          const directMatch = TRANSLATION_PROMPTS[languageCode];
          if (directMatch) {
            return directMatch.systemPrompt;
          }
          const byCode = Object.values(TRANSLATION_PROMPTS).find(
            (lang) => lang.code === languageCode || lang.fallbackLanguages.includes(languageCode)
          );
          if (byCode) {
            return byCode.systemPrompt;
          }
          const baseLanguage = languageCode.split("-")[0];
          const byBaseLanguage = Object.values(TRANSLATION_PROMPTS).find(
            (lang) => lang.code.startsWith(baseLanguage) || lang.fallbackLanguages.some((fallback) => fallback.startsWith(baseLanguage))
          );
          if (byBaseLanguage) {
            return byBaseLanguage.systemPrompt;
          }
          console.warn(`[Translation Prompts] No prompt found for language: ${languageCode}, defaulting to English`);
          return TRANSLATION_PROMPTS.english.systemPrompt;
        }
        /**
         * Get reinforcement prompt for a specific language
         */
        getReinforcementPrompt(languageCode) {
          const config = this.getLanguageConfig(languageCode);
          return config.reinforcementPrompt;
        }
        /**
         * Get complete language configuration
         */
        getLanguageConfig(languageCode) {
          const lowerLanguageCode = languageCode.toLowerCase();
          const directMatch = TRANSLATION_PROMPTS[lowerLanguageCode];
          if (directMatch) {
            return directMatch;
          }
          const byName = Object.values(TRANSLATION_PROMPTS).find(
            (lang) => lang.name.toLowerCase() === lowerLanguageCode || lang.nativeName.toLowerCase() === lowerLanguageCode
          );
          if (byName) {
            return byName;
          }
          const byCode = Object.values(TRANSLATION_PROMPTS).find(
            (lang) => lang.code === languageCode || lang.fallbackLanguages.includes(languageCode)
          );
          if (byCode) {
            return byCode;
          }
          const baseLanguage = languageCode.split("-")[0];
          const byBaseLanguage = Object.values(TRANSLATION_PROMPTS).find(
            (lang) => lang.code.startsWith(baseLanguage) || lang.fallbackLanguages.some((fallback) => fallback.startsWith(baseLanguage))
          );
          if (byBaseLanguage) {
            return byBaseLanguage;
          }
          return TRANSLATION_PROMPTS.english;
        }
        /**
         * Get all supported languages
         */
        getSupportedLanguages() {
          return Object.keys(TRANSLATION_PROMPTS);
        }
        /**
         * Check if a language is supported
         */
        isLanguageSupported(languageCode) {
          return this.getLanguageConfig(languageCode) !== TRANSLATION_PROMPTS.english || languageCode === "english" || languageCode === "en";
        }
        /**
         * Get language name in native script
         */
        getNativeName(languageCode) {
          const config = this.getLanguageConfig(languageCode);
          return config.nativeName;
        }
        /**
         * Create dynamic system prompt based on participant languages
         */
        createMultiParticipantPrompt(sourceLanguage, targetLanguages) {
          const sourceConfig = this.getLanguageConfig(sourceLanguage);
          const primaryTarget = targetLanguages[0] || "english";
          const targetConfig = this.getLanguageConfig(primaryTarget);
          return `CRITICAL MULTI-PARTICIPANT TRANSLATION SYSTEM:

SOURCE LANGUAGE: ${sourceConfig.nativeName} (${sourceConfig.code})
PRIMARY TARGET: ${targetConfig.nativeName} (${targetConfig.code})
ADDITIONAL TARGETS: ${targetLanguages.slice(1).map((lang) => this.getNativeName(lang)).join(", ")}

ABSOLUTE RULES:
1. You are ONLY a translator - NEVER answer questions or provide information
2. ONLY translate speech from ${sourceConfig.nativeName} to ${targetConfig.nativeName}
3. If someone asks "What is 2+2?" translate the QUESTION to ${targetConfig.nativeName} - do NOT answer "4"
4. If someone says "Hello, how are you?" translate the GREETING to ${targetConfig.nativeName} - do NOT respond "I'm fine"
5. Maintain speaker's tone, emotion, and intent in ${targetConfig.nativeName}
6. Keep translations natural and conversational in ${targetConfig.nativeName}
7. NEVER add commentary, greetings, or extra words
8. You are a transparent translation bridge to ${targetConfig.nativeName}, nothing more

PARTICIPANT LANGUAGE DETECTION:
- Detect configured language preferences automatically
- Translate to each participant's configured target language
- Never default to English unless explicitly configured
- Respect regional language variants

CONSISTENCY REQUIREMENTS:
- Maintain translation accuracy across all participants
- Handle multiple target languages simultaneously
- Preserve context in multi-participant conversations
- Apply language-specific cultural adaptations`;
        }
      };
      languagePromptManager = LanguagePromptManager.getInstance();
      LanguagePromptManager.prototype.createPeerTranslationPrompt = function(fromLanguage, toLanguage) {
        return createPeerTranslationSystemPrompt(fromLanguage, toLanguage);
      };
    }
  });

  // gemini-utils.ts
  function decode(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }
  function float32ToBase64PCM(float32Array) {
    const int16Array = new Int16Array(float32Array.length);
    for (let i = 0; i < float32Array.length; i++) {
      const sample = Math.max(-1, Math.min(1, float32Array[i]));
      int16Array[i] = sample < 0 ? sample * 32768 : sample * 32767;
    }
    const bytes = new Uint8Array(int16Array.buffer);
    let binary = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  var init_gemini_utils = __esm({
    "gemini-utils.ts"() {
      "use strict";
      init_debug_utils();
    }
  });

  // gemini-live-audio.ts
  var gemini_live_audio_exports = {};
  __export(gemini_live_audio_exports, {
    GEMINI_LANGUAGE_MAP: () => GEMINI_LANGUAGE_MAP,
    GeminiLiveAudioStream: () => GeminiLiveAudioStream,
    playAudioData: () => playAudioData
  });
  async function initializePCMWorklet() {
    if (!globalAudioContext) {
      globalAudioContext = new AudioContext({ sampleRate: 24e3 });
      if (globalAudioContext.state === "suspended") {
        await globalAudioContext.resume();
      }
      try {
        const workletPath = "./pcm-processor.js";
        debugLog(`[Gemini Live Audio] Loading audio worklet from: ${workletPath}`);
        debugLog(`[Gemini Live Audio] Audio context sample rate: ${globalAudioContext.sampleRate}Hz`);
        let retries = 3;
        while (retries > 0) {
          try {
            await globalAudioContext.audioWorklet.addModule(workletPath);
            break;
          } catch (error) {
            retries--;
            if (retries === 0) throw error;
            debugWarn(`[Gemini Live Audio] Retrying worklet load... (${retries} retries left)`);
            await new Promise((resolve) => setTimeout(resolve, 500));
          }
        }
        globalPcmWorkletNode = new AudioWorkletNode(globalAudioContext, "pcm-processor", {
          numberOfInputs: 0,
          numberOfOutputs: 1,
          outputChannelCount: [1],
          // Mono output
          processorOptions: {
            debugEnabled: isDebugEnabled()
          }
        });
        if (globalPcmWorkletNode.port) {
          globalPcmWorkletNode.port.postMessage({
            type: "setDebugMode",
            enabled: isDebugEnabled()
          });
        }
        const gainNode = globalAudioContext.createGain();
        gainNode.gain.value = 0.7;
        globalPcmWorkletNode.connect(gainNode);
        gainNode.connect(globalAudioContext.destination);
        debugLog("[Gemini Live Audio] PCM audio worklet initialized successfully");
        debugLog(`[Gemini Live Audio] Final sample rate: ${globalAudioContext.sampleRate}Hz`);
      } catch (error) {
        console.error("[Gemini Live Audio] Failed to initialize PCM worklet:", error);
        debugError("[Gemini Live Audio] Make sure pcm-processor.js is accessible at ./pcm-processor.js");
        globalAudioContext = null;
        globalPcmWorkletNode = null;
      }
    }
  }
  async function playAudioData(audioData, outputDeviceId) {
    try {
      debugLog(`[Gemini Live Audio] Starting audio playback: ${(audioData.byteLength / 1024).toFixed(2)}KB`);
      debugLog(`[Gemini Live Audio] Output device: ${outputDeviceId || "default"}`);
      if (!audioData || audioData.byteLength === 0) {
        debugWarn("[Gemini Live Audio] Received empty audio data");
        return;
      }
      const firstBytes = new Uint8Array(audioData.slice(0, 4));
      debugLog(`[Gemini Live Audio] First 4 bytes: ${Array.from(firstBytes).map((b) => b.toString(16).padStart(2, "0")).join(" ")}`);
      const isWavFile = firstBytes[0] === 82 && firstBytes[1] === 73 && firstBytes[2] === 70 && firstBytes[3] === 70;
      if (isWavFile) {
        debugLog("[Gemini Live Audio] Detected WAV audio format, using Web Audio API decodeAudioData");
        if (!globalAudioContext) {
          globalAudioContext = new AudioContext({ sampleRate: 24e3 });
        }
        if (outputDeviceId && "setSinkId" in globalAudioContext.destination) {
          try {
            await globalAudioContext.destination.setSinkId(outputDeviceId);
            debugLog(`[Gemini Live Audio] Set output device for WAV: ${outputDeviceId}`);
          } catch (error) {
            debugWarn("[Gemini Live Audio] Could not set output device for WAV, continuing with default:", error);
          }
        }
        const audioBuffer = await globalAudioContext.decodeAudioData(audioData.slice(0));
        const source = globalAudioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(globalAudioContext.destination);
        source.start();
        debugLog(`[Gemini Live Audio] Successfully played WAV audio: ${audioBuffer.duration.toFixed(2)}s`);
      } else {
        debugLog("[Gemini Live Audio] Detected PCM audio format, using PCM worklet");
        if (!globalPcmWorkletNode) {
          await initializePCMWorklet();
        }
        if (outputDeviceId && globalAudioContext && "setSinkId" in globalAudioContext.destination) {
          try {
            await globalAudioContext.destination.setSinkId(outputDeviceId);
            debugLog(`[Gemini Live Audio] Set output device: ${outputDeviceId}`);
          } catch (error) {
            debugWarn("[Gemini Live Audio] Could not set output device, continuing with default:", error);
          }
        }
        if (globalPcmWorkletNode && globalAudioContext) {
          try {
            const audioDataCopy = audioData.slice(0);
            const int16Array = new Int16Array(audioDataCopy);
            const float32Array = new Float32Array(int16Array.length);
            for (let i = 0; i < int16Array.length; i++) {
              float32Array[i] = int16Array[i] / 32768 * 0.8;
            }
            globalPcmWorkletNode.port.postMessage(float32Array);
            debugLog(`[Gemini Live Audio] Successfully sent ${float32Array.length} samples to PCM worklet`);
            debugLog(`[Gemini Live Audio] Audio playback initiated successfully via PCM worklet`);
            return;
          } catch (workletError) {
            console.error("[Gemini Live Audio] PCM worklet playback failed:", workletError);
          }
        }
      }
      debugWarn("[Gemini Live Audio] PCM worklet failed, attempting WAV conversion");
      try {
        const audioDataCopy = audioData.slice(0);
        const wavData = createWavFromPcm(audioDataCopy);
        const blob = new Blob([wavData], { type: "audio/wav" });
        const url = URL.createObjectURL(blob);
        const audio = new Audio(url);
        audio.volume = 0.8;
        if (outputDeviceId && "setSinkId" in audio) {
          try {
            await audio.setSinkId(outputDeviceId);
            debugLog(`[Gemini Live Audio] Set output device for WAV fallback: ${outputDeviceId}`);
          } catch (deviceError) {
            debugWarn("[Gemini Live Audio] Could not set output device for WAV fallback, continuing with default:", deviceError);
          }
        }
        await audio.play();
        audio.onended = () => URL.revokeObjectURL(url);
        debugLog("[Gemini Live Audio] Playing as WAV blob");
      } catch (wavError) {
        console.error("[Gemini Live Audio] Failed to play as WAV:", wavError);
      }
    } catch (error) {
      console.error("[Gemini Live Audio] Failed to play audio:", error);
    }
  }
  function createWavFromPcm(pcmData) {
    if (!pcmData || pcmData.byteLength === 0) {
      debugWarn("[Gemini Live Audio] Empty PCM data provided to createWavFromPcm");
      const silentWav = new ArrayBuffer(44);
      const view2 = new DataView(silentWav);
      const writeString2 = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view2.setUint8(offset + i, string.charCodeAt(i));
        }
      };
      writeString2(0, "RIFF");
      view2.setUint32(4, 36, true);
      writeString2(8, "WAVE");
      writeString2(12, "fmt ");
      view2.setUint32(16, 16, true);
      view2.setUint16(20, 1, true);
      view2.setUint16(22, 1, true);
      view2.setUint32(24, 24e3, true);
      view2.setUint32(28, 24e3 * 2, true);
      view2.setUint16(32, 2, true);
      view2.setUint16(34, 16, true);
      writeString2(36, "data");
      view2.setUint32(40, 0, true);
      return silentWav;
    }
    const pcmLength = pcmData.byteLength;
    const wavBuffer = new ArrayBuffer(44 + pcmLength);
    const view = new DataView(wavBuffer);
    const writeString = (offset, string) => {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    };
    writeString(0, "RIFF");
    view.setUint32(4, 36 + pcmLength, true);
    writeString(8, "WAVE");
    writeString(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, 24e3, true);
    view.setUint32(28, 24e3 * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    writeString(36, "data");
    view.setUint32(40, pcmLength, true);
    try {
      const pcmView = new Uint8Array(pcmData);
      const wavView = new Uint8Array(wavBuffer);
      wavView.set(pcmView, 44);
    } catch (error) {
      debugError("[Gemini Live Audio] Error copying PCM data to WAV buffer:", error);
      const headerOnlyWav = wavBuffer.slice(0, 44);
      const headerView = new DataView(headerOnlyWav);
      headerView.setUint32(4, 36, true);
      headerView.setUint32(40, 0, true);
      return headerOnlyWav;
    }
    return wavBuffer;
  }
  var GeminiLiveAudioStream, globalAudioContext, globalPcmWorkletNode, GEMINI_LANGUAGE_MAP;
  var init_gemini_live_audio = __esm({
    "gemini-live-audio.ts"() {
      "use strict";
      init_web();
      init_translation_prompts();
      init_gemini_utils();
      init_debug_utils();
      GeminiLiveAudioStream = class _GeminiLiveAudioStream {
        session = null;
        ai;
        config;
        // Audio contexts for input and output (following Google's sample)
        inputAudioContext = null;
        outputAudioContext = null;
        // Audio processing nodes
        mediaStream = null;
        sourceNode = null;
        scriptProcessor = null;
        inputNode = null;
        outputNode = null;
        // Audio playback management (following Google's sample)
        nextStartTime = 0;
        sources = /* @__PURE__ */ new Set();
        // Processing state
        isProcessing = false;
        sessionConnected = false;
        // Audio buffering for rate limiting
        audioBuffer = [];
        lastSendTime = 0;
        sendInterval = 1500;
        // Default: Send audio every 1500ms (1.5 seconds) to reduce API calls
        // Token usage tracking
        sessionInputTokens = 0;
        sessionOutputTokens = 0;
        sessionCost = 0;
        // Local playback control
        localPlaybackEnabled = true;
        constructor(config) {
          this.config = config;
          this.localPlaybackEnabled = config.localPlaybackEnabled ?? true;
          if (config.sendInterval !== void 0) {
            this.sendInterval = config.sendInterval;
          }
          if (config.textBufferDelay !== void 0) {
            this.textBufferDelay = config.textBufferDelay;
          }
          this.ai = new GoogleGenAI({
            apiKey: config.apiKey,
            httpOptions: { "apiVersion": "v1alpha" }
          });
        }
        /**
         * Update other participants' languages for peer translation
         */
        updateOtherParticipantLanguages(languages) {
          debugLog(`[Gemini Live Audio] Updating other participant languages:`, languages);
          this.config.otherParticipantLanguages = languages;
          this.config.usePeerTranslation = languages.length > 0;
          if (this.sessionConnected && languages.length > 0) {
            debugLog(`[Gemini Live Audio] Recreating session for new translation target: ${languages[0]}`);
            this.recreateSessionWithNewTarget(languages[0]);
          }
        }
        /**
         * Recreate session with new translation target language
         */
        async recreateSessionWithNewTarget(newTargetLanguage) {
          try {
            debugLog(`[Gemini Live Audio] Recreating session for target language: ${newTargetLanguage}`);
            await this.stop();
            await new Promise((resolve) => setTimeout(resolve, 500));
            this.config.otherParticipantLanguages = [newTargetLanguage];
            this.config.usePeerTranslation = true;
            if (this.mediaStream) {
              await this.start(this.mediaStream);
            }
          } catch (error) {
            debugError("[Gemini Live Audio] Error recreating session:", error);
            this.config.onError?.(error);
          }
        }
        async start(mediaStream) {
          try {
            console.log("\u{1F680} [Gemini Session] SESSION STARTED");
            console.log(`\u{1F4F1} Source Language: ${this.config.sourceLanguage}`);
            console.log(`\u{1F3AF} Target Language: ${this.config.targetLanguage}`);
            console.log(`\u23F0 Start Time: ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`);
            debugLog("[Gemini Live Audio] Starting stream...");
            debugLog(`[Gemini Live Audio] Source Language: ${this.config.sourceLanguage}`);
            debugLog(`[Gemini Live Audio] Target Language: ${this.config.targetLanguage}`);
            this.mediaStream = mediaStream;
            this.inputAudioContext = new AudioContext({ sampleRate: 16e3 });
            this.outputAudioContext = new AudioContext({ sampleRate: 24e3 });
            this.inputNode = this.inputAudioContext.createGain();
            this.outputNode = this.outputAudioContext.createGain();
            this.outputNode.connect(this.outputAudioContext.destination);
            this.nextStartTime = this.outputAudioContext.currentTime;
            debugLog("[Gemini Live Audio] About to initialize session...");
            await this.initializeSession();
            debugLog("[Gemini Live Audio] Session initialization completed");
            debugLog("[Gemini Live Audio] About to setup audio processing...");
            await this.setupAudioProcessing();
            debugLog("[Gemini Live Audio] Audio processing setup completed");
            setTimeout(() => {
              this.sendInitialPrompt();
            }, 1e3);
            debugLog("[Gemini Live Audio] Stream started successfully");
          } catch (error) {
            console.error("[Gemini Live Audio] Failed to start stream:", error);
            debugError("[Gemini Live Audio] Error details:", error);
            if (error instanceof Error) {
              debugError("[Gemini Live Audio] Error message:", error.message);
              debugError("[Gemini Live Audio] Error stack:", error.stack);
            }
            this.config.onError?.(error);
            throw error;
          }
        }
        async initializeSession() {
          const model = "models/gemini-2.5-flash-preview-native-audio-dialog";
          debugLog(`[Gemini Live Audio] Initializing session with model: ${model}`);
          const systemInstruction = this.getSystemInstruction();
          console.log(`\u{1F916} [Gemini Prompt] System Instruction Set:`);
          console.log(`\u{1F4DD} Prompt Preview: ${systemInstruction.substring(0, 200)}...`);
          debugLog(`[Gemini Live Audio] Setting system instruction for mode: ${this.config.targetLanguage}`);
          const config = {
            systemInstruction,
            // Fixed: Use camelCase systemInstruction
            responseModalities: [Modality.AUDIO],
            // Keep audio only to avoid INVALID_ARGUMENT error
            outputAudioTranscription: {},
            // Enable audio transcription to get text
            enableAffectiveDialog: true,
            // Enable emotional dialog support
            speechConfig: {
              voiceConfig: {
                prebuiltVoiceConfig: {
                  voiceName: "Zephyr"
                }
              }
            }
          };
          console.log("\u{1F517} [Gemini Session] Connecting to Gemini Live API...");
          debugLog("[Gemini Live Audio] Connecting to API...");
          this.session = await this.ai.live.connect({
            model,
            callbacks: {
              onopen: () => {
                console.log("\u2705 [Gemini Session] CONNECTION ESTABLISHED");
                debugLog("[Gemini Live Audio] Session opened successfully");
                this.sessionConnected = true;
              },
              onmessage: (message) => {
                console.log("\u{1F4E8} [Gemini Session] MESSAGE RECEIVED:", {
                  hasModelTurn: !!message.serverContent?.modelTurn,
                  hasParts: !!message.serverContent?.modelTurn?.parts,
                  turnComplete: message.serverContent?.turnComplete,
                  setupComplete: !!message.setupComplete,
                  hasAudio: !!message.serverContent?.modelTurn?.parts?.some((part) => part.inlineData?.data),
                  hasTranscription: !!message.serverContent?.outputTranscription,
                  interrupted: !!message.serverContent?.interrupted
                });
                debugLog("[Gemini Live Audio] Received message:", {
                  hasModelTurn: !!message.serverContent?.modelTurn,
                  hasParts: !!message.serverContent?.modelTurn?.parts,
                  turnComplete: message.serverContent?.turnComplete,
                  setupComplete: !!message.setupComplete
                });
                if (message.setupComplete) {
                  console.log("\u{1F3AF} [Gemini Session] SETUP COMPLETED - Session ready for audio input");
                  debugLog("[Gemini Live Audio] Setup completed, session is ready");
                  this.sessionConnected = true;
                }
                this.handleServerMessage(message);
              },
              onerror: (e) => {
                console.error("\u274C [Gemini Session] ERROR:", e.message);
                console.error("[Gemini Live Audio] Error:", e.message);
                this.sessionConnected = false;
                if (e.message.includes("quota") || e.message.includes("exceeded")) {
                  console.error("[Gemini Live Audio] API quota exceeded - translation service temporarily unavailable");
                  this.config.onError?.(new Error("API quota exceeded. Please try again later or check your Gemini API billing settings."));
                } else if (e.message.includes("API key expired") || e.message.includes("expired")) {
                  console.error("[Gemini Live Audio] API key expired - please renew your API key");
                  this.config.onError?.(new Error("API key expired. Please renew your Gemini API key in the settings."));
                } else {
                  this.config.onError?.(new Error(e.message));
                }
              },
              onclose: (e) => {
                console.log("\u{1F50C} [Gemini Session] CONNECTION CLOSED:", e.reason || "No reason provided");
                debugLog("[Gemini Live Audio] Session closed:", e.reason);
                this.sessionConnected = false;
                if (e.reason && (e.reason.includes("quota") || e.reason.includes("exceeded"))) {
                  console.error("[Gemini Live Audio] Session closed due to quota limit");
                  this.config.onError?.(new Error("API quota exceeded. Gemini API usage limit has been reached."));
                } else if (e.reason && (e.reason.includes("API key expired") || e.reason.includes("expired"))) {
                  console.error("[Gemini Live Audio] Session closed due to expired API key");
                  this.config.onError?.(new Error("API key expired. Please renew your Gemini API key in the settings."));
                } else if (e.reason && e.reason.includes("API key")) {
                  console.error("[Gemini Live Audio] Session closed due to API key issue");
                  this.config.onError?.(new Error("API key error. Please check your Gemini API key in the settings."));
                }
              }
            },
            config
          });
          debugLog("[Gemini Live Audio] Session initialized, waiting for setup completion...");
          this.sessionConnected = true;
        }
        async setupAudioProcessing() {
          if (!this.inputAudioContext || !this.mediaStream) return;
          debugLog("[Gemini Live Audio] Setting up audio processing pipeline...");
          this.sourceNode = this.inputAudioContext.createMediaStreamSource(this.mediaStream);
          this.sourceNode.connect(this.inputNode);
          try {
            await this.inputAudioContext.audioWorklet.addModule("/audio-capture-processor.js");
            const audioWorkletNode = new AudioWorkletNode(this.inputAudioContext, "audio-capture-processor");
            audioWorkletNode.port.onmessage = (event) => {
              if (!this.isProcessing || !this.session || !this.sessionConnected) return;
              const pcmData = event.data;
              this.audioBuffer.push(new Float32Array(pcmData));
              const currentTime = Date.now();
              if (currentTime - this.lastSendTime >= this.sendInterval) {
                this.sendBufferedAudio();
                this.lastSendTime = currentTime;
              }
            };
            this.sourceNode.connect(audioWorkletNode);
            audioWorkletNode.connect(this.inputAudioContext.destination);
            this.scriptProcessor = audioWorkletNode;
          } catch (workletError) {
            debugWarn("[Gemini Live Audio] AudioWorklet not supported, falling back to ScriptProcessorNode");
            const bufferSize = 256;
            this.scriptProcessor = this.inputAudioContext.createScriptProcessor(bufferSize, 1, 1);
            this.scriptProcessor.onaudioprocess = (event) => {
              if (!this.isProcessing || !this.session || !this.sessionConnected) return;
              const inputBuffer = event.inputBuffer;
              const pcmData = inputBuffer.getChannelData(0);
              this.audioBuffer.push(new Float32Array(pcmData));
              const currentTime = Date.now();
              if (currentTime - this.lastSendTime >= this.sendInterval) {
                this.sendBufferedAudio();
                this.lastSendTime = currentTime;
              }
            };
            this.sourceNode.connect(this.scriptProcessor);
            this.scriptProcessor.connect(this.inputAudioContext.destination);
          }
          this.isProcessing = true;
          debugLog("[Gemini Live Audio] Audio processing pipeline ready");
        }
        // Gemini 2.5 Flash Native Audio pricing (per 1M tokens) - Updated December 2024
        static PRICING = {
          INPUT_AUDIO_PER_SECOND: 3e-6,
          // $3.00 per 1M tokens, ~1 token per second of audio
          OUTPUT_AUDIO_PER_SECOND: 12e-6,
          // $12.00 per 1M tokens, ~1 token per second of audio
          INPUT_TEXT_PER_TOKEN: 5e-7,
          // $0.50 per 1M tokens (text)
          OUTPUT_TEXT_PER_TOKEN: 2e-6
          // $2.00 per 1M tokens (text, including thinking tokens)
        };
        calculateAudioTokens(audioLengthSeconds) {
          return Math.ceil(audioLengthSeconds);
        }
        calculateTextTokens(text) {
          return Math.ceil(text.length / 4);
        }
        updateTokenUsage(inputAudioSeconds = 0, outputAudioSeconds = 0, outputText = "") {
          const inputTokens = this.calculateAudioTokens(inputAudioSeconds);
          const outputAudioTokens = this.calculateAudioTokens(outputAudioSeconds);
          const outputTextTokens = this.calculateTextTokens(outputText);
          const totalOutputTokens = outputAudioTokens + outputTextTokens;
          const inputCost = inputTokens * _GeminiLiveAudioStream.PRICING.INPUT_AUDIO_PER_SECOND;
          const outputAudioCost = outputAudioTokens * _GeminiLiveAudioStream.PRICING.OUTPUT_AUDIO_PER_SECOND;
          const outputTextCost = outputTextTokens * _GeminiLiveAudioStream.PRICING.OUTPUT_TEXT_PER_TOKEN;
          const totalCost = inputCost + outputAudioCost + outputTextCost;
          this.sessionInputTokens += inputTokens;
          this.sessionOutputTokens += totalOutputTokens;
          this.sessionCost += totalCost;
          debugLog(`[Gemini Live Audio] Token usage - Input: ${inputTokens}, Output: ${totalOutputTokens}, Cost: $${totalCost.toFixed(6)}`);
          debugLog(`[Gemini Live Audio] Session total - Input: ${this.sessionInputTokens}, Output: ${this.sessionOutputTokens}, Cost: $${this.sessionCost.toFixed(6)}`);
          this.config.onTokenUsage?.({
            inputTokens: this.sessionInputTokens,
            outputTokens: this.sessionOutputTokens,
            cost: this.sessionCost
          });
        }
        sendBufferedAudio() {
          if (!this.session || this.audioBuffer.length === 0 || !this.sessionConnected) return;
          if (!this.sessionConnected) {
            debugLog("[Gemini Live Audio] Session not connected, stopping audio send");
            this.isProcessing = false;
            this.audioBuffer = [];
            return;
          }
          try {
            const totalLength = this.audioBuffer.reduce((sum, buf) => sum + buf.length, 0);
            const combinedBuffer = new Float32Array(totalLength);
            let offset = 0;
            for (const buffer of this.audioBuffer) {
              combinedBuffer.set(buffer, offset);
              offset += buffer.length;
            }
            const base64Audio = float32ToBase64PCM(combinedBuffer);
            const audioLengthSeconds = totalLength / 16e3;
            console.log(`\u{1F3A4} [Audio Input] SENDING ${totalLength} samples (${audioLengthSeconds.toFixed(2)}s) to Gemini`);
            debugLog(`[Gemini Live Audio] Sending buffered audio: ${totalLength} samples (${audioLengthSeconds.toFixed(2)}s)`);
            if (!this.session || !this.sessionConnected) {
              console.warn("\u26A0\uFE0F [Audio Input] Session not connected, skipping audio send");
              debugWarn("[Gemini Live Audio] Session not connected, skipping audio send");
              this.audioBuffer = [];
              return;
            }
            this.session.sendRealtimeInput({
              audio: {
                data: base64Audio,
                mimeType: "audio/pcm;rate=16000"
              }
            });
            console.log("\u2705 [Audio Input] Successfully sent audio to Gemini Live API");
            this.updateTokenUsage(audioLengthSeconds);
            this.audioBuffer = [];
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error("\u274C [Audio Input] Error sending buffered audio:", errorMessage);
            if (errorMessage.includes("CLOSING") || errorMessage.includes("CLOSED") || errorMessage.includes("quota") || errorMessage.includes("WebSocket")) {
              console.log("\u{1F50C} [Audio Input] Session closed during send - stopping audio processing");
              debugLog("[Gemini Live Audio] Session closed during buffered send, stopping");
              this.isProcessing = false;
              this.sessionConnected = false;
              this.audioBuffer = [];
              if (this.scriptProcessor) {
                this.scriptProcessor.disconnect();
                this.scriptProcessor = null;
              }
            } else {
              console.error("[Gemini Live Audio] Error sending buffered audio:", error);
            }
          }
        }
        getSystemInstruction() {
          const isSystemAssistantMode = this.config.targetLanguage === "System Assistant";
          if (isSystemAssistantMode) {
            const getSystemAssistantPrompt = (userLanguage) => {
              const languageMap = {
                "japanese": `\u3042\u306A\u305F\u306Fotak-conference\u30B7\u30B9\u30C6\u30E0\u306E\u30A2\u30B7\u30B9\u30BF\u30F3\u30C8\u3067\u3059\u3002otak-conference\u306F\u3001\u30EA\u30A2\u30EB\u30BF\u30A4\u30E0\u591A\u8A00\u8A9E\u7FFB\u8A33\u4F1A\u8B70\u30B7\u30B9\u30C6\u30E0\u3067\u3059\u3002

\u4E3B\u306A\u6A5F\u80FD\uFF1A
\u2022 \u30EA\u30A2\u30EB\u30BF\u30A4\u30E0\u97F3\u58F0\u7FFB\u8A33\uFF1A3\u8A00\u8A9E\uFF08\u65E5\u672C\u8A9E\u3001\u82F1\u8A9E\u3001\u30D9\u30C8\u30CA\u30E0\u8A9E\uFF09\u306B\u5BFE\u5FDC\u3057\u3001\u53C2\u52A0\u8005\u306E\u767A\u8A00\u3092\u5373\u5EA7\u306B\u7FFB\u8A33
\u2022 WebRTC\u306B\u3088\u308B\u9AD8\u54C1\u8CEA\u306A\u97F3\u58F0\u30FB\u30D3\u30C7\u30AA\u901A\u8A71
\u2022 \u753B\u9762\u5171\u6709\u6A5F\u80FD
\u2022 \u30C1\u30E3\u30C3\u30C8\u6A5F\u80FD\uFF08\u65E2\u8AAD\u6A5F\u80FD\u4ED8\u304D\uFF09
\u2022 \u30EA\u30A2\u30AF\u30B7\u30E7\u30F3\u6A5F\u80FD\uFF08\u{1F44D}\u2764\uFE0F\u{1F60A}\u{1F44F}\u{1F389}\uFF09
\u2022 \u6319\u624B\u6A5F\u80FD
\u2022 \u30AB\u30E1\u30E9\u30A8\u30D5\u30A7\u30AF\u30C8\uFF08\u80CC\u666F\u307C\u304B\u3057\u3001\u7F8E\u808C\u30E2\u30FC\u30C9\u3001\u660E\u308B\u3055\u8ABF\u6574\uFF09
\u2022 \u97F3\u58F0\u30C7\u30D0\u30A4\u30B9\u9078\u629E

\u4F7F\u3044\u65B9\uFF1A
1. \u8A2D\u5B9A\u753B\u9762\u3067\u540D\u524D\u3068Gemini API\u30AD\u30FC\u3092\u5165\u529B
2. \u8A00\u8A9E\u3092\u9078\u629E\uFF08\u65E5\u672C\u8A9E\u3001\u82F1\u8A9E\u3001\u30D9\u30C8\u30CA\u30E0\u8A9E\u304B\u3089\u9078\u629E\u53EF\u80FD\uFF09
3. \u300CStart Conference\u300D\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u4F1A\u8B70\u3092\u958B\u59CB
4. URL\u3092\u5171\u6709\u3057\u3066\u4ED6\u306E\u53C2\u52A0\u8005\u3092\u62DB\u5F85

\u30E6\u30FC\u30B6\u30FC\u306E\u8CEA\u554F\u306B\u65E5\u672C\u8A9E\u3067\u4E01\u5BE7\u306B\u7B54\u3048\u3066\u304F\u3060\u3055\u3044\u3002`,
                "english": `You are the otak-conference system assistant. otak-conference is a real-time multilingual translation conference system.

Key Features:
\u2022 Real-time voice translation: Supports 3 languages (Japanese, English, Vietnamese) with instant translation
\u2022 High-quality audio/video calls using WebRTC
\u2022 Screen sharing capability
\u2022 Chat function with read receipts
\u2022 Reaction features (\u{1F44D}\u2764\uFE0F\u{1F60A}\u{1F44F}\u{1F389})
\u2022 Hand raise function
\u2022 Camera effects (background blur, beauty mode, brightness adjustment)
\u2022 Audio device selection

How to Use:
1. Enter your name and Gemini API key in settings
2. Select your language (Japanese, English, Vietnamese available)
3. Click "Start Conference" to begin
4. Share the URL to invite other participants

Please answer user questions politely in English.`,
                "vietnamese": `B\u1EA1n l\xE0 tr\u1EE3 l\xFD h\u1EC7 th\u1ED1ng otak-conference. otak-conference l\xE0 h\u1EC7 th\u1ED1ng h\u1ED9i ngh\u1ECB d\u1ECBch \u0111a ng\xF4n ng\u1EEF th\u1EDDi gian th\u1EF1c.

T\xEDnh n\u0103ng ch\xEDnh:
\u2022 D\u1ECBch gi\u1ECDng n\xF3i th\u1EDDi gian th\u1EF1c: H\u1ED7 tr\u1EE3 3 ng\xF4n ng\u1EEF (ti\u1EBFng Nh\u1EADt, ti\u1EBFng Anh, ti\u1EBFng Vi\u1EC7t) v\u1EDBi d\u1ECBch thu\u1EADt t\u1EE9c th\xEC
\u2022 Cu\u1ED9c g\u1ECDi \xE2m thanh/video ch\u1EA5t l\u01B0\u1EE3ng cao s\u1EED d\u1EE5ng WebRTC
\u2022 Kh\u1EA3 n\u0103ng chia s\u1EBB m\xE0n h\xECnh
\u2022 Ch\u1EE9c n\u0103ng tr\xF2 chuy\u1EC7n v\u1EDBi x\xE1c nh\u1EADn \u0111\xE3 \u0111\u1ECDc
\u2022 T\xEDnh n\u0103ng ph\u1EA3n \u1EE9ng (\u{1F44D}\u2764\uFE0F\u{1F60A}\u{1F44F}\u{1F389})
\u2022 Ch\u1EE9c n\u0103ng gi\u01A1 tay
\u2022 Hi\u1EC7u \u1EE9ng camera (l\xE0m m\u1EDD n\u1EC1n, ch\u1EBF \u0111\u1ED9 l\xE0m \u0111\u1EB9p, \u0111i\u1EC1u ch\u1EC9nh \u0111\u1ED9 s\xE1ng)
\u2022 L\u1EF1a ch\u1ECDn thi\u1EBFt b\u1ECB \xE2m thanh

C\xE1ch s\u1EED d\u1EE5ng:
1. Nh\u1EADp t\xEAn v\xE0 kh\xF3a API Gemini trong c\xE0i \u0111\u1EB7t
2. Ch\u1ECDn ng\xF4n ng\u1EEF c\u1EE7a b\u1EA1n (ti\u1EBFng Nh\u1EADt, ti\u1EBFng Anh, ti\u1EBFng Vi\u1EC7t c\xF3 s\u1EB5n)
3. Nh\u1EA5p "Start Conference" \u0111\u1EC3 b\u1EAFt \u0111\u1EA7u
4. Chia s\u1EBB URL \u0111\u1EC3 m\u1EDDi ng\u01B0\u1EDDi tham gia kh\xE1c

Vui l\xF2ng tr\u1EA3 l\u1EDDi c\xE2u h\u1ECFi c\u1EE7a ng\u01B0\u1EDDi d\xF9ng m\u1ED9t c\xE1ch l\u1ECBch s\u1EF1 b\u1EB1ng ti\u1EBFng Vi\u1EC7t.`,
                "chinese": `\u60A8\u662Fotak-conference\u7CFB\u7EDF\u52A9\u624B\u3002otak-conference\u662F\u4E00\u4E2A\u5B9E\u65F6\u591A\u8BED\u8A00\u7FFB\u8BD1\u4F1A\u8BAE\u7CFB\u7EDF\u3002

\u4E3B\u8981\u529F\u80FD\uFF1A
\u2022 \u5B9E\u65F6\u8BED\u97F3\u7FFB\u8BD1\uFF1A\u652F\u630125\u79CD\u8BED\u8A00\u7684\u5373\u65F6\u7FFB\u8BD1
\u2022 \u4F7F\u7528WebRTC\u7684\u9AD8\u8D28\u91CF\u97F3\u89C6\u9891\u901A\u8BDD
\u2022 \u5C4F\u5E55\u5171\u4EAB\u529F\u80FD
\u2022 \u5E26\u5DF2\u8BFB\u56DE\u6267\u7684\u804A\u5929\u529F\u80FD
\u2022 \u53CD\u5E94\u529F\u80FD\uFF08\u{1F44D}\u2764\uFE0F\u{1F60A}\u{1F44F}\u{1F389}\uFF09
\u2022 \u4E3E\u624B\u529F\u80FD
\u2022 \u76F8\u673A\u6548\u679C\uFF08\u80CC\u666F\u6A21\u7CCA\u3001\u7F8E\u989C\u6A21\u5F0F\u3001\u4EAE\u5EA6\u8C03\u6574\uFF09
\u2022 \u97F3\u9891\u8BBE\u5907\u9009\u62E9

\u4F7F\u7528\u65B9\u6CD5\uFF1A
1. \u5728\u8BBE\u7F6E\u4E2D\u8F93\u5165\u60A8\u7684\u59D3\u540D\u548CGemini API\u5BC6\u94A5
2. \u9009\u62E9\u60A8\u7684\u8BED\u8A00\uFF0825\u79CD\u8BED\u8A00\u53EF\u9009\uFF09
3. \u70B9\u51FB"Start Conference"\u5F00\u59CB\u4F1A\u8BAE
4. \u5206\u4EABURL\u9080\u8BF7\u5176\u4ED6\u53C2\u4E0E\u8005

\u8BF7\u7528\u4E2D\u6587\u793C\u8C8C\u5730\u56DE\u7B54\u7528\u6237\u7684\u95EE\u9898\u3002`,
                "korean": `\uB2F9\uC2E0\uC740 otak-conference \uC2DC\uC2A4\uD15C \uC5B4\uC2DC\uC2A4\uD134\uD2B8\uC785\uB2C8\uB2E4. otak-conference\uB294 \uC2E4\uC2DC\uAC04 \uB2E4\uAD6D\uC5B4 \uBC88\uC5ED \uD68C\uC758 \uC2DC\uC2A4\uD15C\uC785\uB2C8\uB2E4.

\uC8FC\uC694 \uAE30\uB2A5:
\u2022 \uC2E4\uC2DC\uAC04 \uC74C\uC131 \uBC88\uC5ED: 25\uAC1C \uC5B8\uC5B4 \uC9C0\uC6D0 \uBC0F \uC989\uC2DC \uBC88\uC5ED
\u2022 WebRTC\uB97C \uC0AC\uC6A9\uD55C \uACE0\uD488\uC9C8 \uC74C\uC131/\uBE44\uB514\uC624 \uD1B5\uD654
\u2022 \uD654\uBA74 \uACF5\uC720 \uAE30\uB2A5
\u2022 \uC77D\uC74C \uD655\uC778 \uAE30\uB2A5\uC774 \uC788\uB294 \uCC44\uD305
\u2022 \uBC18\uC751 \uAE30\uB2A5 (\u{1F44D}\u2764\uFE0F\u{1F60A}\u{1F44F}\u{1F389})
\u2022 \uC190\uB4E4\uAE30 \uAE30\uB2A5
\u2022 \uCE74\uBA54\uB77C \uD6A8\uACFC (\uBC30\uACBD \uD750\uB9BC, \uBDF0\uD2F0 \uBAA8\uB4DC, \uBC1D\uAE30 \uC870\uC815)
\u2022 \uC624\uB514\uC624 \uC7A5\uCE58 \uC120\uD0DD

\uC0AC\uC6A9 \uBC29\uBC95:
1. \uC124\uC815\uC5D0\uC11C \uC774\uB984\uACFC Gemini API \uD0A4 \uC785\uB825
2. \uC5B8\uC5B4 \uC120\uD0DD (25\uAC1C \uC5B8\uC5B4 \uC0AC\uC6A9 \uAC00\uB2A5)
3. "Start Conference"\uB97C \uD074\uB9AD\uD558\uC5EC \uD68C\uC758 \uC2DC\uC791
4. URL\uC744 \uACF5\uC720\uD558\uC5EC \uB2E4\uB978 \uCC38\uAC00\uC790 \uCD08\uB300

\uD55C\uAD6D\uC5B4\uB85C \uC815\uC911\uD558\uAC8C \uC0AC\uC6A9\uC790\uC758 \uC9C8\uBB38\uC5D0 \uB2F5\uBCC0\uD574 \uC8FC\uC138\uC694.`,
                "spanish": `Eres el asistente del sistema otak-conference. otak-conference es un sistema de conferencias con traducci\xF3n multiling\xFCe en tiempo real.

Caracter\xEDsticas principales:
\u2022 Traducci\xF3n de voz en tiempo real: Soporta 25 idiomas con traducci\xF3n instant\xE1nea
\u2022 Llamadas de audio/video de alta calidad usando WebRTC
\u2022 Capacidad de compartir pantalla
\u2022 Funci\xF3n de chat con confirmaci\xF3n de lectura
\u2022 Funciones de reacci\xF3n (\u{1F44D}\u2764\uFE0F\u{1F60A}\u{1F44F}\u{1F389})
\u2022 Funci\xF3n de levantar la mano
\u2022 Efectos de c\xE1mara (desenfoque de fondo, modo belleza, ajuste de brillo)
\u2022 Selecci\xF3n de dispositivo de audio

C\xF3mo usar:
1. Ingrese su nombre y clave API de Gemini en configuraci\xF3n
2. Seleccione su idioma (25 idiomas disponibles)
3. Haga clic en "Start Conference" para comenzar
4. Comparta la URL para invitar a otros participantes

Por favor responda las preguntas del usuario cort\xE9smente en espa\xF1ol.`,
                "french": `Vous \xEAtes l'assistant du syst\xE8me otak-conference. otak-conference est un syst\xE8me de conf\xE9rence avec traduction multilingue en temps r\xE9el.

Fonctionnalit\xE9s principales :
\u2022 Traduction vocale en temps r\xE9el : Prend en charge 25 langues avec traduction instantan\xE9e
\u2022 Appels audio/vid\xE9o de haute qualit\xE9 utilisant WebRTC
\u2022 Capacit\xE9 de partage d'\xE9cran
\u2022 Fonction de chat avec accus\xE9s de lecture
\u2022 Fonctions de r\xE9action (\u{1F44D}\u2764\uFE0F\u{1F60A}\u{1F44F}\u{1F389})
\u2022 Fonction lever la main
\u2022 Effets de cam\xE9ra (flou d'arri\xE8re-plan, mode beaut\xE9, r\xE9glage de la luminosit\xE9)
\u2022 S\xE9lection du p\xE9riph\xE9rique audio

Comment utiliser :
1. Entrez votre nom et la cl\xE9 API Gemini dans les param\xE8tres
2. S\xE9lectionnez votre langue (25 langues disponibles)
3. Cliquez sur "Start Conference" pour commencer
4. Partagez l'URL pour inviter d'autres participants

Veuillez r\xE9pondre poliment aux questions de l'utilisateur en fran\xE7ais.`
              };
              return languageMap[userLanguage.toLowerCase()] || languageMap["english"];
            };
            return getSystemAssistantPrompt(this.config.sourceLanguage.toLowerCase());
          } else {
            if (this.config.usePeerTranslation && this.config.otherParticipantLanguages && this.config.otherParticipantLanguages.length > 0) {
              const targetLanguage = this.config.otherParticipantLanguages[0];
              debugLog(`[Gemini Live Audio] Using peer translation mode: ${this.config.sourceLanguage} \u2192 ${targetLanguage}`);
              return createPeerTranslationSystemPrompt(this.config.sourceLanguage, targetLanguage);
            } else {
              const getTranslationInstruction = (sourceLanguage, targetLanguage) => {
                if (sourceLanguage === "japanese" && targetLanguage === "vietnamese") {
                  return "\u8CB4\u65B9\u306F\u30D7\u30ED\u306E\u901A\u8A33\u3067\u3059\u3002\u65E5\u672C\u8A9E\u304B\u3089\u30D9\u30C8\u30CA\u30E0\u8A9E\u306B\u901A\u8A33\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u7FFB\u8A33\u5F8C\u306E\u5185\u5BB9\u3060\u3051\u51FA\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002";
                } else if (sourceLanguage === "vietnamese" && targetLanguage === "japanese") {
                  return "B\u1EA1n l\xE0 phi\xEAn d\u1ECBch vi\xEAn chuy\xEAn nghi\u1EC7p. H\xE3y d\u1ECBch t\u1EEB ti\u1EBFng Vi\u1EC7t sang ti\u1EBFng Nh\u1EADt. Ch\u1EC9 xu\u1EA5t n\u1ED9i dung sau khi d\u1ECBch.";
                } else if (sourceLanguage === "japanese" && targetLanguage === "english") {
                  return "\u8CB4\u65B9\u306F\u30D7\u30ED\u306E\u901A\u8A33\u3067\u3059\u3002\u65E5\u672C\u8A9E\u304B\u3089\u82F1\u8A9E\u306B\u901A\u8A33\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u7FFB\u8A33\u5F8C\u306E\u5185\u5BB9\u3060\u3051\u51FA\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002";
                } else if (sourceLanguage === "english" && targetLanguage === "japanese") {
                  return "You are a professional interpreter. Please translate from English to Japanese. Output only the translated content.";
                } else if (sourceLanguage === "vietnamese" && targetLanguage === "english") {
                  return "B\u1EA1n l\xE0 phi\xEAn d\u1ECBch vi\xEAn chuy\xEAn nghi\u1EC7p. H\xE3y d\u1ECBch t\u1EEB ti\u1EBFng Vi\u1EC7t sang ti\u1EBFng Anh. Ch\u1EC9 xu\u1EA5t n\u1ED9i dung sau khi d\u1ECBch.";
                } else if (sourceLanguage === "english" && targetLanguage === "vietnamese") {
                  return "You are a professional interpreter. Please translate from English to Vietnamese. Output only the translated content.";
                } else {
                  return `You are a professional interpreter. Please translate from ${sourceLanguage} to ${targetLanguage}. Output only the translated content.`;
                }
              };
              return getTranslationInstruction(this.config.sourceLanguage, this.config.targetLanguage);
            }
          }
        }
        sendInitialPrompt() {
          debugLog("[Gemini Live Audio] System instruction already set during session initialization");
        }
        // Removed sendAudioChunk method - now using direct streaming in setupAudioProcessing
        float32ToPCM16(float32Array) {
          const pcm16 = new Int16Array(float32Array.length);
          for (let i = 0; i < float32Array.length; i++) {
            const sample = Math.max(-1, Math.min(1, float32Array[i]));
            pcm16[i] = sample < 0 ? sample * 32768 : sample * 32767;
          }
          return pcm16;
        }
        arrayBufferToBase64(buffer) {
          const bytes = new Uint8Array(buffer);
          let binary = "";
          for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        }
        // Audio data accumulation for complete turn processing
        audioChunks = [];
        isCollectingAudio = false;
        // Text buffering for complete sentence processing
        textBuffer = [];
        lastTextTime = 0;
        textBufferTimeout = null;
        textBufferDelay = 2e3;
        // Default: 2
        handleServerMessage(message) {
          if (message.serverContent?.modelTurn && !this.isCollectingAudio) {
            console.log("\u{1F504} [Gemini Output] Starting new turn - collecting response");
            this.isCollectingAudio = true;
            this.audioChunks = [];
            debugLog("[Gemini Live Audio] Starting audio collection for new turn");
          }
          if (message.serverContent?.modelTurn?.parts) {
            for (const part of message.serverContent.modelTurn.parts) {
              if (part.inlineData?.data && part.inlineData.mimeType?.includes("audio")) {
                console.log("\u{1F3B5} [Audio Output] AUDIO CHUNK RECEIVED from Gemini");
                console.log(`\u{1F4CA} [Audio Output] Chunk size: ${part.inlineData.data.length} characters (base64)`);
                this.audioChunks.push(part.inlineData.data);
                debugLog(`[Gemini Live Audio] Collected audio chunk: ${part.inlineData.data.length} chars`);
              }
            }
          }
          if (message.serverContent?.turnComplete && this.isCollectingAudio) {
            console.log(`\u{1F3C1} [Gemini Output] TURN COMPLETE - Processing ${this.audioChunks.length} audio chunks`);
            debugLog(`[Gemini Live Audio] Turn complete, processing ${this.audioChunks.length} audio chunks`);
            this.isCollectingAudio = false;
            this.flushTextBuffer();
            if (this.audioChunks.length > 0) {
              this.processCompleteAudioTurn(this.audioChunks);
              this.audioChunks = [];
            } else {
              console.warn("\u26A0\uFE0F [Gemini Output] Turn complete but no audio chunks received");
            }
          }
          const interrupted = message.serverContent?.interrupted;
          if (interrupted) {
            console.log("\u{1F6D1} [Gemini Output] INTERRUPTION SIGNAL received");
            debugLog("[Gemini Live Audio] Received interruption signal");
            this.isCollectingAudio = false;
            this.audioChunks = [];
            this.textBuffer = [];
            if (this.textBufferTimeout) {
              clearTimeout(this.textBufferTimeout);
              this.textBufferTimeout = null;
            }
            for (const source of this.sources.values()) {
              source.stop();
              this.sources.delete(source);
            }
            this.nextStartTime = 0;
          }
          if (message.serverContent?.outputTranscription) {
            const transcriptText = message.serverContent.outputTranscription.text;
            if (transcriptText) {
              console.log("\u{1F4DD} [Text Buffer] TRANSCRIPT CHUNK RECEIVED:", transcriptText);
              this.textBuffer.push(transcriptText);
              this.lastTextTime = Date.now();
              if (this.textBufferTimeout) {
                clearTimeout(this.textBufferTimeout);
              }
              this.textBufferTimeout = setTimeout(() => {
                this.flushTextBuffer();
              }, this.textBufferDelay);
              console.log(`\u{1F4CA} [Text Buffer] Buffered ${this.textBuffer.length} text chunks`);
            }
          }
          this.handleTextResponse(message);
        }
        /**
         * Flush accumulated text buffer and send to callback
         */
        flushTextBuffer() {
          if (this.textBuffer.length === 0) return;
          const combinedText = this.textBuffer.join(" ").trim();
          if (combinedText) {
            console.log("\u{1F4DD} [Text Buffer] FLUSHING BUFFERED TEXT:", combinedText);
            console.log(`\u{1F4CA} [Text Buffer] Combined ${this.textBuffer.length} chunks into single message`);
            this.updateTokenUsage(0, 0, combinedText);
            console.log("\u{1F4DE} [Callback] Calling onTextReceived with buffered text...");
            this.config.onTextReceived?.(combinedText);
            console.log("\u2705 [Callback] onTextReceived completed for buffered text");
          }
          this.textBuffer = [];
          if (this.textBufferTimeout) {
            clearTimeout(this.textBufferTimeout);
            this.textBufferTimeout = null;
          }
        }
        /**
         * Process complete audio turn by combining chunks and creating WAV file
         * Following Google's pattern for handling complete audio responses
         */
        async processCompleteAudioTurn(audioChunks) {
          try {
            console.log(`\u{1F527} [Audio Processing] Starting optimized audio processing: ${audioChunks.length} chunks`);
            debugLog(`[Gemini Live Audio] Processing complete audio turn with ${audioChunks.length} chunks`);
            if (audioChunks.length === 0) {
              console.warn("\u26A0\uFE0F [Audio Processing] No audio chunks to process");
              debugWarn("[Gemini Live Audio] No audio chunks to process");
              return;
            }
            let totalSamples = 0;
            const decodedChunks = [];
            for (let i = 0; i < audioChunks.length; i++) {
              const chunk = audioChunks[i];
              console.log(`\u{1F4E6} [Audio Processing] Processing chunk ${i + 1}/${audioChunks.length}: ${chunk.length} chars`);
              const buffer = decode(chunk);
              const intArray = new Int16Array(buffer);
              decodedChunks.push(intArray);
              totalSamples += intArray.length;
              console.log(`\u{1F522} [Audio Processing] Chunk ${i + 1} decoded: ${intArray.length} samples`);
            }
            if (totalSamples === 0) {
              console.warn("\u26A0\uFE0F [Audio Processing] No audio data to process - empty chunks");
              debugWarn("[Gemini Live Audio] No audio data to process");
              return;
            }
            const audioBuffer = new Int16Array(totalSamples);
            let offset = 0;
            for (const chunk of decodedChunks) {
              audioBuffer.set(chunk, offset);
              offset += chunk.length;
            }
            console.log(`\u{1F3B5} [Audio Processing] Combined audio buffer: ${audioBuffer.length} samples`);
            debugLog(`[Gemini Live Audio] Combined audio buffer: ${audioBuffer.length} samples`);
            console.log("\u{1F3BC} [Audio Processing] Creating WAV file (24kHz, mono)...");
            const wavData = this.createWavFile(audioBuffer, 24e3, 1);
            console.log(`\u{1F4C1} [Audio Processing] WAV file created: ${wavData.byteLength} bytes`);
            const audioDurationSeconds = audioBuffer.length / 24e3;
            console.log(`\u23F1\uFE0F [Audio Processing] Audio duration: ${audioDurationSeconds.toFixed(2)}s`);
            if (this.localPlaybackEnabled && this.outputAudioContext) {
              console.log("\u{1F50A} [Audio Playback] Playing audio locally...");
              await this.playWavAudio(wavData);
              console.log(`\u2705 [Audio Playback] Local playback completed: ${audioDurationSeconds.toFixed(2)}s`);
              debugLog(`[Gemini Live Audio] Playing combined audio locally: ${audioDurationSeconds.toFixed(2)}s`);
            } else {
              console.log(`\u{1F507} [Audio Playback] Skipping local playback (disabled): ${audioDurationSeconds.toFixed(2)}s`);
              debugLog(`[Gemini Live Audio] Skipping local playback: ${audioDurationSeconds.toFixed(2)}s`);
            }
            this.updateTokenUsage(0, audioDurationSeconds);
            console.log("\u{1F4E1} [Audio Distribution] Calling onAudioReceived callback...");
            this.config.onAudioReceived?.(wavData.slice(0));
            console.log("\u2705 [Audio Distribution] Audio distribution completed");
          } catch (error) {
            console.error("\u274C [Audio Processing] Failed to process complete audio turn:", error);
            console.error("[Gemini Live Audio] Failed to process complete audio turn:", error);
            debugError("[Gemini Live Audio] Error details:", error);
          }
        }
        /**
         * Create WAV file from PCM audio data
         * Based on the pattern from Google's documentation
         */
        createWavFile(audioData, sampleRate, channels) {
          const byteRate = sampleRate * channels * 2;
          const blockAlign = channels * 2;
          const dataSize = audioData.length * 2;
          const fileSize = 44 + dataSize;
          const buffer = new ArrayBuffer(fileSize);
          const view = new DataView(buffer);
          const writeString = (offset, string) => {
            for (let i = 0; i < string.length; i++) {
              view.setUint8(offset + i, string.charCodeAt(i));
            }
          };
          writeString(0, "RIFF");
          view.setUint32(4, fileSize - 8, true);
          writeString(8, "WAVE");
          writeString(12, "fmt ");
          view.setUint32(16, 16, true);
          view.setUint16(20, 1, true);
          view.setUint16(22, channels, true);
          view.setUint32(24, sampleRate, true);
          view.setUint32(28, byteRate, true);
          view.setUint16(32, blockAlign, true);
          view.setUint16(34, 16, true);
          writeString(36, "data");
          view.setUint32(40, dataSize, true);
          const audioView = new Int16Array(buffer, 44);
          audioView.set(audioData);
          return buffer;
        }
        /**
         * Play WAV audio data using Web Audio API
         */
        async playWavAudio(wavData) {
          if (!this.outputAudioContext || !this.outputNode) return;
          try {
            const audioBuffer = await this.outputAudioContext.decodeAudioData(wavData.slice(0));
            const source = this.outputAudioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(this.outputNode);
            source.addEventListener("ended", () => {
              this.sources.delete(source);
            });
            this.nextStartTime = Math.max(
              this.nextStartTime,
              this.outputAudioContext.currentTime
            );
            source.start(this.nextStartTime);
            this.nextStartTime = this.nextStartTime + audioBuffer.duration;
            this.sources.add(source);
          } catch (error) {
            console.error("[Gemini Live Audio] Failed to play WAV audio:", error);
          }
        }
        // Method to handle handleServerMessage text processing
        handleTextResponse(message) {
          console.log("\u{1F50D} [Text Analysis] Analyzing message for text content:", {
            hasServerContent: !!message.serverContent,
            hasModelTurn: !!message.serverContent?.modelTurn,
            hasParts: !!message.serverContent?.modelTurn?.parts,
            partsLength: message.serverContent?.modelTurn?.parts?.length || 0,
            hasOutputTranscription: !!message.serverContent?.outputTranscription
          });
          if (message.serverContent?.modelTurn?.parts) {
            console.log(`\u{1F4DD} [Text Analysis] Processing ${message.serverContent.modelTurn.parts.length} parts`);
            for (let i = 0; i < message.serverContent.modelTurn.parts.length; i++) {
              const part = message.serverContent.modelTurn.parts[i];
              console.log(`\u{1F50D} [Text Analysis] Part ${i + 1}:`, {
                hasText: !!part.text,
                hasInlineData: !!part.inlineData,
                textContent: part.text ? `"${part.text.substring(0, 100)}${part.text.length > 100 ? "..." : ""}"` : "No text",
                textLength: part.text?.length || 0
              });
              if (part.text) {
                console.log("\u2705 [Text Output] TEXT RESPONSE RECEIVED from Gemini:");
                console.log(`\u{1F4C4} [Text Output] Content: "${part.text}"`);
                console.log(`\u{1F4CF} [Text Output] Length: ${part.text.length} characters`);
                debugLog("[Gemini Live Audio] Received translated text:", part.text);
                this.updateTokenUsage(0, 0, part.text);
                console.log("\u{1F4DE} [Callback] Calling onTextReceived callback with text response...");
                this.config.onTextReceived?.(part.text);
                console.log("\u2705 [Callback] onTextReceived callback completed successfully");
              }
            }
          } else {
            console.log("\u274C [Text Analysis] No text parts found in message - no text response from Gemini");
          }
        }
        // Public methods to control local playback
        setLocalPlaybackEnabled(enabled) {
          this.localPlaybackEnabled = enabled;
          debugLog(`[Gemini Live Audio] Local playback ${enabled ? "enabled" : "disabled"}`);
        }
        getLocalPlaybackEnabled() {
          return this.localPlaybackEnabled;
        }
        // Removed base64ToArrayBuffer - now using decode function from gemini-utils
        async stop() {
          console.log("\u{1F6D1} [Gemini Session] SESSION ENDING - Beginning shutdown process");
          console.log(`\u23F0 End Time: ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`);
          console.log(`\u{1F4B0} Session Cost: $${this.sessionCost.toFixed(4)}`);
          console.log(`\u{1F4CA} Input Tokens: ${this.sessionInputTokens}, Output Tokens: ${this.sessionOutputTokens}`);
          debugLog("[Gemini Live Audio] Stopping stream...");
          console.log("\u{1F504} [Session Cleanup] Setting processing flags to false...");
          this.isProcessing = false;
          this.sessionConnected = false;
          if (this.scriptProcessor) {
            console.log("\u{1F39B}\uFE0F [Audio Cleanup] Disconnecting script processor...");
            this.scriptProcessor.disconnect();
            this.scriptProcessor = null;
            console.log("\u2705 [Audio Cleanup] Script processor disconnected");
          }
          if (this.sourceNode) {
            console.log("\u{1F3A4} [Audio Cleanup] Disconnecting source node...");
            this.sourceNode.disconnect();
            this.sourceNode = null;
            console.log("\u2705 [Audio Cleanup] Source node disconnected");
          }
          if (this.sources.size > 0) {
            console.log(`\u{1F50A} [Audio Cleanup] Stopping ${this.sources.size} active audio sources...`);
            for (const source of this.sources.values()) {
              source.stop();
              this.sources.delete(source);
            }
            console.log("\u2705 [Audio Cleanup] All audio sources stopped");
          }
          if (this.inputAudioContext) {
            console.log("\u{1F3B5} [Audio Cleanup] Closing input audio context...");
            await this.inputAudioContext.close();
            this.inputAudioContext = null;
            console.log("\u2705 [Audio Cleanup] Input audio context closed");
          }
          if (this.outputAudioContext) {
            console.log("\u{1F50A} [Audio Cleanup] Closing output audio context...");
            await this.outputAudioContext.close();
            this.outputAudioContext = null;
            console.log("\u2705 [Audio Cleanup] Output audio context closed");
          }
          if (this.session) {
            console.log("\u{1F517} [Session Cleanup] Closing Gemini Live session...");
            this.session.close();
            this.session = null;
            console.log("\u2705 [Session Cleanup] Gemini Live session closed");
          }
          console.log("\u{1F9F9} [Session Cleanup] Resetting internal state...");
          this.inputNode = null;
          this.outputNode = null;
          this.nextStartTime = 0;
          this.audioBuffer = [];
          this.lastSendTime = 0;
          this.textBuffer = [];
          if (this.textBufferTimeout) {
            clearTimeout(this.textBufferTimeout);
            this.textBufferTimeout = null;
          }
          this.sessionInputTokens = 0;
          this.sessionOutputTokens = 0;
          this.sessionCost = 0;
          console.log("\u2705 [Gemini Session] SESSION COMPLETELY STOPPED - All resources cleaned up");
          debugLog("[Gemini Live Audio] Stream stopped");
        }
        isActive() {
          return this.session !== null && this.sessionConnected && this.isProcessing;
        }
        /**
         * Check if session is ready for operations (more lenient than isActive)
         */
        isSessionReady() {
          return this.session !== null && this.sessionConnected;
        }
        /**
         * Update target language dynamically when new participants join
         * Recreate session with new system_instruction since Live API doesn't support dynamic system instruction updates
         */
        async updateTargetLanguage(newTargetLanguage) {
          if (!this.isSessionReady()) {
            console.warn("[Gemini Live Audio] Cannot update language - session not ready");
            return;
          }
          const oldTargetLanguage = this.config.targetLanguage;
          this.config.targetLanguage = newTargetLanguage;
          debugLog(`[Gemini Live Audio] Updated target language: ${oldTargetLanguage} \u2192 ${newTargetLanguage}`);
          const oldMode = oldTargetLanguage === "System Assistant";
          const newMode = newTargetLanguage === "System Assistant";
          if (oldMode !== newMode || oldMode === false && newMode === false && oldTargetLanguage !== newTargetLanguage) {
            debugLog("[Gemini Live Audio] Mode or language changed, recreating session with new system instruction...");
            debugLog(`[Gemini Live Audio] Old: ${oldTargetLanguage} (System Assistant: ${oldMode})`);
            debugLog(`[Gemini Live Audio] New: ${newTargetLanguage} (System Assistant: ${newMode})`);
            try {
              const currentMediaStream = this.mediaStream;
              await this.stop();
              if (currentMediaStream) {
                await this.start(currentMediaStream);
                debugLog("[Gemini Live Audio] Session recreated successfully with new system instruction");
              }
            } catch (error) {
              console.error("[Gemini Live Audio] Failed to recreate session:", error);
              this.config.onError?.(error);
            }
          } else {
            debugLog("[Gemini Live Audio] Same mode, no session recreation needed");
          }
        }
        /**
         * Get current target language
         */
        getCurrentTargetLanguage() {
          return this.config.targetLanguage;
        }
        /**
         * Update speed settings dynamically
         */
        updateSpeedSettings(sendInterval, textBufferDelay) {
          if (sendInterval !== void 0 && sendInterval > 0) {
            this.sendInterval = sendInterval;
            debugLog(`[Gemini Live Audio] Updated send interval to ${sendInterval}ms`);
          }
          if (textBufferDelay !== void 0 && textBufferDelay > 0) {
            this.textBufferDelay = textBufferDelay;
            debugLog(`[Gemini Live Audio] Updated text buffer delay to ${textBufferDelay}ms`);
          }
        }
        /**
         * Get current speed settings
         */
        getSpeedSettings() {
          return {
            sendInterval: this.sendInterval,
            textBufferDelay: this.textBufferDelay
          };
        }
      };
      globalAudioContext = null;
      globalPcmWorkletNode = null;
      GEMINI_LANGUAGE_MAP = {
        "english": "English",
        "japanese": "Japanese",
        "chinese": "Chinese (Simplified)",
        "traditionalChinese": "Chinese (Traditional)",
        "korean": "Korean",
        "spanish": "Spanish",
        "french": "French",
        "german": "German",
        "italian": "Italian",
        "portuguese": "Portuguese",
        "russian": "Russian",
        "arabic": "Arabic",
        "hindi": "Hindi",
        "bengali": "Bengali",
        "vietnamese": "Vietnamese",
        "thai": "Thai",
        "turkish": "Turkish",
        "polish": "Polish",
        "czech": "Czech",
        "hungarian": "Hungarian",
        "bulgarian": "Bulgarian",
        "javanese": "Javanese",
        "tamil": "Tamil",
        "burmese": "Burmese",
        "hebrew": "Hebrew"
      };
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.production.js
  var require_react_jsx_runtime_production = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      function jsxProd(type, config, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config.key && (key = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        config = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config ? config : null,
          props: maybeKey
        };
      }
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsxProd;
      exports.jsxs = jsxProd;
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_jsx_runtime_production();
      } else {
        module.exports = null;
      }
    }
  });

  // main.tsx
  var import_react6 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // hooks.ts
  var import_react = __toESM(require_react());

  // node_modules/uuid/dist/esm-browser/stringify.js
  var byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }

  // node_modules/uuid/dist/esm-browser/rng.js
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      if (typeof crypto === "undefined" || !crypto.getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
      getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
  }

  // node_modules/uuid/dist/esm-browser/native.js
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native_default = { randomUUID };

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? rng();
    if (rnds.length < 16) {
      throw new Error("Random bytes length must be >= 16");
    }
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      if (offset < 0 || offset + 16 > buf.length) {
        throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
      }
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default = v4;

  // hooks.ts
  init_gemini_live_audio();
  init_debug_utils();
  var useConferenceApp = () => {
    const [apiKey, setApiKey] = (0, import_react.useState)("");
    const [username, setUsername] = (0, import_react.useState)("");
    const [roomId, setRoomId] = (0, import_react.useState)("");
    const [isConnected, setIsConnected] = (0, import_react.useState)(false);
    const [isInConference, setIsInConference] = (0, import_react.useState)(false);
    const [isMuted, setIsMuted] = (0, import_react.useState)(true);
    const [isScreenSharing, setIsScreenSharing] = (0, import_react.useState)(false);
    const [isCameraOn, setIsCameraOn] = (0, import_react.useState)(false);
    const [isBackgroundBlur, setIsBackgroundBlur] = (0, import_react.useState)(false);
    const [isBeautyMode, setIsBeautyMode] = (0, import_react.useState)(false);
    const [brightness, setBrightness] = (0, import_react.useState)(100);
    const [showCameraSettings, setShowCameraSettings] = (0, import_react.useState)(false);
    const [myLanguage, setMyLanguage] = (0, import_react.useState)("english");
    const [translations, setTranslations] = (0, import_react.useState)([]);
    const [participants, setParticipants] = (0, import_react.useState)([]);
    const [showSettings, setShowSettings] = (0, import_react.useState)(false);
    const [showRoomUrl, setShowRoomUrl] = (0, import_react.useState)(false);
    const [showCopyModal, setShowCopyModal] = (0, import_react.useState)(false);
    const [remoteScreenSharer, setRemoteScreenSharer] = (0, import_react.useState)(null);
    const [isHandRaised, setIsHandRaised] = (0, import_react.useState)(false);
    const [showChat, setShowChat] = (0, import_react.useState)(false);
    const [showReactions, setShowReactions] = (0, import_react.useState)(false);
    const [chatMessages, setChatMessages] = (0, import_react.useState)([]);
    const [chatInput, setChatInput] = (0, import_react.useState)("");
    const [audioTranslations, setAudioTranslations] = (0, import_react.useState)([]);
    const [isAudioTranslationEnabled, setIsAudioTranslationEnabled] = (0, import_react.useState)(true);
    const isAudioTranslationEnabledRef = (0, import_react.useRef)(true);
    const [isLocalPlaybackEnabled, setIsLocalPlaybackEnabled] = (0, import_react.useState)(true);
    const isLocalPlaybackEnabledRef = (0, import_react.useRef)(true);
    const [voiceSettings, setVoiceSettings] = (0, import_react.useState)({
      voiceName: "Zephyr",
      speed: 1,
      pitch: 1
    });
    const [unreadMessageCount, setUnreadMessageCount] = (0, import_react.useState)(0);
    const [showAudioSettings, setShowAudioSettings] = (0, import_react.useState)(false);
    const [audioInputDevices, setAudioInputDevices] = (0, import_react.useState)([]);
    const [audioOutputDevices, setAudioOutputDevices] = (0, import_react.useState)([]);
    const [selectedMicrophone, setSelectedMicrophone] = (0, import_react.useState)("");
    const [selectedSpeaker, setSelectedSpeaker] = (0, import_react.useState)("");
    const [sendRawAudio, setSendRawAudio] = (0, import_react.useState)(false);
    const [isGeminiSpeaking, setIsGeminiSpeaking] = (0, import_react.useState)(false);
    const [noiseFilterSettings, setNoiseFilterSettings] = (0, import_react.useState)({
      enabled: true,
      // Default ON for better audio quality
      highPassFrequency: 100,
      // Remove low-frequency noise (AC, fans)
      lowPassFrequency: 8e3,
      // Remove high-frequency noise (electronics)
      compressionRatio: 3,
      // Moderate compression
      gainReduction: -6
      // 6dB gain reduction
    });
    const [showErrorModal, setShowErrorModal] = (0, import_react.useState)(false);
    const [errorMessage, setErrorMessage] = (0, import_react.useState)("");
    const [translationSpeedMode, setTranslationSpeedMode] = (0, import_react.useState)("ultrafast" /* ULTRAFAST */);
    const [translationSpeedSettings, setTranslationSpeedSettings] = (0, import_react.useState)({
      mode: "ultrafast" /* ULTRAFAST */,
      sendInterval: 100,
      textBufferDelay: 200,
      estimatedCostMultiplier: 15
    });
    const [apiUsageStats, setApiUsageStats] = (0, import_react.useState)({
      sessionUsage: {
        inputTokens: { text: 0, audio: 0 },
        outputTokens: { text: 0, audio: 0 },
        totalCost: 0
      },
      totalUsage: {
        inputTokens: { text: 0, audio: 0 },
        outputTokens: { text: 0, audio: 0 },
        totalCost: 0
      },
      sessionCount: 0
    });
    const audioAnalyzerRef = (0, import_react.useRef)(null);
    const audioDataRef = (0, import_react.useRef)(null);
    const lastSpeakingStatusRef = (0, import_react.useRef)(false);
    const lastSpeakingUpdateRef = (0, import_react.useRef)(0);
    const sourceNodeRef = (0, import_react.useRef)(null);
    const highPassFilterRef = (0, import_react.useRef)(null);
    const lowPassFilterRef = (0, import_react.useRef)(null);
    const compressorRef = (0, import_react.useRef)(null);
    const gainNodeRef = (0, import_react.useRef)(null);
    const destinationRef = (0, import_react.useRef)(null);
    const filteredStreamRef = (0, import_react.useRef)(null);
    const wsRef = (0, import_react.useRef)(null);
    const localStreamRef = (0, import_react.useRef)(null);
    const screenStreamRef = (0, import_react.useRef)(null);
    const cameraStreamRef = (0, import_react.useRef)(null);
    const videoRef = (0, import_react.useRef)(null);
    const canvasRef = (0, import_react.useRef)(null);
    const screenPreviewRef = (0, import_react.useRef)(null);
    const peerConnectionsRef = (0, import_react.useRef)({});
    const audioContextRef = (0, import_react.useRef)(null);
    const clientIdRef = (0, import_react.useRef)(v4_default());
    const audioRecordersRef = (0, import_react.useRef)(/* @__PURE__ */ new Map());
    const liveAudioStreamRef = (0, import_react.useRef)(null);
    const iceServers = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" }
      ]
    };
    (0, import_react.useEffect)(() => {
      const storedApiKey = localStorage.getItem("geminiApiKey");
      const storedUsername = localStorage.getItem("username");
      const storedLanguage = localStorage.getItem("myLanguage");
      const storedMicrophone = localStorage.getItem("selectedMicrophone");
      const storedLocalPlayback = localStorage.getItem("isLocalPlaybackEnabled");
      const storedSpeaker = localStorage.getItem("selectedSpeaker");
      const storedSendRawAudio = localStorage.getItem("sendRawAudio");
      const storedNoiseFilter = localStorage.getItem("noiseFilterSettings");
      const storedUsage = localStorage.getItem("geminiApiUsage");
      const storedSpeedMode = localStorage.getItem("translationSpeedMode");
      if (storedApiKey) {
        setApiKey(storedApiKey);
      }
      if (storedUsername) {
        setUsername(storedUsername);
      }
      if (storedLanguage) {
        setMyLanguage(storedLanguage);
      }
      const storedSessionCount = localStorage.getItem("geminiSessionCount");
      if (storedUsage) {
        try {
          const parsedUsage = JSON.parse(storedUsage);
          const sessionCount = storedSessionCount ? parseInt(storedSessionCount, 10) : 0;
          setApiUsageStats((prev) => ({
            ...prev,
            totalUsage: parsedUsage,
            sessionCount
          }));
        } catch (error) {
          debugError("Failed to parse stored API usage:", error);
        }
      } else if (storedSessionCount) {
        try {
          const sessionCount = parseInt(storedSessionCount, 10);
          setApiUsageStats((prev) => ({
            ...prev,
            sessionCount
          }));
        } catch (error) {
          debugError("Failed to parse stored session count:", error);
        }
      }
      if (storedMicrophone) {
        setSelectedMicrophone(storedMicrophone);
      }
      if (storedSpeaker) {
        setSelectedSpeaker(storedSpeaker);
      }
      if (storedSendRawAudio !== null) {
        setSendRawAudio(storedSendRawAudio === "true");
      }
      if (storedLocalPlayback !== null) {
        const localPlaybackEnabled = storedLocalPlayback === "true";
        setIsLocalPlaybackEnabled(localPlaybackEnabled);
        isLocalPlaybackEnabledRef.current = localPlaybackEnabled;
      }
      if (storedNoiseFilter) {
        try {
          const parsedNoiseFilter = JSON.parse(storedNoiseFilter);
          setNoiseFilterSettings(parsedNoiseFilter);
        } catch (error) {
          debugError("Failed to parse stored noise filter settings:", error);
        }
      }
      if (storedSpeedMode) {
        updateTranslationSpeedMode(storedSpeedMode);
      }
      const urlParams = new URLSearchParams(window.location.search);
      const queryRoomId = urlParams.get("roomId");
      const uuidRegex2 = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      if (queryRoomId && uuidRegex2.test(queryRoomId)) {
        setRoomId(queryRoomId);
        setShowSettings(false);
      } else {
        setRoomId(v4_default());
      }
    }, []);
    (0, import_react.useEffect)(() => {
      debugLog("[otak-conference] Loading settings from localStorage...");
      const savedApiKey = localStorage.getItem("geminiApiKey");
      const savedUsername = localStorage.getItem("username");
      const savedLanguage = localStorage.getItem("myLanguage");
      debugLog("[otak-conference] Saved API Key:", savedApiKey ? "Found (hidden for security)" : "Not found");
      debugLog("[otak-conference] Saved Username:", savedUsername);
      debugLog("[otak-conference] Saved Language:", savedLanguage);
      if (savedApiKey) setApiKey(savedApiKey);
      if (savedUsername) setUsername(savedUsername);
      if (savedLanguage) setMyLanguage(savedLanguage);
    }, []);
    (0, import_react.useEffect)(() => {
      debugLog("[otak-conference] Saving API Key to localStorage:", apiKey ? "Key provided (hidden for security)" : "Empty key");
      localStorage.setItem("geminiApiKey", apiKey);
    }, [apiKey]);
    (0, import_react.useEffect)(() => {
      localStorage.setItem("username", username);
    }, [username]);
    (0, import_react.useEffect)(() => {
      localStorage.setItem("myLanguage", myLanguage);
    }, [myLanguage]);
    (0, import_react.useEffect)(() => {
      if (selectedMicrophone) {
        localStorage.setItem("selectedMicrophone", selectedMicrophone);
      }
    }, [selectedMicrophone]);
    (0, import_react.useEffect)(() => {
      if (selectedSpeaker) {
        localStorage.setItem("selectedSpeaker", selectedSpeaker);
      }
    }, [selectedSpeaker]);
    (0, import_react.useEffect)(() => {
      localStorage.setItem("noiseFilterSettings", JSON.stringify(noiseFilterSettings));
    }, [noiseFilterSettings]);
    (0, import_react.useEffect)(() => {
      if (apiUsageStats.sessionCount !== void 0) {
        localStorage.setItem("geminiSessionCount", apiUsageStats.sessionCount.toString());
      }
    }, [apiUsageStats.sessionCount]);
    (0, import_react.useEffect)(() => {
      if (apiUsageStats.totalUsage) {
        localStorage.setItem("geminiApiUsage", JSON.stringify(apiUsageStats.totalUsage));
      }
    }, [apiUsageStats.totalUsage]);
    const getAudioDevices = async () => {
      try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          debugWarn("MediaDevices API not available");
          return;
        }
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          stream.getTracks().forEach((track) => track.stop());
        } catch (permissionError) {
          debugWarn("Media permission not granted, device labels may be limited:", permissionError);
        }
        const devices = await navigator.mediaDevices.enumerateDevices();
        if (!devices) {
          debugWarn("No devices returned from enumerateDevices");
          return;
        }
        const audioInputs = devices.filter((device) => device.kind === "audioinput");
        const audioOutputs = devices.filter((device) => device.kind === "audiooutput");
        debugLog("Available audio inputs:", audioInputs);
        debugLog("Available audio outputs:", audioOutputs);
        setAudioInputDevices(audioInputs);
        setAudioOutputDevices(audioOutputs);
        if (selectedMicrophone) {
          const micExists = audioInputs.some((device) => device.deviceId === selectedMicrophone);
          if (!micExists && audioInputs.length > 0) {
            debugLog("[AUDIO] Saved microphone not found, selecting default");
            setSelectedMicrophone(audioInputs[0].deviceId);
          }
        } else if (audioInputs.length > 0) {
          setSelectedMicrophone(audioInputs[0].deviceId);
        }
        if (selectedSpeaker) {
          const speakerExists = audioOutputs.some((device) => device.deviceId === selectedSpeaker);
          if (!speakerExists && audioOutputs.length > 0) {
            debugLog("[AUDIO] Saved speaker not found, selecting default");
            setSelectedSpeaker(audioOutputs[0].deviceId);
          }
        } else if (audioOutputs.length > 0) {
          setSelectedSpeaker(audioOutputs[0].deviceId);
        }
      } catch (error) {
        console.error("Error getting audio devices:", error);
      }
    };
    (0, import_react.useEffect)(() => {
      getAudioDevices();
    }, []);
    const setupNoiseFilterChain = (stream) => {
      if (!audioContextRef.current) {
        audioContextRef.current = new AudioContext();
      }
      try {
        debugLog("[NoiseFilter] Setting up noise filter chain");
        const audioContext = audioContextRef.current;
        cleanupNoiseFilterChain();
        sourceNodeRef.current = audioContext.createMediaStreamSource(stream);
        highPassFilterRef.current = audioContext.createBiquadFilter();
        lowPassFilterRef.current = audioContext.createBiquadFilter();
        compressorRef.current = audioContext.createDynamicsCompressor();
        gainNodeRef.current = audioContext.createGain();
        destinationRef.current = audioContext.createMediaStreamDestination();
        highPassFilterRef.current.type = "highpass";
        highPassFilterRef.current.frequency.setValueAtTime(noiseFilterSettings.highPassFrequency, audioContext.currentTime);
        highPassFilterRef.current.Q.setValueAtTime(0.7, audioContext.currentTime);
        lowPassFilterRef.current.type = "lowpass";
        lowPassFilterRef.current.frequency.setValueAtTime(noiseFilterSettings.lowPassFrequency, audioContext.currentTime);
        lowPassFilterRef.current.Q.setValueAtTime(0.7, audioContext.currentTime);
        compressorRef.current.threshold.setValueAtTime(-24, audioContext.currentTime);
        compressorRef.current.knee.setValueAtTime(30, audioContext.currentTime);
        compressorRef.current.ratio.setValueAtTime(noiseFilterSettings.compressionRatio, audioContext.currentTime);
        compressorRef.current.attack.setValueAtTime(3e-3, audioContext.currentTime);
        compressorRef.current.release.setValueAtTime(0.25, audioContext.currentTime);
        const gainValue = Math.pow(10, noiseFilterSettings.gainReduction / 20);
        gainNodeRef.current.gain.setValueAtTime(gainValue, audioContext.currentTime);
        if (noiseFilterSettings.enabled) {
          sourceNodeRef.current.connect(highPassFilterRef.current).connect(lowPassFilterRef.current).connect(compressorRef.current).connect(gainNodeRef.current).connect(destinationRef.current);
          debugLog("[NoiseFilter] Noise filter chain enabled");
        } else {
          sourceNodeRef.current.connect(destinationRef.current);
          debugLog("[NoiseFilter] Noise filter chain bypassed");
        }
        filteredStreamRef.current = destinationRef.current.stream;
        debugLog("[NoiseFilter] Noise filter chain setup complete");
        return filteredStreamRef.current;
      } catch (error) {
        debugError("Error setting up noise filter chain:", error);
        return stream;
      }
    };
    const cleanupNoiseFilterChain = () => {
      try {
        if (sourceNodeRef.current) {
          sourceNodeRef.current.disconnect();
          sourceNodeRef.current = null;
        }
        if (highPassFilterRef.current) {
          highPassFilterRef.current.disconnect();
          highPassFilterRef.current = null;
        }
        if (lowPassFilterRef.current) {
          lowPassFilterRef.current.disconnect();
          lowPassFilterRef.current = null;
        }
        if (compressorRef.current) {
          compressorRef.current.disconnect();
          compressorRef.current = null;
        }
        if (gainNodeRef.current) {
          gainNodeRef.current.disconnect();
          gainNodeRef.current = null;
        }
        if (destinationRef.current) {
          destinationRef.current.disconnect();
          destinationRef.current = null;
        }
        filteredStreamRef.current = null;
        debugLog("[NoiseFilter] Noise filter chain cleaned up");
      } catch (error) {
        debugError("Error cleaning up noise filter chain:", error);
      }
    };
    const setupAudioLevelDetection = (stream) => {
      if (!audioContextRef.current) {
        audioContextRef.current = new AudioContext();
      }
      try {
        const streamToAnalyze = noiseFilterSettings.enabled && filteredStreamRef.current ? filteredStreamRef.current : stream;
        const source = audioContextRef.current.createMediaStreamSource(streamToAnalyze);
        audioAnalyzerRef.current = audioContextRef.current.createAnalyser();
        audioAnalyzerRef.current.fftSize = 256;
        audioAnalyzerRef.current.smoothingTimeConstant = 0.3;
        source.connect(audioAnalyzerRef.current);
        const bufferLength = audioAnalyzerRef.current.frequencyBinCount;
        audioDataRef.current = new Uint8Array(bufferLength);
        monitorAudioLevel();
      } catch (error) {
        console.error("Error setting up audio level detection:", error);
      }
    };
    const monitorAudioLevel = () => {
      if (!audioAnalyzerRef.current || !audioDataRef.current) return;
      const checkAudioLevel = () => {
        if (!audioAnalyzerRef.current || !audioDataRef.current || !localStreamRef.current) return;
        audioAnalyzerRef.current.getByteFrequencyData(audioDataRef.current);
        const average = audioDataRef.current.reduce((acc, value) => acc + value, 0) / audioDataRef.current.length;
        const audioTrack = localStreamRef.current.getAudioTracks()[0];
        const isAudioEnabled = audioTrack ? audioTrack.enabled : false;
        const isSpeaking = average > 5 && isAudioEnabled;
        setParticipants((prev) => prev.map(
          (p) => p.clientId === clientIdRef.current ? { ...p, isSpeaking, audioLevel: average } : p
        ));
        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
          const now = Date.now();
          const statusChanged = lastSpeakingStatusRef.current !== isSpeaking;
          const timeSinceLastUpdate = now - lastSpeakingUpdateRef.current;
          if (statusChanged || isSpeaking && timeSinceLastUpdate > 500) {
            lastSpeakingStatusRef.current = isSpeaking;
            lastSpeakingUpdateRef.current = now;
            wsRef.current.send(JSON.stringify({
              type: "speaking-status",
              isSpeaking,
              audioLevel: average,
              username
            }));
          }
        }
        requestAnimationFrame(checkAudioLevel);
      };
      checkAudioLevel();
    };
    const connectToSignaling = (0, import_react.useCallback)(() => {
      const workerDomain = "otak-conference-worker.systemexe-research-and-development.workers.dev";
      const wsUrl = `wss://${workerDomain}/ws?room=${roomId}`;
      const ws = new WebSocket(wsUrl);
      wsRef.current = ws;
      if (!wsRef.current) return;
      ws.onopen = () => {
        debugLog("Connected to signaling server");
        ws.send(JSON.stringify({
          type: "join",
          roomId,
          clientId: clientIdRef.current,
          username,
          language: myLanguage
        }));
      };
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        debugLog("Received message:", message);
        switch (message.type) {
          case "room-full":
            debugLog("Room is full:", message);
            setIsConnected(false);
            setIsInConference(false);
            setErrorMessage(`\u4F1A\u8B70\u5BA4\u304C\u6E80\u5BA4\u3067\u3059\u3002\u6700\u5927\u53C2\u52A0\u8005\u6570\u306F${message.maxParticipants}\u540D\u3067\u3059\u3002\uFF08\u73FE\u5728${message.currentParticipants}\u540D\u304C\u53C2\u52A0\u4E2D\uFF09`);
            setShowErrorModal(true);
            if (localStreamRef.current) {
              localStreamRef.current.getTracks().forEach((track) => track.stop());
              localStreamRef.current = null;
            }
            break;
          case "user-joined":
            debugLog(`User joined: ${message.peerId}`);
            if (message.peerId !== clientIdRef.current) {
              await createPeerConnection(message.peerId, true);
              setParticipants((prev) => {
                const newParticipants = [...prev, { clientId: message.peerId, username: message.username, language: message.language }];
                updateGeminiTargetLanguage(newParticipants);
                return newParticipants;
              });
            }
            break;
          case "user-left":
            debugLog(`User left: ${message.peerId}`);
            closePeerConnection(message.peerId);
            setParticipants((prev) => {
              const newParticipants = prev.filter((p) => p.clientId !== message.peerId);
              updateGeminiTargetLanguage(newParticipants);
              return newParticipants;
            });
            if (remoteScreenSharer === message.peerId) {
              setRemoteScreenSharer(null);
              if (screenPreviewRef.current && !isScreenSharing) {
                screenPreviewRef.current.srcObject = null;
              }
            }
            break;
          case "offer":
            debugLog(`Received offer from ${message.peerId}`);
            await handleOffer(message.peerId, message.offer);
            break;
          case "answer":
            debugLog(`Received answer from ${message.peerId}`);
            await handleAnswer(message.peerId, message.answer);
            break;
          case "ice-candidate":
            debugLog(`Received ICE candidate from ${message.peerId}`);
            await handleIceCandidate(message.peerId, message.candidate);
            break;
          case "participants":
            debugLog("Received participants list:", message.participants);
            setParticipants(message.participants);
            updateGeminiTargetLanguage(message.participants);
            const otherParticipants = message.participants.filter((p) => p.clientId !== clientIdRef.current);
            for (const participant of otherParticipants) {
              await createPeerConnection(participant.clientId, false);
            }
            break;
          case "hand-raise":
            debugLog(`Hand raise from ${message.username}: ${message.raised}`);
            setParticipants((prev) => prev.map(
              (p) => p.username === message.username ? { ...p, isHandRaised: message.raised } : p
            ));
            break;
          case "reaction":
            debugLog(`Reaction from ${message.username}: ${message.reaction}`);
            setParticipants((prev) => prev.map(
              (p) => p.username === message.username ? { ...p, reaction: message.reaction, reactionTimestamp: Date.now() } : p
            ));
            setTimeout(() => {
              setParticipants((prev) => prev.map(
                (p) => p.username === message.username ? { ...p, reaction: void 0, reactionTimestamp: void 0 } : p
              ));
            }, 3e3);
            break;
          case "chat":
            debugLog(`Chat message from ${message.username}: ${message.message}`);
            if (message.username !== username) {
              setChatMessages((prev) => [...prev, {
                id: Date.now(),
                from: message.username,
                message: message.message,
                timestamp: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
                readBy: showChat ? [username] : []
                // Mark as read if chat is open
              }]);
              if (!showChat) {
                setUnreadMessageCount((prev) => prev + 1);
              }
            }
            break;
          case "message-read":
            debugLog(`Message read by ${message.readBy}: ${message.messageId}`);
            setChatMessages((prev) => prev.map(
              (msg) => msg.id === message.messageId ? { ...msg, readBy: [...msg.readBy || [], message.readBy] } : msg
            ));
            break;
          case "speaking-status":
            setParticipants((prev) => prev.map(
              (p) => p.username === message.username ? { ...p, isSpeaking: message.isSpeaking, audioLevel: message.audioLevel } : p
            ));
            break;
          case "translated-audio":
            debugLog(`[Conference] Received translated audio from ${message.from}`);
            debugLog(`[Conference] Audio data size: ${message.audioData?.length || 0} characters (Base64)`);
            debugLog(`[Conference] Audio format: ${message.audioFormat}`);
            debugLog(`[Conference] From language: ${message.fromLanguage}`);
            if (message.from !== username) {
              try {
                debugLog(`\u{1F3B5} [Audio Receive] Received audio from ${message.from}`);
                debugLog(`\u{1F4CA} [Audio Receive] Base64 data size: ${message.audioData?.length || 0} characters`);
                debugLog(`\u{1F4DD} [Audio Receive] Base64 preview: ${message.audioData?.substring(0, 100) || "None"}...`);
                if (!message.audioData || typeof message.audioData !== "string") {
                  throw new Error("Invalid audio data: not a string");
                }
                const base64Regex2 = /^[A-Za-z0-9+/]*={0,2}$/;
                if (!base64Regex2.test(message.audioData)) {
                  throw new Error("Invalid audio data: not valid Base64 format");
                }
                debugLog(`\u2705 [Audio Receive] Base64 validation passed`);
                debugLog(`\u{1F504} [Audio Receive] Decoding Base64 to binary...`);
                const binaryString = atob(message.audioData);
                debugLog(`\u{1F4CA} [Audio Receive] Decoded binary length: ${binaryString.length} bytes`);
                const audioData = new ArrayBuffer(binaryString.length);
                const uint8Array = new Uint8Array(audioData);
                for (let i = 0; i < binaryString.length; i++) {
                  uint8Array[i] = binaryString.charCodeAt(i);
                }
                debugLog(`\u{1F3B5} [Audio Receive] ArrayBuffer created: ${audioData.byteLength} bytes`);
                debugLog(`[Conference] Playing translated audio from ${message.from} (${audioData.byteLength} bytes)`);
                debugLog(`[Conference] Selected speaker device: ${selectedSpeaker || "default"}`);
                debugLog(`\u{1F50A} [Audio Receive] Starting playback...`);
                await playAudioData(audioData, selectedSpeaker);
                debugLog(`\u2705 [Audio Receive] Successfully played translated audio from ${message.from}`);
                debugLog(`[Conference] Successfully played translated audio from ${message.from}`);
              } catch (error) {
                console.error("\u274C [Audio Receive] Failed to play translated audio:", error);
                console.error("[Conference] Failed to play translated audio:", error);
                console.error("[Conference] Error details:", {
                  errorMessage: error instanceof Error ? error.message : String(error),
                  audioDataSize: message.audioData?.length || 0,
                  audioDataType: typeof message.audioData,
                  audioDataPreview: message.audioData?.substring(0, 100) || "None",
                  selectedSpeaker: selectedSpeaker || "default",
                  from: message.from
                });
              }
            } else {
              debugLog(`[Conference] Skipping translated audio from self (${message.from})`);
            }
            break;
          case "translation":
            debugLog(`[Conference] Received translation from ${message.translation.from}`);
            if (message.translation.from !== username) {
              setTranslations((prev) => {
                const updated = [...prev, message.translation];
                debugLog("\u{1F4E5} [HOOKS] Received translation from participant:", message.translation);
                debugLog("\u{1F4CA} [HOOKS] Updated translations array length:", updated.length);
                return updated;
              });
            }
            break;
        }
      };
      ws.onclose = () => {
        debugLog("Disconnected from signaling server");
        setIsConnected(false);
      };
      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
      };
    }, [roomId, username, myLanguage]);
    const createPeerConnection = async (peerId, isInitiator) => {
      const pc = new RTCPeerConnection(iceServers);
      peerConnectionsRef.current[peerId] = pc;
      if (localStreamRef.current) {
        debugLog("Adding local stream tracks to peer connection for", peerId);
        localStreamRef.current.getTracks().forEach((track) => {
          if (localStreamRef.current) {
            if (track.kind === "audio" && !sendRawAudio) {
              debugLog(`Skipping audio track for peer ${peerId} (raw audio transmission disabled)`);
              return;
            }
            debugLog(`Adding ${track.kind} track (enabled: ${track.enabled}) to peer ${peerId}`);
            const sender = pc.addTrack(track, localStreamRef.current);
            debugLog("Track added successfully, sender:", sender);
          }
        });
      } else {
        console.warn("No local stream available when creating peer connection for", peerId);
      }
      pc.ontrack = async (event) => {
        debugLog("Received remote stream from", peerId);
        const [remoteStream] = event.streams;
        const track = event.track;
        debugLog(`Received ${track.kind} track from ${peerId}, enabled: ${track.enabled}, readyState: ${track.readyState}`);
        if (track.kind === "video") {
          debugLog("Received video track (screen share) from", peerId);
          if (screenPreviewRef.current) {
            screenPreviewRef.current.srcObject = remoteStream;
            screenPreviewRef.current.play().catch((e) => console.error("Error playing remote screen share:", e));
            setRemoteScreenSharer(peerId);
          }
        } else if (track.kind === "audio") {
          debugLog("Processing audio stream from", peerId);
          const audioElement = new Audio();
          audioElement.srcObject = remoteStream;
          audioElement.autoplay = true;
          if ("setSinkId" in audioElement && selectedSpeaker) {
            try {
              await audioElement.setSinkId(selectedSpeaker);
              debugLog(`[Audio] Set output device for remote audio: ${selectedSpeaker}`);
            } catch (error) {
              console.warn("[Audio] Could not set output device for remote audio:", error);
            }
          }
          audioElement.play().catch((e) => console.error("Error playing remote audio:", e));
        }
      };
      pc.onicecandidate = (event) => {
        if (event.candidate && wsRef.current) {
          wsRef.current.send(JSON.stringify({
            type: "ice-candidate",
            peerId,
            candidate: event.candidate
          }));
        }
      };
      if (isInitiator) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        if (wsRef.current) {
          wsRef.current.send(JSON.stringify({
            type: "offer",
            peerId,
            offer
          }));
        }
      }
      return pc;
    };
    const closePeerConnection = (peerId) => {
      if (peerConnectionsRef.current[peerId]) {
        peerConnectionsRef.current[peerId].close();
        delete peerConnectionsRef.current[peerId];
      }
    };
    const handleOffer = async (peerId, offer) => {
      let pc = peerConnectionsRef.current[peerId];
      if (!pc) {
        pc = await createPeerConnection(peerId, false);
      }
      await pc.setRemoteDescription(offer);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      if (wsRef.current) {
        wsRef.current.send(JSON.stringify({
          type: "answer",
          peerId,
          answer
        }));
      }
    };
    const handleAnswer = async (peerId, answer) => {
      const pc = peerConnectionsRef.current[peerId];
      if (pc) {
        await pc.setRemoteDescription(answer);
      }
    };
    const handleIceCandidate = async (peerId, candidate) => {
      const pc = peerConnectionsRef.current[peerId];
      if (pc) {
        await pc.addIceCandidate(candidate);
      }
    };
    const cleanupPeerAudioRecorder = (peerId) => {
      const recorder = audioRecordersRef.current.get(peerId);
      if (recorder) {
        recorder.stopRecording();
        audioRecordersRef.current.delete(peerId);
      }
    };
    const arrayBufferToBase64 = (buffer) => {
      const bytes = new Uint8Array(buffer);
      let binary = "";
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    };
    const float32ArrayToArrayBuffer = (float32Array) => {
      const buffer = new ArrayBuffer(float32Array.length * 4);
      const view = new DataView(buffer);
      for (let i = 0; i < float32Array.length; i++) {
        view.setFloat32(i * 4, float32Array[i], true);
      }
      return buffer;
    };
    const startConference = async () => {
      if (!apiKey) {
        alert("Please enter your Gemini API key.");
        return;
      }
      if (!username) {
        alert("Please enter your username.");
        return;
      }
      try {
        const audioConstraints = selectedMicrophone ? { deviceId: { exact: selectedMicrophone } } : true;
        const rawStream = await navigator.mediaDevices.getUserMedia({
          audio: audioConstraints,
          video: false
        });
        const processedStream = setupNoiseFilterChain(rawStream);
        localStreamRef.current = processedStream;
        const audioTrack = localStreamRef.current.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = false;
        }
        setupAudioLevelDetection(rawStream);
        setParticipants([{
          clientId: clientIdRef.current,
          username,
          language: myLanguage,
          isSpeaking: false,
          isHandRaised: false
        }]);
        connectToSignaling();
        setIsConnected(true);
        setIsInConference(true);
        setShowSettings(false);
        debugLog("[Conference] Gemini Live Audio will be started when participants join (no assistant mode)");
        window.history.pushState({}, "", `?roomId=${roomId}`);
      } catch (error) {
        console.error("Failed to start conference:", error);
        alert("Failed to access microphone. Please check permissions.");
      }
    };
    const endConference = () => {
      Object.keys(peerConnectionsRef.current).forEach((peerId) => {
        closePeerConnection(peerId);
      });
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
      }
      if (localStreamRef.current) {
        localStreamRef.current.getTracks().forEach((track) => track.stop());
        localStreamRef.current = null;
      }
      if (screenStreamRef.current) {
        screenStreamRef.current.getTracks().forEach((track) => track.stop());
        screenStreamRef.current = null;
      }
      if (liveAudioStreamRef.current) {
        debugLog("[Conference] Stopping Gemini Live Audio stream...");
        liveAudioStreamRef.current.stop();
        liveAudioStreamRef.current = null;
        debugLog("[Conference] Gemini Live Audio stream stopped");
      }
      cleanupNoiseFilterChain();
      setIsConnected(false);
      setIsInConference(false);
      setIsScreenSharing(false);
      setIsMuted(true);
      setTranslations([]);
      setParticipants([]);
    };
    const shareRoomUrl = async () => {
      const roomUrl = `${window.location.href.split("?")[0]}?roomId=${roomId}`;
      try {
        await navigator.clipboard.writeText(roomUrl);
        setShowCopyModal(true);
        setTimeout(() => setShowCopyModal(false), 2e3);
      } catch (error) {
        console.error("Failed to copy URL:", error);
        setShowCopyModal(true);
        setTimeout(() => setShowCopyModal(false), 2e3);
      }
    };
    const toggleMute = () => {
      if (localStreamRef.current) {
        const audioTrack = localStreamRef.current.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          setIsMuted(!audioTrack.enabled);
        }
      }
    };
    const toggleScreenShare = async () => {
      if (!isScreenSharing) {
        try {
          screenStreamRef.current = await navigator.mediaDevices.getDisplayMedia({
            video: {
              width: { ideal: 1920, max: 1920 },
              height: { ideal: 1080, max: 1080 },
              frameRate: { ideal: 30, max: 30 }
            },
            audio: false
            // Changed to false to avoid audio issues
          });
          debugLog("Screen share stream obtained:", screenStreamRef.current);
          debugLog("Video tracks:", screenStreamRef.current.getVideoTracks());
          debugLog("Stream active:", screenStreamRef.current.active);
          const videoTrack = screenStreamRef.current.getVideoTracks()[0];
          if (!videoTrack) {
            throw new Error("No video track found in screen share stream");
          }
          debugLog("Video track enabled:", videoTrack.enabled);
          debugLog("Video track readyState:", videoTrack.readyState);
          Object.values(peerConnectionsRef.current).forEach((pc) => {
            if (screenStreamRef.current) {
              screenStreamRef.current.getTracks().forEach((track) => {
                debugLog(`Adding ${track.kind} track to peer connection`);
                try {
                  pc.addTrack(track, screenStreamRef.current);
                  debugLog("Track added successfully");
                } catch (error) {
                  console.error("Error adding track:", error);
                }
              });
            }
          });
          await new Promise((resolve) => setTimeout(resolve, 100));
          if (screenPreviewRef.current && screenStreamRef.current) {
            debugLog("Setting up screen preview");
            screenPreviewRef.current.srcObject = null;
            screenPreviewRef.current.muted = true;
            screenPreviewRef.current.playsInline = true;
            screenPreviewRef.current.autoplay = true;
            screenPreviewRef.current.onloadedmetadata = () => {
              debugLog(
                "Video metadata loaded, dimensions:",
                screenPreviewRef.current?.videoWidth,
                "x",
                screenPreviewRef.current?.videoHeight
              );
              if (screenPreviewRef.current) {
                screenPreviewRef.current.style.display = "none";
                setTimeout(() => {
                  if (screenPreviewRef.current) {
                    screenPreviewRef.current.style.display = "block";
                  }
                }, 10);
              }
            };
            screenPreviewRef.current.oncanplay = () => {
              debugLog("Video can play");
            };
            screenPreviewRef.current.onplaying = () => {
              debugLog("Video is playing");
            };
            screenPreviewRef.current.onerror = (error) => {
              console.error("Video element error:", error);
            };
            screenPreviewRef.current.srcObject = screenStreamRef.current;
            setTimeout(async () => {
              if (screenPreviewRef.current) {
                try {
                  await screenPreviewRef.current.play();
                  debugLog("Video playing successfully");
                } catch (playError) {
                  console.error("Error playing video:", playError);
                  screenPreviewRef.current.muted = true;
                  screenPreviewRef.current.play().catch((e) => console.error("Second play attempt failed:", e));
                }
              }
            }, 100);
          }
          setIsScreenSharing(true);
          videoTrack.onended = () => {
            debugLog("Screen share ended by user");
            if (screenStreamRef.current) {
              screenStreamRef.current.getTracks().forEach((track) => {
                track.stop();
              });
              screenStreamRef.current = null;
            }
            if (screenPreviewRef.current && !remoteScreenSharer) {
              screenPreviewRef.current.srcObject = null;
            }
            setIsScreenSharing(false);
          };
        } catch (error) {
          console.error("Error starting screen share:", error);
          alert("Failed to start screen sharing. Please check permissions.");
          setIsScreenSharing(false);
        }
      } else {
        if (screenStreamRef.current) {
          screenStreamRef.current.getTracks().forEach((track) => {
            track.stop();
            debugLog("Stopped track:", track.kind);
          });
          screenStreamRef.current = null;
        }
        if (screenPreviewRef.current && !remoteScreenSharer) {
          screenPreviewRef.current.srcObject = null;
        }
        setIsScreenSharing(false);
        debugLog("Screen sharing stopped");
      }
    };
    const toggleCamera = async () => {
      if (!isCameraOn) {
        try {
          cameraStreamRef.current = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false
          });
          if (videoRef.current) {
            videoRef.current.srcObject = cameraStreamRef.current;
            videoRef.current.play();
          }
          setIsCameraOn(true);
          if (isBackgroundBlur || isBeautyMode || brightness !== 100) {
            applyVideoEffects();
          }
        } catch (error) {
          console.error("Error accessing camera:", error);
          alert("Failed to access camera. Please check permissions.");
        }
      } else {
        if (cameraStreamRef.current) {
          cameraStreamRef.current.getTracks().forEach((track) => track.stop());
          cameraStreamRef.current = null;
        }
        setIsCameraOn(false);
      }
    };
    const applyVideoEffects = () => {
      if (!cameraStreamRef.current || !videoRef.current || !canvasRef.current) return;
      const video = videoRef.current;
      const canvas = canvasRef.current;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const applyEffects = () => {
        ctx.filter = `brightness(${brightness}%)`;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        if (isBackgroundBlur) {
          ctx.filter += " blur(2px)";
        }
        if (isBeautyMode) {
          ctx.filter += " contrast(1.1) saturate(1.1)";
        }
        requestAnimationFrame(applyEffects);
      };
      applyEffects();
    };
    const toggleHandRaise = () => {
      const newHandRaised = !isHandRaised;
      setIsHandRaised(newHandRaised);
      setParticipants((prev) => prev.map(
        (p) => p.clientId === clientIdRef.current ? { ...p, isHandRaised: newHandRaised } : p
      ));
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({
          type: "hand-raise",
          raised: newHandRaised,
          username
        }));
      }
    };
    const sendReaction = (reaction) => {
      setParticipants((prev) => prev.map(
        (p) => p.clientId === clientIdRef.current ? { ...p, reaction, reactionTimestamp: Date.now() } : p
      ));
      setTimeout(() => {
        setParticipants((prev) => prev.map(
          (p) => p.clientId === clientIdRef.current ? { ...p, reaction: void 0, reactionTimestamp: void 0 } : p
        ));
      }, 3e3);
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({
          type: "reaction",
          reaction,
          username
        }));
      }
      setShowReactions(false);
      debugLog(`Sent reaction: ${reaction}`);
    };
    const sendChatMessage = () => {
      if (!chatInput.trim()) return;
      const message = chatInput.trim();
      setChatMessages((prev) => [...prev, {
        id: Date.now(),
        from: username,
        message,
        timestamp: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
        readBy: [username]
        // Self-sent messages are automatically read
      }]);
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({
          type: "chat",
          message,
          username
        }));
      }
      setChatInput("");
    };
    const toggleChat = (value) => {
      setShowChat(value);
      if (value) {
        setUnreadMessageCount(0);
        setChatMessages((prev) => prev.map((msg) => {
          if (!msg.readBy?.includes(username)) {
            const updatedMsg = {
              ...msg,
              readBy: [...msg.readBy || [], username]
            };
            if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN && msg.from !== username) {
              wsRef.current.send(JSON.stringify({
                type: "message-read",
                messageId: msg.id,
                readBy: username
              }));
            }
            return updatedMsg;
          }
          return msg;
        }));
      }
    };
    const changeMicrophone = async (deviceId) => {
      setSelectedMicrophone(deviceId);
      localStorage.setItem("selectedMicrophone", deviceId);
      if (isInConference && localStreamRef.current) {
        try {
          const audioTrack = localStreamRef.current.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.stop();
          }
          const rawNewAudioStream = await navigator.mediaDevices.getUserMedia({
            audio: { deviceId: { exact: deviceId } }
          });
          const processedNewAudioStream = setupNoiseFilterChain(rawNewAudioStream);
          const newAudioTrack = processedNewAudioStream.getAudioTracks()[0];
          if (newAudioTrack) {
            newAudioTrack.enabled = !isMuted;
            Object.values(peerConnectionsRef.current).forEach((pc) => {
              const sender = pc.getSenders().find((s) => s.track?.kind === "audio");
              if (sender) {
                sender.replaceTrack(newAudioTrack);
              }
            });
            localStreamRef.current.removeTrack(audioTrack);
            localStreamRef.current.addTrack(newAudioTrack);
            setupAudioLevelDetection(rawNewAudioStream);
          }
        } catch (error) {
          console.error("Error changing microphone:", error);
          alert("Failed to change microphone. Please check permissions.");
        }
      }
    };
    const updateNoiseFilterSettings = (newSettings) => {
      const updatedSettings = { ...noiseFilterSettings, ...newSettings };
      setNoiseFilterSettings(updatedSettings);
      if (isInConference && localStreamRef.current) {
        try {
          debugLog("[NoiseFilter] Updating filter settings during conference");
          changeMicrophone(selectedMicrophone || "");
        } catch (error) {
          debugError("Error updating noise filter settings:", error);
        }
      }
    };
    const toggleNoiseFilter = () => {
      updateNoiseFilterSettings({ enabled: !noiseFilterSettings.enabled });
    };
    const changeSpeaker = async (deviceId) => {
      setSelectedSpeaker(deviceId);
      localStorage.setItem("selectedSpeaker", deviceId);
      debugLog(`[Audio] Changing speaker to device: ${deviceId}`);
      try {
        const audioElements = document.querySelectorAll("audio");
        debugLog(`[Audio] Found ${audioElements.length} existing audio elements`);
        for (const audio of audioElements) {
          if ("setSinkId" in audio) {
            try {
              await audio.setSinkId(deviceId);
              debugLog("[Audio] Successfully set output device for existing audio element");
            } catch (error) {
              console.warn("[Audio] Could not set output device for existing audio element:", error);
            }
          }
        }
        if (audioContextRef.current && "setSinkId" in audioContextRef.current.destination) {
          try {
            await audioContextRef.current.destination.setSinkId(deviceId);
            debugLog("[Audio] Successfully set output device for audio context");
          } catch (error) {
            console.warn("[Audio] Could not set output device for audio context:", error);
          }
        }
        debugLog(`[Audio] Speaker device change completed for device: ${deviceId}`);
      } catch (error) {
        console.warn("[Audio] Speaker change not fully supported:", error);
      }
    };
    const toggleSendRawAudio = async () => {
      const newValue = !sendRawAudio;
      setSendRawAudio(newValue);
      localStorage.setItem("sendRawAudio", newValue.toString());
      debugLog(`[Conference] Raw audio transmission ${newValue ? "enabled" : "disabled"}`);
      if (isInConference && localStreamRef.current) {
        const audioTrack = localStreamRef.current.getAudioTracks()[0];
        if (audioTrack) {
          for (const [peerId, pc] of Object.entries(peerConnectionsRef.current)) {
            const sender = pc.getSenders().find((s) => s.track?.kind === "audio");
            try {
              if (newValue && !sender) {
                pc.addTrack(audioTrack, localStreamRef.current);
                debugLog(`[Conference] Added audio track to peer connection ${peerId}`);
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                  wsRef.current.send(JSON.stringify({
                    type: "offer",
                    peerId,
                    offer
                  }));
                }
              } else if (!newValue && sender) {
                pc.removeTrack(sender);
                debugLog(`[Conference] Removed audio track from peer connection ${peerId}`);
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                  wsRef.current.send(JSON.stringify({
                    type: "offer",
                    peerId,
                    offer
                  }));
                }
              }
            } catch (error) {
              console.error(`[Conference] Error updating audio track for peer ${peerId}:`, error);
            }
          }
        }
      }
    };
    const toggleLocalPlayback = () => {
      const newValue = !isLocalPlaybackEnabled;
      setIsLocalPlaybackEnabled(newValue);
      isLocalPlaybackEnabledRef.current = newValue;
      localStorage.setItem("isLocalPlaybackEnabled", newValue.toString());
      debugLog(`[Conference] Local playback of Gemini responses ${newValue ? "enabled" : "disabled"}`);
      if (liveAudioStreamRef.current) {
        liveAudioStreamRef.current.setLocalPlaybackEnabled(newValue);
      }
    };
    const isLocalDevelopment = () => {
      const hostname = window.location.hostname;
      return hostname === "localhost" || hostname === "127.0.0.1" || hostname.includes("trycloudflare.com") || hostname.includes("ngrok.io") || false;
    };
    const startSoloGeminiSession = async (sourceLanguage, targetLanguage) => {
      try {
        if (!apiKey || !localStreamRef.current) {
          console.warn("[Conference] Cannot start solo Gemini session - missing API key or local stream");
          return;
        }
        debugLog(`[Conference] Creating solo Gemini Live Audio session: ${sourceLanguage} \u2192 ${targetLanguage}`);
        const { GeminiLiveAudioStream: GeminiLiveAudioStream2 } = await Promise.resolve().then(() => (init_gemini_live_audio(), gemini_live_audio_exports));
        liveAudioStreamRef.current = new GeminiLiveAudioStream2({
          apiKey,
          sourceLanguage,
          targetLanguage,
          localPlaybackEnabled: isLocalPlaybackEnabledRef.current,
          // Solo mode configuration
          otherParticipantLanguages: [],
          usePeerTranslation: false,
          onAudioReceived: async (audioData) => {
            try {
              debugLog("[Conference] Solo mode - Received translated audio from Gemini");
            } catch (error) {
              debugError("[Conference] Solo mode - Error handling audio:", error);
            }
          },
          onTextReceived: (text) => {
            try {
              debugLog("\u{1F3AF} [Solo Mode] Received translated text:", text);
              debugLog("[Conference] Solo mode - Translated text received:", text);
              const newTranslation = {
                id: Date.now(),
                from: "Gemini AI",
                fromLanguage: targetLanguage,
                original: text,
                translation: text,
                timestamp: (/* @__PURE__ */ new Date()).toLocaleTimeString()
              };
              setTranslations((prev) => [...prev, newTranslation]);
            } catch (error) {
              debugError("[Conference] Solo mode - Error handling text:", error);
            }
          }
        });
        if (liveAudioStreamRef.current) {
          debugLog("[Conference] Solo session callbacks configured");
        }
        await liveAudioStreamRef.current.start(localStreamRef.current);
        debugLog("[Conference] Solo Gemini Live Audio session started successfully");
      } catch (error) {
        console.error("[Conference] Failed to start solo Gemini session:", error);
        liveAudioStreamRef.current = null;
      }
    };
    const updateGeminiTargetLanguage = async (currentParticipants) => {
      const otherParticipants = currentParticipants.filter((p) => p.clientId !== clientIdRef.current);
      if (otherParticipants.length === 0) {
        if (isLocalDevelopment()) {
          debugLog("[Conference] Local development mode: Starting solo session with Gemini");
          const sourceLanguage2 = GEMINI_LANGUAGE_MAP[myLanguage] || "English";
          const targetLanguage2 = myLanguage === "english" ? "Japanese" : "English";
          infoLog(`\u{1F3AF} [Solo Session] Local Development Mode`);
          infoLog(`\u{1F4F1} My Language: ${myLanguage} \u2192 ${sourceLanguage2}`);
          infoLog(`\u{1F916} Gemini Target: ${targetLanguage2} (solo mode)`);
          infoLog(`\u{1F504} Translation Direction: ${sourceLanguage2} \u2192 ${targetLanguage2}`);
          await startSoloGeminiSession(sourceLanguage2, targetLanguage2);
          return;
        } else {
          debugLog("[Conference] No other participants, stopping Gemini Live Audio session");
          if (liveAudioStreamRef.current) {
            debugLog("[Conference] Stopping Gemini Live Audio stream (no participants)");
            await liveAudioStreamRef.current.stop();
            liveAudioStreamRef.current = null;
          }
          return;
        }
      }
      const primaryTarget = otherParticipants[0].language;
      const targetLanguage = GEMINI_LANGUAGE_MAP[primaryTarget] || "English";
      const sourceLanguage = GEMINI_LANGUAGE_MAP[myLanguage] || "English";
      infoLog(`\u{1F3AF} [Translation Setup] Session Started`);
      infoLog(`\u{1F4F1} My Language: ${myLanguage} \u2192 ${sourceLanguage}`);
      infoLog(`\u{1F465} Participant Language: ${primaryTarget} \u2192 ${targetLanguage}`);
      infoLog(`\u{1F504} Translation Direction: ${sourceLanguage} \u2192 ${targetLanguage}`);
      debugLog(`[Conference] Language mapping debug:`);
      debugLog(`[Conference] - My language: ${myLanguage} \u2192 ${sourceLanguage}`);
      debugLog(`[Conference] - Participant language: ${primaryTarget} \u2192 ${targetLanguage}`);
      if (!liveAudioStreamRef.current) {
        debugLog(`[Conference] Creating new Gemini Live Audio session: ${sourceLanguage} \u2192 ${targetLanguage}`);
        if (!apiKey || !localStreamRef.current) {
          console.warn("[Conference] Cannot start Gemini Live Audio - missing API key or local stream");
          return;
        }
        try {
          setApiUsageStats((prev) => ({
            ...prev,
            sessionCount: (prev.sessionCount || 0) + 1
          }));
          const otherLanguages = otherParticipants.map((p) => GEMINI_LANGUAGE_MAP[p.language] || "english");
          liveAudioStreamRef.current = new GeminiLiveAudioStream({
            apiKey,
            sourceLanguage,
            targetLanguage,
            localPlaybackEnabled: isLocalPlaybackEnabledRef.current,
            // Speed optimization settings
            sendInterval: translationSpeedSettings.sendInterval,
            textBufferDelay: translationSpeedSettings.textBufferDelay,
            // Peer-to-peer translation configuration
            otherParticipantLanguages: otherLanguages,
            usePeerTranslation: true,
            onAudioReceived: async (audioData) => {
              debugLog("[Conference] Received translated audio (handled by GeminiLiveAudioStream internally)");
              await sendTranslatedAudioToParticipants(audioData);
            },
            onTextReceived: (text) => {
              debugLog("\u{1F3AF} [HOOKS] onTextReceived called with text:", text);
              debugLog("[Conference] Translated text received:", text);
              const newTranslation = {
                id: Date.now(),
                from: username,
                // Use actual username instead of 'Gemini AI'
                fromLanguage: myLanguage,
                original: text,
                // Show the received text as original
                translation: text,
                // And also as translation
                timestamp: (/* @__PURE__ */ new Date()).toLocaleTimeString()
              };
              debugLog("\u{1F4CB} [HOOKS] Adding translation to state:", newTranslation);
              setTranslations((prev) => {
                const updated = [...prev, newTranslation];
                debugLog("\u{1F4CA} [HOOKS] Updated translations array length:", updated.length);
                return updated;
              });
              debugLog("\u2705 [HOOKS] Translation added to state");
              if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                const translationMessage = {
                  type: "translation",
                  translation: newTranslation
                };
                debugLog("\u{1F4E4} [HOOKS] Sending translation to participants:", translationMessage);
                wsRef.current.send(JSON.stringify(translationMessage));
              }
            },
            onTokenUsage: (usage) => {
              debugLog("\u{1F4B0} [Token Usage] Update received:", {
                inputTokens: usage.inputTokens,
                outputTokens: usage.outputTokens,
                cost: usage.cost
              });
              debugLog("[Conference] Token usage update:", usage);
              setApiUsageStats((prev) => {
                const prevTotalUsage = prev.totalUsage || {
                  inputTokens: { text: 0, audio: 0 },
                  outputTokens: { text: 0, audio: 0 },
                  totalCost: 0
                };
                const prevSessionUsage = prev.sessionUsage || {
                  inputTokens: { text: 0, audio: 0 },
                  outputTokens: { text: 0, audio: 0 },
                  totalCost: 0
                };
                const newSessionUsage = {
                  inputTokens: {
                    text: prevSessionUsage.inputTokens.text,
                    audio: usage.inputTokens
                    // Gemini reports cumulative session total
                  },
                  outputTokens: {
                    text: prevSessionUsage.outputTokens.text,
                    audio: usage.outputTokens
                    // Gemini reports cumulative session total
                  },
                  totalCost: usage.cost
                  // Gemini reports cumulative session cost
                };
                const sessionDelta = {
                  inputTokens: newSessionUsage.inputTokens.audio - prevSessionUsage.inputTokens.audio,
                  outputTokens: newSessionUsage.outputTokens.audio - prevSessionUsage.outputTokens.audio,
                  cost: newSessionUsage.totalCost - prevSessionUsage.totalCost
                };
                const newTotalUsage = {
                  inputTokens: {
                    text: prevTotalUsage.inputTokens.text,
                    audio: prevTotalUsage.inputTokens.audio + sessionDelta.inputTokens
                  },
                  outputTokens: {
                    text: prevTotalUsage.outputTokens.text,
                    audio: prevTotalUsage.outputTokens.audio + sessionDelta.outputTokens
                  },
                  totalCost: prevTotalUsage.totalCost + sessionDelta.cost
                };
                debugLog("\u{1F4B0} [Token Usage] Updated stats:", {
                  sessionCost: newSessionUsage.totalCost,
                  totalCost: newTotalUsage.totalCost,
                  sessionDelta
                });
                return {
                  ...prev,
                  sessionUsage: newSessionUsage,
                  totalUsage: newTotalUsage
                };
              });
            },
            onError: (error) => {
              console.error("[Conference] Gemini Live Audio error:", error);
              setErrorMessage(error.message);
              setShowErrorModal(true);
            }
          });
          await liveAudioStreamRef.current.start(localStreamRef.current);
          debugLog("[Conference] Gemini Live Audio session started successfully");
        } catch (error) {
          console.error("[Conference] Failed to start Gemini Live Audio session:", error);
          liveAudioStreamRef.current = null;
        }
      } else {
        const otherLanguages = otherParticipants.map((p) => GEMINI_LANGUAGE_MAP[p.language] || "english");
        debugLog(`[Conference] Updating Gemini session with participant languages:`, otherLanguages);
        if (liveAudioStreamRef.current.updateOtherParticipantLanguages) {
          liveAudioStreamRef.current.updateOtherParticipantLanguages(otherLanguages);
        } else {
          const currentTargetLanguage = liveAudioStreamRef.current.getCurrentTargetLanguage();
          if (targetLanguage !== currentTargetLanguage) {
            debugLog(`[Conference] Updating Gemini target language: ${currentTargetLanguage} \u2192 ${targetLanguage}`);
            await liveAudioStreamRef.current.updateTargetLanguage(targetLanguage);
          } else {
            debugLog(`[Conference] Target language already set to ${targetLanguage}, no update needed`);
          }
        }
      }
    };
    const sendTranslatedAudioToParticipants = async (audioData) => {
      try {
        if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
          console.warn("[Conference] WebSocket not available, cannot send translated audio");
          return;
        }
        debugLog(`\u{1F4E1} [Audio Send] Converting ${audioData.byteLength} bytes to Base64...`);
        const base64Audio = arrayBufferToBase64(audioData);
        debugLog(`\u{1F4E1} [Audio Send] Base64 conversion completed: ${base64Audio.length} characters`);
        debugLog(`\u{1F4E1} [Audio Send] Base64 preview: ${base64Audio.substring(0, 100)}...`);
        infoLog(`\u{1F4E4} [Audio Send] Sending translated audio (${audioData.byteLength} bytes)`);
        debugLog(`[Conference] Sending translated audio to participants (${audioData.byteLength} bytes)`);
        wsRef.current.send(JSON.stringify({
          type: "translated-audio",
          audioData: base64Audio,
          audioFormat: "pcm-24khz-16bit",
          from: username,
          fromLanguage: myLanguage,
          timestamp: Date.now()
        }));
        debugLog("[Conference] Translated audio sent to participants");
      } catch (error) {
        console.error("[Conference] Failed to send translated audio:", error);
      }
    };
    const generateTranslationAudio = (0, import_react.useCallback)(async (translatedText, targetLanguage, originalText, fromLanguage) => {
      if (!isAudioTranslationEnabled) {
        return;
      }
      try {
        debugLog(`[Conference] Audio translation requested: "${translatedText}"`);
      } catch (error) {
        console.error("Audio generation error:", error);
      }
    }, [isAudioTranslationEnabled, voiceSettings, username]);
    const toggleAudioTranslation = (0, import_react.useCallback)(() => {
      setIsAudioTranslationEnabled((prev) => {
        const newValue = !prev;
        isAudioTranslationEnabledRef.current = newValue;
        return newValue;
      });
    }, []);
    (0, import_react.useEffect)(() => {
      isAudioTranslationEnabledRef.current = isAudioTranslationEnabled;
    }, [isAudioTranslationEnabled]);
    const updateVoiceSettings = (0, import_react.useCallback)((newSettings) => {
      setVoiceSettings((prev) => ({ ...prev, ...newSettings }));
    }, []);
    const updateTranslationSpeedMode = (0, import_react.useCallback)((mode) => {
      let settings;
      switch (mode) {
        case "ultrafast" /* ULTRAFAST */:
          settings = {
            mode: "ultrafast" /* ULTRAFAST */,
            sendInterval: 100,
            textBufferDelay: 200,
            estimatedCostMultiplier: 15
          };
          break;
        case "realtime" /* REALTIME */:
          settings = {
            mode: "realtime" /* REALTIME */,
            sendInterval: 300,
            textBufferDelay: 500,
            estimatedCostMultiplier: 5
          };
          break;
        case "balanced" /* BALANCED */:
          settings = {
            mode: "balanced" /* BALANCED */,
            sendInterval: 800,
            textBufferDelay: 1e3,
            estimatedCostMultiplier: 2
          };
          break;
        case "economy" /* ECONOMY */:
        default:
          settings = {
            mode: "economy" /* ECONOMY */,
            sendInterval: 1500,
            textBufferDelay: 2e3,
            estimatedCostMultiplier: 1
          };
          break;
      }
      setTranslationSpeedMode(mode);
      setTranslationSpeedSettings(settings);
      if (liveAudioStreamRef.current) {
        liveAudioStreamRef.current.updateSpeedSettings(settings.sendInterval, settings.textBufferDelay);
      }
      localStorage.setItem("translationSpeedMode", mode);
      debugLog(`[Translation Speed] Updated to ${mode} mode - Send: ${settings.sendInterval}ms, Buffer: ${settings.textBufferDelay}ms`);
    }, []);
    (0, import_react.useEffect)(() => {
      return () => {
        audioTranslations.forEach((translation) => {
          if (translation.audioUrl) {
            URL.revokeObjectURL(translation.audioUrl);
          }
        });
      };
    }, [audioTranslations]);
    const calculateTokenCost = (inputTokens, outputTokens) => {
      const INPUT_COST_TEXT = 0.5 / 1e6;
      const INPUT_COST_AUDIO = 3 / 1e6;
      const OUTPUT_COST_TEXT = 2 / 1e6;
      const OUTPUT_COST_AUDIO = 12 / 1e6;
      return inputTokens.text * INPUT_COST_TEXT + inputTokens.audio * INPUT_COST_AUDIO + outputTokens.text * OUTPUT_COST_TEXT + outputTokens.audio * OUTPUT_COST_AUDIO;
    };
    const updateApiUsage = (inputTokens, outputTokens) => {
      const cost = calculateTokenCost(inputTokens, outputTokens);
      setApiUsageStats((prev) => {
        const newSessionUsage = {
          inputTokens: {
            text: prev.sessionUsage.inputTokens.text + inputTokens.text,
            audio: prev.sessionUsage.inputTokens.audio + inputTokens.audio
          },
          outputTokens: {
            text: prev.sessionUsage.outputTokens.text + outputTokens.text,
            audio: prev.sessionUsage.outputTokens.audio + outputTokens.audio
          },
          totalCost: prev.sessionUsage.totalCost + cost
        };
        const newTotalUsage = {
          inputTokens: {
            text: prev.totalUsage.inputTokens.text + inputTokens.text,
            audio: prev.totalUsage.inputTokens.audio + inputTokens.audio
          },
          outputTokens: {
            text: prev.totalUsage.outputTokens.text + outputTokens.text,
            audio: prev.totalUsage.outputTokens.audio + outputTokens.audio
          },
          totalCost: prev.totalUsage.totalCost + cost
        };
        localStorage.setItem("geminiApiUsage", JSON.stringify(newTotalUsage));
        return {
          sessionUsage: newSessionUsage,
          totalUsage: newTotalUsage,
          sessionCount: prev.sessionCount
        };
      });
    };
    const resetSessionUsage = () => {
      setApiUsageStats((prev) => ({
        ...prev,
        sessionUsage: {
          inputTokens: { text: 0, audio: 0 },
          outputTokens: { text: 0, audio: 0 },
          totalCost: 0
        }
      }));
    };
    return {
      // State
      apiKey,
      setApiKey,
      username,
      setUsername,
      roomId,
      setRoomId,
      isConnected,
      setIsConnected,
      isInConference,
      setIsInConference,
      isMuted,
      setIsMuted,
      isScreenSharing,
      setIsScreenSharing,
      isCameraOn,
      setIsCameraOn,
      isBackgroundBlur,
      setIsBackgroundBlur,
      isBeautyMode,
      setIsBeautyMode,
      brightness,
      setBrightness,
      showCameraSettings,
      setShowCameraSettings,
      myLanguage,
      setMyLanguage,
      translations,
      setTranslations,
      participants,
      setParticipants,
      showSettings,
      setShowSettings,
      showRoomUrl,
      setShowRoomUrl,
      showCopyModal,
      setShowCopyModal,
      remoteScreenSharer,
      setRemoteScreenSharer,
      isHandRaised,
      setIsHandRaised,
      showChat,
      toggleChat,
      showReactions,
      setShowReactions,
      chatMessages,
      setChatMessages,
      chatInput,
      setChatInput,
      unreadMessageCount,
      setUnreadMessageCount,
      showAudioSettings,
      setShowAudioSettings,
      audioInputDevices,
      audioOutputDevices,
      selectedMicrophone,
      showErrorModal,
      setShowErrorModal,
      errorMessage,
      selectedSpeaker,
      sendRawAudio,
      isLocalPlaybackEnabled,
      // Refs
      videoRef,
      canvasRef,
      screenPreviewRef,
      // Functions
      startConference,
      endConference,
      shareRoomUrl,
      toggleMute,
      toggleScreenShare,
      toggleCamera,
      applyVideoEffects,
      toggleHandRaise,
      sendReaction,
      sendChatMessage,
      getAudioDevices,
      changeMicrophone,
      changeSpeaker,
      toggleSendRawAudio,
      toggleLocalPlayback,
      // Noise filter
      noiseFilterSettings,
      updateNoiseFilterSettings,
      toggleNoiseFilter,
      // Audio translation
      audioTranslations,
      isAudioTranslationEnabled,
      voiceSettings,
      generateTranslationAudio,
      toggleAudioTranslation,
      updateVoiceSettings,
      // API usage tracking
      apiUsageStats,
      updateApiUsage,
      resetSessionUsage,
      // Gemini speaking state
      isGeminiSpeaking,
      // Translation speed settings
      translationSpeedMode,
      translationSpeedSettings,
      updateTranslationSpeedMode
    };
  };

  // components.tsx
  var import_react5 = __toESM(require_react());

  // node_modules/lucide-react/dist/esm/createLucideIcon.js
  var import_react3 = __toESM(require_react());

  // node_modules/lucide-react/dist/esm/shared/src/utils.js
  var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  var toCamelCase = (string) => string.replace(
    /^([A-Z])|[\s-_]+(\w)/g,
    (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
  );
  var toPascalCase = (string) => {
    const camelCase = toCamelCase(string);
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
  };
  var mergeClasses = (...classes) => classes.filter((className, index, array) => {
    return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
  }).join(" ").trim();
  var hasA11yProp = (props) => {
    for (const prop in props) {
      if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
        return true;
      }
    }
  };

  // node_modules/lucide-react/dist/esm/Icon.js
  var import_react2 = __toESM(require_react());

  // node_modules/lucide-react/dist/esm/defaultAttributes.js
  var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  };

  // node_modules/lucide-react/dist/esm/Icon.js
  var Icon = (0, import_react2.forwardRef)(
    ({
      color = "currentColor",
      size = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      iconNode,
      ...rest
    }, ref) => (0, import_react2.createElement)(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => (0, import_react2.createElement)(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    )
  );

  // node_modules/lucide-react/dist/esm/createLucideIcon.js
  var createLucideIcon = (iconName, iconNode) => {
    const Component = (0, import_react3.forwardRef)(
      ({ className, ...props }, ref) => (0, import_react3.createElement)(Icon, {
        ref,
        iconNode,
        className: mergeClasses(
          `lucide-${toKebabCase(toPascalCase(iconName))}`,
          `lucide-${iconName}`,
          className
        ),
        ...props
      })
    );
    Component.displayName = toPascalCase(iconName);
    return Component;
  };

  // node_modules/lucide-react/dist/esm/icons/copy.js
  var __iconNode = [
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
  ];
  var Copy = createLucideIcon("copy", __iconNode);

  // node_modules/lucide-react/dist/esm/icons/funnel.js
  var __iconNode2 = [
    [
      "path",
      {
        d: "M10 20a1 1 0 0 0 .553.895l2 1A1 1 0 0 0 14 21v-7a2 2 0 0 1 .517-1.341L21.74 4.67A1 1 0 0 0 21 3H3a1 1 0 0 0-.742 1.67l7.225 7.989A2 2 0 0 1 10 14z",
        key: "sc7q7i"
      }
    ]
  ];
  var Funnel = createLucideIcon("funnel", __iconNode2);

  // node_modules/lucide-react/dist/esm/icons/hand.js
  var __iconNode3 = [
    ["path", { d: "M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2", key: "1fvzgz" }],
    ["path", { d: "M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2", key: "1kc0my" }],
    ["path", { d: "M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8", key: "10h0bg" }],
    [
      "path",
      {
        d: "M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15",
        key: "1s1gnw"
      }
    ]
  ];
  var Hand = createLucideIcon("hand", __iconNode3);

  // node_modules/lucide-react/dist/esm/icons/headphones.js
  var __iconNode4 = [
    [
      "path",
      {
        d: "M3 14h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-7a9 9 0 0 1 18 0v7a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3",
        key: "1xhozi"
      }
    ]
  ];
  var Headphones = createLucideIcon("headphones", __iconNode4);

  // node_modules/lucide-react/dist/esm/icons/heart.js
  var __iconNode5 = [
    [
      "path",
      {
        d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
        key: "c3ymky"
      }
    ]
  ];
  var Heart = createLucideIcon("heart", __iconNode5);

  // node_modules/lucide-react/dist/esm/icons/languages.js
  var __iconNode6 = [
    ["path", { d: "m5 8 6 6", key: "1wu5hv" }],
    ["path", { d: "m4 14 6-6 2-3", key: "1k1g8d" }],
    ["path", { d: "M2 5h12", key: "or177f" }],
    ["path", { d: "M7 2h1", key: "1t2jsx" }],
    ["path", { d: "m22 22-5-10-5 10", key: "don7ne" }],
    ["path", { d: "M14 18h6", key: "1m8k6r" }]
  ];
  var Languages = createLucideIcon("languages", __iconNode6);

  // node_modules/lucide-react/dist/esm/icons/message-circle.js
  var __iconNode7 = [
    ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z", key: "vv11sd" }]
  ];
  var MessageCircle = createLucideIcon("message-circle", __iconNode7);

  // node_modules/lucide-react/dist/esm/icons/mic-off.js
  var __iconNode8 = [
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22", key: "a6p6uj" }],
    ["path", { d: "M18.89 13.23A7.12 7.12 0 0 0 19 12v-2", key: "80xlxr" }],
    ["path", { d: "M5 10v2a7 7 0 0 0 12 5", key: "p2k8kg" }],
    ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33", key: "1gzdoj" }],
    ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12", key: "r2i35w" }],
    ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }]
  ];
  var MicOff = createLucideIcon("mic-off", __iconNode8);

  // node_modules/lucide-react/dist/esm/icons/mic.js
  var __iconNode9 = [
    ["path", { d: "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z", key: "131961" }],
    ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
    ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }]
  ];
  var Mic = createLucideIcon("mic", __iconNode9);

  // node_modules/lucide-react/dist/esm/icons/monitor-off.js
  var __iconNode10 = [
    ["path", { d: "M17 17H4a2 2 0 0 1-2-2V5c0-1.5 1-2 1-2", key: "k0q8oc" }],
    ["path", { d: "M22 15V5a2 2 0 0 0-2-2H9", key: "cp1ac0" }],
    ["path", { d: "M8 21h8", key: "1ev6f3" }],
    ["path", { d: "M12 17v4", key: "1riwvh" }],
    ["path", { d: "m2 2 20 20", key: "1ooewy" }]
  ];
  var MonitorOff = createLucideIcon("monitor-off", __iconNode10);

  // node_modules/lucide-react/dist/esm/icons/monitor.js
  var __iconNode11 = [
    ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2", key: "48i651" }],
    ["line", { x1: "8", x2: "16", y1: "21", y2: "21", key: "1svkeh" }],
    ["line", { x1: "12", x2: "12", y1: "17", y2: "21", key: "vw1qmm" }]
  ];
  var Monitor = createLucideIcon("monitor", __iconNode11);

  // node_modules/lucide-react/dist/esm/icons/phone-off.js
  var __iconNode12 = [
    [
      "path",
      {
        d: "M10.1 13.9a14 14 0 0 0 3.732 2.668 1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2 18 18 0 0 1-12.728-5.272",
        key: "1wngk7"
      }
    ],
    ["path", { d: "M22 2 2 22", key: "y4kqgn" }],
    [
      "path",
      {
        d: "M4.76 13.582A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 .244.473",
        key: "10hv5p"
      }
    ]
  ];
  var PhoneOff = createLucideIcon("phone-off", __iconNode12);

  // node_modules/lucide-react/dist/esm/icons/phone.js
  var __iconNode13 = [
    [
      "path",
      {
        d: "M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384",
        key: "9njp5v"
      }
    ]
  ];
  var Phone = createLucideIcon("phone", __iconNode13);

  // node_modules/lucide-react/dist/esm/icons/settings.js
  var __iconNode14 = [
    [
      "path",
      {
        d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
        key: "1qme2f"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
  ];
  var Settings = createLucideIcon("settings", __iconNode14);

  // node_modules/lucide-react/dist/esm/icons/share-2.js
  var __iconNode15 = [
    ["circle", { cx: "18", cy: "5", r: "3", key: "gq8acd" }],
    ["circle", { cx: "6", cy: "12", r: "3", key: "w7nqdw" }],
    ["circle", { cx: "18", cy: "19", r: "3", key: "1xt0gg" }],
    ["line", { x1: "8.59", x2: "15.42", y1: "13.51", y2: "17.49", key: "47mynk" }],
    ["line", { x1: "15.41", x2: "8.59", y1: "6.51", y2: "10.49", key: "1n3mei" }]
  ];
  var Share2 = createLucideIcon("share-2", __iconNode15);

  // node_modules/lucide-react/dist/esm/icons/sparkles.js
  var __iconNode16 = [
    [
      "path",
      {
        d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z",
        key: "4pj2yx"
      }
    ],
    ["path", { d: "M20 3v4", key: "1olli1" }],
    ["path", { d: "M22 5h-4", key: "1gvqau" }],
    ["path", { d: "M4 17v2", key: "vumght" }],
    ["path", { d: "M5 18H3", key: "zchphs" }]
  ];
  var Sparkles = createLucideIcon("sparkles", __iconNode16);

  // node_modules/lucide-react/dist/esm/icons/sun.js
  var __iconNode17 = [
    ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }],
    ["path", { d: "M12 2v2", key: "tus03m" }],
    ["path", { d: "M12 20v2", key: "1lh1kg" }],
    ["path", { d: "m4.93 4.93 1.41 1.41", key: "149t6j" }],
    ["path", { d: "m17.66 17.66 1.41 1.41", key: "ptbguv" }],
    ["path", { d: "M2 12h2", key: "1t8f8n" }],
    ["path", { d: "M20 12h2", key: "1q8mjw" }],
    ["path", { d: "m6.34 17.66-1.41 1.41", key: "1m8zz5" }],
    ["path", { d: "m19.07 4.93-1.41 1.41", key: "1shlcs" }]
  ];
  var Sun = createLucideIcon("sun", __iconNode17);

  // node_modules/lucide-react/dist/esm/icons/users.js
  var __iconNode18 = [
    ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
    ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744", key: "16gr8j" }],
    ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
    ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
  ];
  var Users = createLucideIcon("users", __iconNode18);

  // node_modules/lucide-react/dist/esm/icons/video-off.js
  var __iconNode19 = [
    [
      "path",
      { d: "M10.66 6H14a2 2 0 0 1 2 2v2.5l5.248-3.062A.5.5 0 0 1 22 7.87v8.196", key: "w8jjjt" }
    ],
    ["path", { d: "M16 16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2", key: "1xawa7" }],
    ["path", { d: "m2 2 20 20", key: "1ooewy" }]
  ];
  var VideoOff = createLucideIcon("video-off", __iconNode19);

  // node_modules/lucide-react/dist/esm/icons/video.js
  var __iconNode20 = [
    [
      "path",
      {
        d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
        key: "ftymec"
      }
    ],
    ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]
  ];
  var Video = createLucideIcon("video", __iconNode20);

  // node_modules/lucide-react/dist/esm/icons/volume-2.js
  var __iconNode21 = [
    [
      "path",
      {
        d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
        key: "uqj9uw"
      }
    ],
    ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
    ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]
  ];
  var Volume2 = createLucideIcon("volume-2", __iconNode21);

  // components.tsx
  init_translation_prompts();

  // generative-art-background-webgl.tsx
  var import_react4 = __toESM(require_react());
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var vertexShaderSource = `
  attribute vec2 a_position;
  attribute vec2 a_velocity;
  attribute float a_age;
  attribute float a_lifespan;
  attribute vec3 a_color;
  
  uniform vec2 u_resolution;
  uniform float u_time;
  
  varying float v_alpha;
  varying vec3 v_color;
  
  void main() {
    vec2 position = a_position / u_resolution * 2.0 - 1.0;
    gl_Position = vec4(position * vec2(1, -1), 0, 1);
    
    float lifeFactor = a_age / a_lifespan;
    float fadeIn = min(1.0, a_age / 20.0);
    float fadeOut = 1.0 - lifeFactor * lifeFactor;
    v_alpha = fadeIn * fadeOut * 0.8;
    
    float speed = length(a_velocity);
    v_color = a_color + vec3(speed * 0.1);
    
    gl_PointSize = 2.0 + speed * 2.0;
  }
`;
  var fragmentShaderSource = `
  precision mediump float;
  
  varying float v_alpha;
  varying vec3 v_color;
  
  void main() {
    vec2 coord = gl_PointCoord - vec2(0.5);
    float dist = length(coord);
    
    if (dist > 0.5) {
      discard;
    }
    
    float alpha = v_alpha * (1.0 - dist * 2.0);
    gl_FragColor = vec4(v_color, alpha);
  }
`;
  var PerlinNoise = class {
    permutation;
    p;
    constructor() {
      this.permutation = [];
      for (let i = 0; i < 256; i++) {
        this.permutation[i] = i;
      }
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
      }
      this.p = [];
      for (let i = 0; i < 512; i++) {
        this.p[i] = this.permutation[i % 256];
      }
    }
    fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }
    lerp(t, a, b) {
      return a + t * (b - a);
    }
    grad(hash, x, y) {
      const h = hash & 3;
      const u = h < 2 ? x : y;
      const v = h < 2 ? y : x;
      return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    }
    noise(x, y) {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      const u = this.fade(x);
      const v = this.fade(y);
      const a = this.p[X] + Y;
      const aa = this.p[a];
      const ab = this.p[a + 1];
      const b = this.p[X + 1] + Y;
      const ba = this.p[b];
      const bb = this.p[b + 1];
      return this.lerp(
        v,
        this.lerp(u, this.grad(this.p[aa], x, y), this.grad(this.p[ba], x - 1, y)),
        this.lerp(u, this.grad(this.p[ab], x, y - 1), this.grad(this.p[bb], x - 1, y - 1))
      );
    }
  };
  var GenerativeArtBackgroundWebGL = ({
    isInConference = false,
    onGeminiSpeaking = false
  }) => {
    const canvasRef = (0, import_react4.useRef)(null);
    const animationRef = (0, import_react4.useRef)(void 0);
    const glRef = (0, import_react4.useRef)(null);
    const programRef = (0, import_react4.useRef)(null);
    const noiseRef = (0, import_react4.useRef)(new PerlinNoise());
    const mouseRef = (0, import_react4.useRef)({ x: 0, y: 0 });
    const particleDataRef = (0, import_react4.useRef)(null);
    const [dimensions, setDimensions] = (0, import_react4.useState)({ width: window.innerWidth, height: window.innerHeight });
    const particleCount = 5e3;
    const scale = 30;
    const inc = 0.05;
    let zoff = 0;
    const geminiCenterX = dimensions.width / 2;
    const geminiCenterY = dimensions.height / 2;
    const geminiRadius = 100;
    const geminiPulseRef = (0, import_react4.useRef)(0);
    const createShader = (gl, type, source) => {
      const shader = gl.createShader(type);
      if (!shader) return null;
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Shader compile error:", gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    };
    const createProgram = (gl) => {
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
      if (!vertexShader || !fragmentShader) return null;
      const program = gl.createProgram();
      if (!program) return null;
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program link error:", gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    };
    (0, import_react4.useEffect)(() => {
      const handleResize = () => {
        setDimensions({ width: window.innerWidth, height: window.innerHeight });
      };
      window.addEventListener("resize", handleResize);
      return () => window.removeEventListener("resize", handleResize);
    }, []);
    (0, import_react4.useEffect)(() => {
      const handleMouseMove = (e) => {
        mouseRef.current = { x: e.clientX, y: e.clientY };
      };
      const handleTouchMove = (e) => {
        if (e.touches.length > 0) {
          mouseRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      };
      window.addEventListener("mousemove", handleMouseMove);
      window.addEventListener("touchmove", handleTouchMove);
      return () => {
        window.removeEventListener("mousemove", handleMouseMove);
        window.removeEventListener("touchmove", handleTouchMove);
      };
    }, []);
    (0, import_react4.useEffect)(() => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      canvas.width = dimensions.width;
      canvas.height = dimensions.height;
      let gl = glRef.current;
      if (!gl) {
        gl = canvas.getContext("webgl", {
          alpha: true,
          premultipliedAlpha: false,
          preserveDrawingBuffer: true
        });
        if (!gl) {
          console.error("WebGL not supported");
          return;
        }
        glRef.current = gl;
      }
      gl.viewport(0, 0, dimensions.width, dimensions.height);
      let program = programRef.current;
      if (!program) {
        program = createProgram(gl);
        if (!program) return;
        programRef.current = program;
      }
      gl.useProgram(program);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.clearColor(0.039, 0.039, 0.078, 1);
      const positionLoc = gl.getAttribLocation(program, "a_position");
      const velocityLoc = gl.getAttribLocation(program, "a_velocity");
      const ageLoc = gl.getAttribLocation(program, "a_age");
      const lifespanLoc = gl.getAttribLocation(program, "a_lifespan");
      const colorLoc = gl.getAttribLocation(program, "a_color");
      const resolutionLoc = gl.getUniformLocation(program, "u_resolution");
      const timeLoc = gl.getUniformLocation(program, "u_time");
      if (!particleDataRef.current) {
        particleDataRef.current = {
          positions: new Float32Array(particleCount * 2),
          velocities: new Float32Array(particleCount * 2),
          ages: new Float32Array(particleCount),
          lifespans: new Float32Array(particleCount),
          colors: new Float32Array(particleCount * 3),
          maxSpeeds: new Float32Array(particleCount),
          initialized: false
        };
      }
      const { positions, velocities, ages, lifespans, colors, maxSpeeds } = particleDataRef.current;
      if (!particleDataRef.current.initialized) {
        for (let i = 0; i < particleCount; i++) {
          positions[i * 2] = Math.random() * dimensions.width;
          positions[i * 2 + 1] = Math.random() * dimensions.height;
          velocities[i * 2] = 0;
          velocities[i * 2 + 1] = 0;
          ages[i] = 0;
          lifespans[i] = 300 + Math.random() * 700;
          maxSpeeds[i] = 1 + Math.random() * 3;
          const colorChoice = Math.random();
          let r, g, b;
          if (colorChoice < 0.4) {
            r = 0.4 + Math.random() * 0.2;
            g = 0.2 + Math.random() * 0.3;
            b = 0.8 + Math.random() * 0.2;
          } else if (colorChoice < 0.6) {
            r = 0.8 + Math.random() * 0.2;
            g = 0.3 + Math.random() * 0.3;
            b = 0.6 + Math.random() * 0.3;
          } else if (colorChoice < 0.75) {
            r = 0.9 + Math.random() * 0.1;
            g = 0.6 + Math.random() * 0.3;
            b = 0.2 + Math.random() * 0.2;
          } else if (colorChoice < 0.9) {
            r = 0.2 + Math.random() * 0.3;
            g = 0.7 + Math.random() * 0.3;
            b = 0.8 + Math.random() * 0.2;
          } else {
            r = 0.9 + Math.random() * 0.1;
            g = 0.2 + Math.random() * 0.2;
            b = 0.2 + Math.random() * 0.2;
          }
          colors[i * 3] = r;
          colors[i * 3 + 1] = g;
          colors[i * 3 + 2] = b;
        }
        particleDataRef.current.initialized = true;
      }
      const positionBuffer = gl.createBuffer();
      const velocityBuffer = gl.createBuffer();
      const ageBuffer = gl.createBuffer();
      const lifespanBuffer = gl.createBuffer();
      const colorBuffer = gl.createBuffer();
      let time = 0;
      const animate = () => {
        if (!gl || !program || !canvas) return;
        if (canvas.width !== dimensions.width || canvas.height !== dimensions.height) {
          canvas.width = dimensions.width;
          canvas.height = dimensions.height;
          gl.viewport(0, 0, dimensions.width, dimensions.height);
        }
        gl.clearColor(0.039, 0.039, 0.078, 0.02);
        gl.clear(gl.COLOR_BUFFER_BIT);
        const cols = Math.floor(dimensions.width / scale);
        const rows = Math.floor(dimensions.height / scale);
        if (isInConference) {
          geminiPulseRef.current += onGeminiSpeaking ? 0.15 : 0.05;
        }
        for (let i = 0; i < particleCount; i++) {
          const x = Math.floor(positions[i * 2] / scale);
          const y = Math.floor(positions[i * 2 + 1] / scale);
          if (x >= 0 && x < cols && y >= 0 && y < rows) {
            const xoff = x * inc;
            const yoff = y * inc;
            const noise1 = noiseRef.current.noise(xoff, yoff + zoff);
            const noise2 = noiseRef.current.noise(xoff * 2, yoff * 2 + zoff * 0.5) * 0.5;
            const noise3 = noiseRef.current.noise(xoff * 4, yoff * 4 + zoff * 0.25) * 0.25;
            let angle = (noise1 + noise2 + noise3) * Math.PI * 4;
            angle += Math.sin(zoff * 2 + x * 0.1) * 0.5;
            angle += Math.cos(zoff * 1.5 + y * 0.1) * 0.3;
            const mouseDist = Math.sqrt(
              Math.pow(mouseRef.current.x - positions[i * 2], 2) + Math.pow(mouseRef.current.y - positions[i * 2 + 1], 2)
            );
            if (mouseDist < 150) {
              const mouseInfluence = (150 - mouseDist) / 150;
              const mouseAngle = Math.atan2(
                mouseRef.current.y - positions[i * 2 + 1],
                mouseRef.current.x - positions[i * 2]
              );
              angle += mouseInfluence * (mouseAngle + Math.PI * 0.5);
            }
            const forceMultiplier = 0.5 + Math.random() * 0.5;
            velocities[i * 2] += Math.cos(angle) * forceMultiplier * 0.5;
            velocities[i * 2 + 1] += Math.sin(angle) * forceMultiplier * 0.5;
          }
          if (isInConference) {
            const dxToGemini = geminiCenterX - positions[i * 2];
            const dyToGemini = geminiCenterY - positions[i * 2 + 1];
            const distToGemini = Math.sqrt(dxToGemini * dxToGemini + dyToGemini * dyToGemini);
            const targetRadius = geminiRadius + Math.sin(geminiPulseRef.current + i * 0.1) * 20;
            if (distToGemini < targetRadius * 3) {
              const angleToGemini = Math.atan2(dyToGemini, dxToGemini);
              const targetX = geminiCenterX - Math.cos(angleToGemini) * targetRadius;
              const targetY = geminiCenterY - Math.sin(angleToGemini) * targetRadius;
              const attractionForce = 0.1;
              velocities[i * 2] += (targetX - positions[i * 2]) * attractionForce;
              velocities[i * 2 + 1] += (targetY - positions[i * 2 + 1]) * attractionForce;
              const orbitalSpeed = onGeminiSpeaking ? 0.05 : 0.02;
              velocities[i * 2] += -dyToGemini / distToGemini * orbitalSpeed;
              velocities[i * 2 + 1] += dxToGemini / distToGemini * orbitalSpeed;
            }
          }
          velocities[i * 2] *= 0.98;
          velocities[i * 2 + 1] *= 0.98;
          const speed = Math.sqrt(velocities[i * 2] * velocities[i * 2] + velocities[i * 2 + 1] * velocities[i * 2 + 1]);
          if (speed > maxSpeeds[i]) {
            velocities[i * 2] = velocities[i * 2] / speed * maxSpeeds[i];
            velocities[i * 2 + 1] = velocities[i * 2 + 1] / speed * maxSpeeds[i];
          }
          positions[i * 2] += velocities[i * 2];
          positions[i * 2 + 1] += velocities[i * 2 + 1];
          ages[i]++;
          if (ages[i] > lifespans[i] || positions[i * 2] < 0 || positions[i * 2] > dimensions.width || positions[i * 2 + 1] < 0 || positions[i * 2 + 1] > dimensions.height) {
            positions[i * 2] = Math.random() * dimensions.width;
            positions[i * 2 + 1] = Math.random() * dimensions.height;
            velocities[i * 2] = 0;
            velocities[i * 2 + 1] = 0;
            ages[i] = 0;
            lifespans[i] = 300 + Math.random() * 700;
          }
        }
        zoff += 2e-3;
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, velocities, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(velocityLoc);
        gl.vertexAttribPointer(velocityLoc, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, ageBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, ages, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(ageLoc);
        gl.vertexAttribPointer(ageLoc, 1, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, lifespanBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, lifespans, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(lifespanLoc);
        gl.vertexAttribPointer(lifespanLoc, 1, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(colorLoc);
        gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
        gl.uniform2f(resolutionLoc, dimensions.width, dimensions.height);
        gl.uniform1f(timeLoc, time * 1e-3);
        gl.drawArrays(gl.POINTS, 0, particleCount);
        time++;
        animationRef.current = requestAnimationFrame(animate);
      };
      animate();
      return () => {
        if (animationRef.current) {
          cancelAnimationFrame(animationRef.current);
        }
      };
    }, [dimensions]);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "canvas",
      {
        ref: canvasRef,
        className: "fixed inset-0 w-full h-full pointer-events-none",
        style: {
          zIndex: 0
        }
      }
    );
  };

  // components.tsx
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  var ConferenceApp = ({
    apiKey,
    setApiKey,
    username,
    setUsername,
    roomId,
    isConnected,
    isInConference,
    isMuted,
    isScreenSharing,
    isCameraOn,
    isBackgroundBlur,
    setIsBackgroundBlur,
    isBeautyMode,
    setIsBeautyMode,
    brightness,
    setBrightness,
    showCameraSettings,
    setShowCameraSettings,
    myLanguage,
    setMyLanguage,
    translations,
    participants,
    showSettings,
    setShowSettings,
    showCopyModal,
    videoRef,
    canvasRef,
    screenPreviewRef,
    remoteScreenSharer,
    isHandRaised,
    showChat,
    toggleChat,
    unreadMessageCount,
    showAudioSettings,
    setShowAudioSettings,
    audioInputDevices,
    audioOutputDevices,
    selectedMicrophone,
    selectedSpeaker,
    getAudioDevices,
    changeMicrophone,
    changeSpeaker,
    sendRawAudio,
    toggleSendRawAudio,
    noiseFilterSettings,
    updateNoiseFilterSettings,
    toggleNoiseFilter,
    showReactions,
    setShowReactions,
    chatMessages,
    chatInput,
    setChatInput,
    startConference,
    endConference,
    shareRoomUrl,
    toggleMute,
    toggleScreenShare,
    toggleCamera,
    toggleHandRaise,
    sendReaction,
    sendChatMessage,
    // Audio translation props
    audioTranslations,
    isAudioTranslationEnabled,
    voiceSettings,
    generateTranslationAudio,
    toggleAudioTranslation,
    updateVoiceSettings,
    // API usage tracking props
    apiUsageStats,
    updateApiUsage,
    resetSessionUsage,
    // Local playback control props
    isLocalPlaybackEnabled,
    toggleLocalPlayback,
    // Error modal props
    showErrorModal,
    errorMessage,
    setShowErrorModal,
    // Gemini speaking state
    isGeminiSpeaking,
    // Translation speed settings
    translationSpeedMode,
    translationSpeedSettings,
    updateTranslationSpeedMode
  }) => {
    const translationsRef = (0, import_react5.useRef)(null);
    (0, import_react5.useEffect)(() => {
      if (translationsRef.current) {
        translationsRef.current.scrollTop = translationsRef.current.scrollHeight;
      }
    }, [translations]);
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "min-h-screen bg-gray-900 text-white relative", children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
        GenerativeArtBackgroundWebGL,
        {
          isInConference,
          onGeminiSpeaking: isGeminiSpeaking
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "relative z-10", children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("header", { className: "bg-gray-800 bg-opacity-90 backdrop-blur-sm border-b border-gray-700 p-3", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "container mx-auto flex items-center justify-between", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "flex items-center gap-2", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h1", { className: "text-xl font-bold", children: "otak-conference" }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("p", { className: "text-xs text-gray-400", children: [
              "A New Era of AI Translation: Powered by LLMs",
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { className: "ml-2 text-gray-500", children: [
                "- ",
                "b9cc1b3"
              ] })
            ] })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center gap-3", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "hidden md:block text-xs text-gray-400 bg-gray-700 px-2 py-1 rounded", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex gap-3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { children: [
                "Sessions: ",
                apiUsageStats.sessionCount
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { children: [
                "Session: $",
                apiUsageStats.sessionUsage.totalCost.toFixed(4)
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { children: [
                "Total: $",
                apiUsageStats.totalUsage.totalCost.toFixed(4)
              ] })
            ] }) }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "md:hidden text-xs text-gray-400 bg-gray-700 px-2 py-1 rounded", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { className: "font-medium", children: [
              "S:",
              apiUsageStats.sessionCount,
              " $",
              apiUsageStats.sessionUsage.totalCost.toFixed(3)
            ] }) }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "button",
              {
                onClick: () => setShowSettings(!showSettings),
                className: "p-1.5 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors",
                children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Settings, { className: "w-4 h-4" })
              }
            )
          ] })
        ] }) }),
        (showSettings || !username || !apiKey) && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "bg-gray-800 bg-opacity-90 backdrop-blur-sm border-b border-gray-700 p-3", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "container mx-auto space-y-3", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("form", { onSubmit: (e) => e.preventDefault(), children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("label", { className: "block text-xs font-medium mb-1", children: "Username" }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "input",
              {
                type: "text",
                value: username,
                onChange: (e) => setUsername(e.target.value),
                placeholder: "Enter your username",
                className: "w-full px-2 py-1.5 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:border-blue-500 text-sm",
                disabled: isConnected
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("label", { className: "block text-xs font-medium mb-1", children: "Gemini API Key" }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "input",
              {
                type: "text",
                value: apiKey,
                onChange: (e) => setApiKey(e.target.value),
                placeholder: "Enter your Gemini API key",
                className: "w-full px-2 py-1.5 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:border-blue-500 text-sm",
                disabled: isConnected
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("label", { className: "block text-xs font-medium mb-1", children: "Your Language" }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "select",
              {
                value: myLanguage,
                onChange: (e) => setMyLanguage(e.target.value),
                className: "w-full px-2 py-1.5 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:border-blue-500 text-sm",
                disabled: isConnected,
                children: getAvailableLanguageOptions().map((option) => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("option", { value: option.value, children: [
                  option.nativeName,
                  " (",
                  option.label,
                  ")"
                ] }, option.value))
              }
            )
          ] })
        ] }) }) }),
        (isScreenSharing || remoteScreenSharer) && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "bg-gray-800 bg-opacity-90 backdrop-blur-sm border-b border-gray-700 p-3", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "container mx-auto", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("h3", { className: "text-base font-semibold mb-3 flex items-center gap-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Monitor, { className: "w-4 h-4" }),
            "Screen Share Preview",
            remoteScreenSharer && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { className: "text-xs text-gray-400", children: [
              "(from ",
              participants.find((p) => p.clientId === remoteScreenSharer)?.username || "Unknown",
              ")"
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "relative bg-black rounded-lg overflow-hidden max-w-xl mx-auto", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "video",
              {
                ref: screenPreviewRef,
                autoPlay: true,
                muted: true,
                playsInline: true,
                controls: false,
                className: "w-full h-auto max-h-72",
                style: { backgroundColor: "#000", minHeight: "160px" },
                onLoadedMetadata: () => console.log("Video metadata loaded in component"),
                onCanPlay: () => console.log("Video can play in component"),
                onError: (e) => console.error("Video error in component:", e)
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "absolute top-1 left-1 bg-black bg-opacity-50 text-white text-xs p-1 rounded", children: remoteScreenSharer ? "Remote Screen Share" : "Your Screen Share" })
          ] })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "container mx-auto p-3 grid grid-cols-1 lg:grid-cols-3 gap-3 pb-16", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "lg:col-span-1 bg-gray-800 bg-opacity-90 backdrop-blur-sm rounded-lg p-3 shadow-lg", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("h2", { className: "text-base font-semibold mb-3 flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Users, { className: "w-4 h-4" }),
              "Participants (",
              participants.length,
              "/2)"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "space-y-2", children: [
              participants.map((participant) => {
                const isCurrentUser = participant.username === username;
                const showReaction = participant.reaction && participant.reactionTimestamp && Date.now() - participant.reactionTimestamp < 3e3;
                return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
                  "div",
                  {
                    className: "p-2 bg-gray-700 rounded-lg flex items-center justify-between",
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center gap-2", children: [
                        /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { className: "text-xs", children: [
                          participant.username,
                          isCurrentUser && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-gray-400 ml-1", children: "(You)" })
                        ] }),
                        participant.isSpeaking && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { title: "Speaking", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Mic, { className: "w-3 h-3 text-green-500 animate-pulse" }) }),
                        participant.isHandRaised && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Hand, { className: "w-3 h-3 text-yellow-500" }),
                        showReaction && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-sm animate-bounce", children: participant.reaction })
                      ] }),
                      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-xs bg-gray-600 px-1.5 py-0.5 rounded", children: participant.language })
                    ]
                  },
                  participant.clientId
                );
              }),
              participants.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-gray-400 text-xs", children: "No participants yet" })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "lg:col-span-2 bg-gray-800 bg-opacity-90 backdrop-blur-sm rounded-lg p-3 shadow-lg", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center justify-between mb-3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("h2", { className: "text-base font-semibold flex items-center gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Languages, { className: "w-4 h-4" }),
                "Translations"
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
                "button",
                {
                  onClick: toggleLocalPlayback,
                  className: `flex items-center gap-1 px-2 py-1 rounded text-xs ${isLocalPlaybackEnabled ? "bg-blue-600 text-white" : "bg-gray-600 text-gray-300"}`,
                  title: `${isLocalPlaybackEnabled ? "Disable" : "Enable"} local playback of Gemini responses`,
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Volume2, { size: 12 }),
                    isLocalPlaybackEnabled ? "Local ON" : "Local OFF"
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
              "div",
              {
                ref: translationsRef,
                className: "space-y-2 h-[200px] overflow-y-auto custom-scrollbar",
                style: {
                  scrollbarWidth: "thin",
                  scrollbarColor: "#374151 #1f2937"
                },
                children: [
                  translations.map((translation) => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
                    "div",
                    {
                      className: "p-3 bg-gray-700 rounded-lg",
                      children: [
                        /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center justify-between text-xs text-gray-400 mb-2", children: [
                          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: translation.from }),
                          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: translation.timestamp })
                        ] }),
                        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-sm text-white leading-relaxed", children: translation.translation })
                      ]
                    },
                    translation.id
                  )),
                  translations.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-gray-400 text-center py-6 text-sm", children: "Translations will appear here..." })
                ]
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "fixed bottom-0 left-0 right-0 bg-gray-800 bg-opacity-90 backdrop-blur-sm border-t border-gray-700 p-3 z-20", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "container mx-auto", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "md:hidden space-y-3", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex justify-between items-center", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "flex justify-start", children: isInConference ? /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
                "button",
                {
                  onClick: endConference,
                  className: "py-1.5 px-3 bg-red-600 hover:bg-red-700 rounded-lg text-sm transition-colors flex items-center gap-1.5",
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(PhoneOff, { className: "w-3 h-3" }),
                    "Close Conference"
                  ]
                }
              ) : /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
                "button",
                {
                  onClick: startConference,
                  className: "py-1.5 px-3 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm transition-colors flex items-center gap-1.5",
                  disabled: !username || !apiKey,
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Phone, { className: "w-3 h-3" }),
                    "Start Conference"
                  ]
                }
              ) }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
                "button",
                {
                  onClick: shareRoomUrl,
                  className: "py-1.5 px-3 bg-green-600 hover:bg-green-700 rounded-lg text-sm transition-colors flex items-center gap-1.5",
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Share2, { className: "w-3 h-3" }),
                    "Share"
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex justify-center gap-1.5 flex-wrap", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "relative", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "button",
                  {
                    onClick: toggleMute,
                    disabled: !isInConference,
                    className: `p-2 rounded-full transition-colors ${!isInConference ? "bg-gray-700 opacity-50 cursor-not-allowed" : isMuted ? "bg-gray-700 hover:bg-gray-600" : "bg-green-600 hover:bg-green-700"}`,
                    children: isMuted ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(MicOff, { className: "w-4 h-4" }) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Mic, { className: "w-4 h-4" })
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "button",
                  {
                    onClick: () => setShowAudioSettings(true),
                    className: "absolute -top-0.5 -right-0.5 p-0.5 bg-blue-600 hover:bg-blue-700 rounded-full transition-colors",
                    children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Settings, { className: "w-2.5 h-2.5" })
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "button",
                {
                  onClick: toggleScreenShare,
                  disabled: !isInConference,
                  className: `p-2 rounded-full transition-colors ${!isInConference ? "bg-gray-700 opacity-50 cursor-not-allowed" : isScreenSharing ? "bg-green-600 hover:bg-green-700" : "bg-gray-700 hover:bg-gray-600"}`,
                  children: isScreenSharing ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(MonitorOff, { className: "w-4 h-4" }) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Monitor, { className: "w-4 h-4" })
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "relative", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "button",
                  {
                    onClick: toggleCamera,
                    disabled: !isInConference,
                    className: `p-2 rounded-full transition-colors ${!isInConference ? "bg-gray-700 opacity-50 cursor-not-allowed" : isCameraOn ? "bg-green-600 hover:bg-green-700" : "bg-gray-700 hover:bg-gray-600"}`,
                    children: isCameraOn ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Video, { className: "w-4 h-4" }) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(VideoOff, { className: "w-4 h-4" })
                  }
                ),
                isCameraOn && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "button",
                  {
                    onClick: () => setShowCameraSettings(true),
                    className: "absolute -top-0.5 -right-0.5 p-0.5 bg-blue-600 hover:bg-blue-700 rounded-full transition-colors",
                    children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Sparkles, { className: "w-2.5 h-2.5" })
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "button",
                {
                  onClick: toggleHandRaise,
                  disabled: !isInConference,
                  className: `p-2 rounded-full transition-colors ${!isInConference ? "bg-gray-700 opacity-50 cursor-not-allowed" : isHandRaised ? "bg-yellow-600 hover:bg-yellow-700" : "bg-gray-700 hover:bg-gray-600"}`,
                  children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Hand, { className: "w-4 h-4" })
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "button",
                {
                  onClick: () => setShowReactions(!showReactions),
                  disabled: !isInConference,
                  className: `p-2 rounded-full transition-colors ${!isInConference ? "bg-gray-700 opacity-50 cursor-not-allowed" : "bg-gray-700 hover:bg-gray-600"}`,
                  children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Heart, { className: "w-4 h-4" })
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "relative", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "button",
                  {
                    onClick: () => toggleChat(!showChat),
                    disabled: !isInConference,
                    className: `p-2 rounded-full transition-colors ${!isInConference ? "bg-gray-700 opacity-50 cursor-not-allowed" : showChat ? "bg-blue-600 hover:bg-blue-700" : "bg-gray-700 hover:bg-gray-600"}`,
                    children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(MessageCircle, { className: "w-4 h-4" })
                  }
                ),
                unreadMessageCount > 0 && !showChat && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "absolute -top-0.5 -right-0.5 bg-red-500 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center animate-pulse", children: unreadMessageCount > 9 ? "9+" : unreadMessageCount })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "hidden md:grid md:grid-cols-3 md:items-center", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "flex justify-start", children: isInConference ? /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
              "button",
              {
                onClick: endConference,
                className: "py-1.5 px-3 bg-red-600 hover:bg-red-700 rounded-lg text-sm transition-colors flex items-center gap-1.5",
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(PhoneOff, { className: "w-3 h-3" }),
                  "Close Conference"
                ]
              }
            ) : /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
              "button",
              {
                onClick: startConference,
                className: "py-1.5 px-3 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm transition-colors flex items-center gap-1.5",
                disabled: !username || !apiKey,
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Phone, { className: "w-3 h-3" }),
                  "Start Conference"
                ]
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex justify-center gap-3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "relative", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "button",
                  {
                    onClick: toggleMute,
                    disabled: !isInConference,
                    className: `p-2 rounded-full transition-colors ${!isInConference ? "bg-gray-700 opacity-50 cursor-not-allowed" : isMuted ? "bg-gray-700 hover:bg-gray-600" : "bg-green-600 hover:bg-green-700"}`,
                    children: isMuted ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(MicOff, { className: "w-4 h-4" }) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Mic, { className: "w-4 h-4" })
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "button",
                  {
                    onClick: () => setShowAudioSettings(true),
                    className: "absolute -top-0.5 -right-0.5 p-0.5 bg-blue-600 hover:bg-blue-700 rounded-full transition-colors",
                    children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Settings, { className: "w-2.5 h-2.5" })
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "button",
                {
                  onClick: toggleScreenShare,
                  disabled: true,
                  className: "p-2 rounded-full transition-colors bg-gray-700 opacity-50 cursor-not-allowed",
                  children: isScreenSharing ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(MonitorOff, { className: "w-4 h-4" }) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Monitor, { className: "w-4 h-4" })
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "relative", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "button",
                  {
                    onClick: toggleCamera,
                    disabled: true,
                    className: "p-2 rounded-full transition-colors bg-gray-700 opacity-50 cursor-not-allowed",
                    children: isCameraOn ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Video, { className: "w-4 h-4" }) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(VideoOff, { className: "w-4 h-4" })
                  }
                ),
                false
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "button",
                {
                  onClick: toggleHandRaise,
                  disabled: !isInConference,
                  className: `p-2 rounded-full transition-colors ${!isInConference ? "bg-gray-700 opacity-50 cursor-not-allowed" : isHandRaised ? "bg-yellow-600 hover:bg-yellow-700" : "bg-gray-700 hover:bg-gray-600"}`,
                  children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Hand, { className: "w-4 h-4" })
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "button",
                {
                  onClick: () => setShowReactions(!showReactions),
                  disabled: !isInConference,
                  className: `p-2 rounded-full transition-colors ${!isInConference ? "bg-gray-700 opacity-50 cursor-not-allowed" : "bg-gray-700 hover:bg-gray-600"}`,
                  children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Heart, { className: "w-4 h-4" })
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "relative", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "button",
                  {
                    onClick: () => toggleChat(!showChat),
                    disabled: !isInConference,
                    className: `p-2 rounded-full transition-colors ${!isInConference ? "bg-gray-700 opacity-50 cursor-not-allowed" : showChat ? "bg-blue-600 hover:bg-blue-700" : "bg-gray-700 hover:bg-gray-600"}`,
                    children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(MessageCircle, { className: "w-4 h-4" })
                  }
                ),
                unreadMessageCount > 0 && !showChat && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "absolute -top-0.5 -right-0.5 bg-red-500 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center animate-pulse", children: unreadMessageCount > 9 ? "9+" : unreadMessageCount })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "flex justify-end", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
              "button",
              {
                onClick: shareRoomUrl,
                className: "py-1.5 px-3 bg-green-600 hover:bg-green-700 rounded-lg text-sm transition-colors flex items-center gap-1.5",
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Share2, { className: "w-3 h-3" }),
                  "Share"
                ]
              }
            ) })
          ] })
        ] }) }),
        showCopyModal && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "bg-gray-800 bg-opacity-95 backdrop-blur-sm p-4 rounded-lg border border-gray-700 text-center shadow-xl", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Copy, { className: "w-6 h-6 text-green-500 mx-auto mb-3" }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h3", { className: "text-base font-semibold mb-2", children: "Room URL Copied!" }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-gray-400 text-sm", children: "Share this URL with others to join the conference" })
        ] }) }),
        showCameraSettings && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "bg-gray-800 bg-opacity-95 backdrop-blur-sm p-4 rounded-lg border border-gray-700 w-80 shadow-xl", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("h3", { className: "text-base font-semibold mb-3 flex items-center gap-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Sparkles, { className: "w-4 h-4" }),
            "Camera Settings"
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "space-y-3", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "input",
                {
                  type: "checkbox",
                  checked: isBackgroundBlur,
                  onChange: (e) => setIsBackgroundBlur(e.target.checked),
                  className: "rounded bg-gray-700 border-gray-600"
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-sm", children: "Background Blur" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "input",
                {
                  type: "checkbox",
                  checked: isBeautyMode,
                  onChange: (e) => setIsBeautyMode(e.target.checked),
                  className: "rounded bg-gray-700 border-gray-600"
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-sm", children: "Beauty Mode" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "block text-xs font-medium mb-2 flex items-center gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Sun, { className: "w-3 h-3" }),
                "Brightness",
                /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { className: "text-gray-400", children: [
                  "(",
                  brightness,
                  "%)"
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "input",
                {
                  type: "range",
                  min: "50",
                  max: "150",
                  value: brightness,
                  onChange: (e) => setBrightness(Number(e.target.value)),
                  className: "w-full h-1.5 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                }
              )
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "button",
              {
                onClick: () => setShowCameraSettings(false),
                className: "w-full py-1.5 px-3 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm transition-colors",
                children: "Close"
              }
            )
          ] })
        ] }) }),
        showAudioSettings && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "bg-gray-800 bg-opacity-95 backdrop-blur-sm p-4 rounded-lg border border-gray-700 w-80 shadow-xl", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("h3", { className: "text-base font-semibold mb-3 flex items-center gap-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Headphones, { className: "w-4 h-4" }),
            "Audio Settings"
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "space-y-3", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "block text-xs font-medium mb-1 flex items-center gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Mic, { className: "w-3 h-3" }),
                "Microphone"
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "select",
                {
                  value: selectedMicrophone,
                  onChange: (e) => changeMicrophone(e.target.value),
                  className: "w-full px-2 py-1.5 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:border-blue-500 text-sm",
                  children: audioInputDevices.map((device) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("option", { value: device.deviceId, children: device.label || `Microphone ${device.deviceId.slice(0, 8)}` }, device.deviceId))
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "mt-2", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "flex items-center text-xs font-medium", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "input",
                  {
                    type: "checkbox",
                    checked: !sendRawAudio,
                    onChange: () => toggleSendRawAudio(),
                    className: "mr-2 bg-gray-700 border-gray-600 rounded focus:ring-blue-500"
                  }
                ),
                "Send only translated audio (disable raw audio)"
              ] }) }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "mt-3 pt-3 border-t border-gray-600", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center justify-between mb-2", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "flex items-center text-xs font-medium", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Funnel, { className: "w-3 h-3 mr-1" }),
                    "Noise Filter"
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                      "input",
                      {
                        type: "checkbox",
                        checked: noiseFilterSettings.enabled,
                        onChange: toggleNoiseFilter,
                        className: "bg-gray-700 border-gray-600 rounded focus:ring-blue-500"
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "ml-2 text-xs text-gray-400", children: noiseFilterSettings.enabled ? "ON" : "OFF" })
                  ] })
                ] }),
                noiseFilterSettings.enabled && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "space-y-2 ml-4 text-xs", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "block text-gray-400 mb-1", children: [
                      "High-pass Filter (",
                      noiseFilterSettings.highPassFrequency,
                      "Hz)"
                    ] }),
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                      "input",
                      {
                        type: "range",
                        min: "50",
                        max: "300",
                        value: noiseFilterSettings.highPassFrequency,
                        onChange: (e) => updateNoiseFilterSettings({
                          highPassFrequency: Number(e.target.value)
                        }),
                        className: "w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "block text-gray-400 mb-1", children: [
                      "Low-pass Filter (",
                      noiseFilterSettings.lowPassFrequency,
                      "Hz)"
                    ] }),
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                      "input",
                      {
                        type: "range",
                        min: "4000",
                        max: "12000",
                        value: noiseFilterSettings.lowPassFrequency,
                        onChange: (e) => updateNoiseFilterSettings({
                          lowPassFrequency: Number(e.target.value)
                        }),
                        className: "w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "block text-gray-400 mb-1", children: [
                      "Compression Ratio (",
                      noiseFilterSettings.compressionRatio.toFixed(1),
                      ")"
                    ] }),
                    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                      "input",
                      {
                        type: "range",
                        min: "1",
                        max: "8",
                        step: "0.5",
                        value: noiseFilterSettings.compressionRatio,
                        onChange: (e) => updateNoiseFilterSettings({
                          compressionRatio: Number(e.target.value)
                        }),
                        className: "w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                      }
                    )
                  ] })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "block text-xs font-medium mb-1 flex items-center gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Volume2, { className: "w-3 h-3" }),
                "Speaker"
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "select",
                {
                  value: selectedSpeaker,
                  onChange: (e) => changeSpeaker(e.target.value),
                  className: "w-full px-2 py-1.5 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:border-blue-500 text-sm",
                  children: audioOutputDevices.map((device) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("option", { value: device.deviceId, children: device.label || `Speaker ${device.deviceId.slice(0, 8)}` }, device.deviceId))
                }
              )
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "block text-xs font-medium mb-1 flex items-center gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Languages, { className: "w-3 h-3" }),
                "Translation Speed"
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "space-y-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "flex items-center gap-2 text-xs", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                    "input",
                    {
                      type: "radio",
                      name: "translationSpeed",
                      value: "ultrafast" /* ULTRAFAST */,
                      checked: translationSpeedMode === "ultrafast" /* ULTRAFAST */,
                      onChange: (e) => updateTranslationSpeedMode(e.target.value),
                      className: "text-blue-600 bg-gray-700 border-gray-600"
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: "Ultra-fast (15x Cost)" }),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-gray-400 ml-auto", children: "~0.3s delay" })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "flex items-center gap-2 text-xs", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                    "input",
                    {
                      type: "radio",
                      name: "translationSpeed",
                      value: "realtime" /* REALTIME */,
                      checked: translationSpeedMode === "realtime" /* REALTIME */,
                      onChange: (e) => updateTranslationSpeedMode(e.target.value),
                      className: "text-blue-600 bg-gray-700 border-gray-600"
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: "Real-time (5x Cost)" }),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-gray-400 ml-auto", children: "~1s delay" })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "flex items-center gap-2 text-xs", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                    "input",
                    {
                      type: "radio",
                      name: "translationSpeed",
                      value: "balanced" /* BALANCED */,
                      checked: translationSpeedMode === "balanced" /* BALANCED */,
                      onChange: (e) => updateTranslationSpeedMode(e.target.value),
                      className: "text-blue-600 bg-gray-700 border-gray-600"
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: "Balanced (2x Cost)" }),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-gray-400 ml-auto", children: "~2s delay" })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("label", { className: "flex items-center gap-2 text-xs", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                    "input",
                    {
                      type: "radio",
                      name: "translationSpeed",
                      value: "economy" /* ECONOMY */,
                      checked: translationSpeedMode === "economy" /* ECONOMY */,
                      onChange: (e) => updateTranslationSpeedMode(e.target.value),
                      className: "text-blue-600 bg-gray-700 border-gray-600"
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: "Economy (Low Cost)" }),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-gray-400 ml-auto", children: "~4s delay" })
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "mt-2 p-2 bg-gray-700 rounded text-xs", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex justify-between items-center", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-gray-400", children: "Estimated hourly cost:" }),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { className: "text-yellow-400 font-medium", children: [
                  "$",
                  (0.5 * translationSpeedSettings.estimatedCostMultiplier).toFixed(2),
                  "/hour"
                ] })
              ] }) })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "button",
              {
                onClick: getAudioDevices,
                className: "w-full py-1.5 px-3 bg-green-600 hover:bg-green-700 rounded-lg text-sm transition-colors mb-2",
                children: "Refresh Devices"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "text-xs text-gray-400 mb-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("p", { children: [
                "Found ",
                audioInputDevices.length,
                " microphone(s), ",
                audioOutputDevices.length,
                " speaker(s)"
              ] }),
              audioOutputDevices.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-yellow-400", children: "Note: Some browsers may not show all audio output devices due to security restrictions." })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "button",
              {
                onClick: () => setShowAudioSettings(false),
                className: "w-full py-1.5 px-3 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm transition-colors",
                children: "Close"
              }
            )
          ] })
        ] }) }),
        showReactions && isInConference && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "fixed bottom-16 left-1/2 transform -translate-x-1/2 bg-gray-800 bg-opacity-95 backdrop-blur-sm p-3 rounded-lg border border-gray-700 flex gap-1.5 shadow-xl z-30", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "button",
            {
              onClick: () => sendReaction("\u{1F44D}"),
              className: "p-1.5 hover:bg-gray-700 rounded transition-colors text-xl",
              children: "\u{1F44D}"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "button",
            {
              onClick: () => sendReaction("\u2764\uFE0F"),
              className: "p-1.5 hover:bg-gray-700 rounded transition-colors text-xl",
              children: "\u2764\uFE0F"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "button",
            {
              onClick: () => sendReaction("\u{1F60A}"),
              className: "p-1.5 hover:bg-gray-700 rounded transition-colors text-xl",
              children: "\u{1F60A}"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "button",
            {
              onClick: () => sendReaction("\u{1F44F}"),
              className: "p-1.5 hover:bg-gray-700 rounded transition-colors text-xl",
              children: "\u{1F44F}"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "button",
            {
              onClick: () => sendReaction("\u{1F389}"),
              className: "p-1.5 hover:bg-gray-700 rounded transition-colors text-xl",
              children: "\u{1F389}"
            }
          )
        ] }),
        showChat && isInConference && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "fixed right-3 bottom-16 w-72 h-80 bg-gray-800 bg-opacity-95 backdrop-blur-sm rounded-lg border border-gray-700 flex flex-col shadow-xl z-30", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "p-3 border-b border-gray-700", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("h3", { className: "text-base font-semibold flex items-center justify-between", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(MessageCircle, { className: "w-4 h-4" }),
              "Chat"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "button",
              {
                onClick: () => toggleChat(false),
                className: "text-gray-400 hover:text-white text-sm",
                children: "\u2715"
              }
            )
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "flex-1 p-3 overflow-y-auto", children: chatMessages.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-gray-400 text-center text-sm", children: "No messages yet..." }) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "space-y-2", children: chatMessages.map((msg) => {
            const isOwnMessage = msg.from === username;
            const readByOthers = msg.readBy?.filter((reader) => reader !== msg.from) || [];
            const allParticipantsCount = participants.length;
            const otherParticipantsCount = allParticipantsCount - 1;
            return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "p-2 bg-gray-700 rounded", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center justify-between text-xs text-gray-400 mb-1", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: msg.from }),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: msg.timestamp })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-xs", children: msg.message }),
              isOwnMessage && readByOthers.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "text-xs text-blue-400 mt-1 flex items-center gap-1", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: "\u2713\u2713" }),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("span", { children: [
                  "Read by ",
                  readByOthers.length,
                  otherParticipantsCount > 0 && ` of ${otherParticipantsCount}`
                ] })
              ] }),
              isOwnMessage && readByOthers.length === 0 && otherParticipantsCount > 0 && /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "text-xs text-gray-500 mt-1 flex items-center gap-1", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: "\u2713" }),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: "Delivered" })
              ] })
            ] }, msg.id);
          }) }) }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "p-3 border-t border-gray-700", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("form", { onSubmit: (e) => {
            e.preventDefault();
            sendChatMessage();
          }, className: "flex gap-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "input",
              {
                type: "text",
                value: chatInput,
                onChange: (e) => setChatInput(e.target.value),
                placeholder: "Type a message...",
                className: "flex-1 px-2 py-1.5 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:border-blue-500 text-sm"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "button",
              {
                type: "submit",
                className: "px-3 py-1.5 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors text-sm",
                children: "Send"
              }
            )
          ] }) })
        ] }),
        showErrorModal && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "bg-gray-800 bg-opacity-95 backdrop-blur-sm border border-gray-700 rounded-lg p-6 max-w-md w-full mx-4 shadow-xl", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center gap-3 mb-4", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "w-8 h-8 bg-red-600 rounded-full flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-white text-lg font-bold", children: "!" }) }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h3", { className: "text-lg font-semibold text-white", children: "Error" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-gray-300 mb-6 leading-relaxed", children: errorMessage }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "button",
            {
              onClick: () => setShowErrorModal(false),
              className: "w-full py-2 px-4 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm transition-colors font-medium",
              children: "Close"
            }
          )
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("video", { ref: videoRef, style: { display: "none" } }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("canvas", { ref: canvasRef, style: { display: "none" } })
      ] })
    ] });
  };

  // main.tsx
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  window.React = import_react6.default;
  window.ReactDOM = { createRoot: import_client.createRoot };
  window.GenerativeArtBackgroundWebGL = GenerativeArtBackgroundWebGL;
  var App = () => {
    const conferenceProps = useConferenceApp();
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(ConferenceApp, { ...conferenceProps });
  };
  var container = document.getElementById("root");
  if (container) {
    const root = (0, import_client.createRoot)(container);
    root.render(/* @__PURE__ */ (0, import_jsx_runtime3.jsx)(App, {}));
  }
  var main_default = App;
})();
/*! Bundled license information:

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.js:
  (**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.js:
  (**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.production.js:
  (**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@google/genai/dist/web/index.mjs:
  (**
   * @license
   * Copyright 2025 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/shared/src/utils.js:
lucide-react/dist/esm/defaultAttributes.js:
lucide-react/dist/esm/Icon.js:
lucide-react/dist/esm/createLucideIcon.js:
lucide-react/dist/esm/icons/copy.js:
lucide-react/dist/esm/icons/funnel.js:
lucide-react/dist/esm/icons/hand.js:
lucide-react/dist/esm/icons/headphones.js:
lucide-react/dist/esm/icons/heart.js:
lucide-react/dist/esm/icons/languages.js:
lucide-react/dist/esm/icons/message-circle.js:
lucide-react/dist/esm/icons/mic-off.js:
lucide-react/dist/esm/icons/mic.js:
lucide-react/dist/esm/icons/monitor-off.js:
lucide-react/dist/esm/icons/monitor.js:
lucide-react/dist/esm/icons/phone-off.js:
lucide-react/dist/esm/icons/phone.js:
lucide-react/dist/esm/icons/settings.js:
lucide-react/dist/esm/icons/share-2.js:
lucide-react/dist/esm/icons/sparkles.js:
lucide-react/dist/esm/icons/sun.js:
lucide-react/dist/esm/icons/users.js:
lucide-react/dist/esm/icons/video-off.js:
lucide-react/dist/esm/icons/video.js:
lucide-react/dist/esm/icons/volume-2.js:
lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.511.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
